-- Wait for the game to be fully loaded
if not game:IsLoaded() then game.Loaded:Wait() end;
task.wait(3)
print("exo start > ")
--print("PlaceId:", game.PlaceId) -- 129954712878723
local _S                         = {}

-- Game services

_S.HttpService                   = game:GetService("HttpService")
_S.ReplicatedStorage             = game:GetService("ReplicatedStorage")
_S.Workspace                     = game:GetService("Workspace")
_S.TeleportService               = game:GetService("TeleportService")
_S.Players                       = game:GetService("Players")
_S.RunService                    = game:GetService("RunService")
_S.MarketplaceService            = game:GetService("MarketplaceService")

-- Local player and character
_S.LocalPlayer                   = _S.Players.LocalPlayer
_S.Character                     = _S.LocalPlayer.Character or _S.LocalPlayer.CharacterAdded:Wait()
_S.Backpack                      = _S.LocalPlayer:WaitForChild("Backpack")
_S.PlayerGui                     = _S.LocalPlayer:WaitForChild("PlayerGui")
_S.player_humanoid               = _S.Character:FindFirstChildOfClass("Humanoid")

-- Game events
_S.GameEvents                    = _S.ReplicatedStorage:WaitForChild("GameEvents")
_S.petsServiceRemote             = _S.GameEvents:WaitForChild("PetsService")
_S.PetEggService                 = _S.GameEvents:WaitForChild("PetEggService")
_S.BuyGearStock                  = _S.GameEvents.BuyGearStock
_S.BuySeedStock                  = _S.GameEvents.BuySeedStock
_S.BuyPetEgg                     = _S.GameEvents.BuyPetEgg
_S.BuyTravelingMerchantShopStock = _S.GameEvents:WaitForChild("BuyTravelingMerchantShopStock")
_S.SellPetRemote                 = _S.GameEvents:WaitForChild("SellPet_RE")
_S.SellAllPetsRemote             = _S.GameEvents:WaitForChild("SellAllPets_RE")
_S.Sell_Inventory                = _S.GameEvents.Sell_Inventory
_S.DataStream                    = _S.GameEvents.DataStream
_S.PlantRemote                   = _S.GameEvents:WaitForChild("Plant_RE")
_S.collectEvent                  = _S.GameEvents:WaitForChild("Crops"):WaitForChild("Collect")
_S.FavItem                       = _S.GameEvents:WaitForChild("Favorite_Item")
_S.BuyEventShopStock             = _S.GameEvents:WaitForChild("BuyEventShopStock")
_S.BoostService                  = _S.GameEvents:WaitForChild("PetBoostService")
_S.TrowelRemote                  = _S.GameEvents:WaitForChild("TrowelRemote")
_S.MutationService               = _S.GameEvents:WaitForChild("PetMutationMachineService_RE")
_S.ActivePetService              = _S.GameEvents:WaitForChild("ActivePetService")
_S.SellPetShopSelected           = _S.GameEvents:WaitForChild("SellPetShopSelected")

_S.SprayService_RE               = _S.GameEvents:WaitForChild("SprayService_RE")
_S.CookingPotService_RE          = _S.GameEvents:WaitForChild("CookingPotService_RE")
_S.CraftingGlobalObjectService   = _S.GameEvents:WaitForChild("CraftingGlobalObjectService");
_S.SprinklerService              = _S.GameEvents:WaitForChild("SprinklerService")
_S.Water_RE                      = _S.GameEvents:WaitForChild("Water_RE")
_S.BonfireService                = _S.GameEvents:WaitForChild("BonfireService")
_S.Remove_Item                   = _S.GameEvents.Remove_Item                    -- RemoteEvent
_S.DeleteObject                  = _S.ReplicatedStorage.GameEvents.DeleteObject -- RemoteEvent
--_S.TieredPlants = _S.GameEvents:WaitForChild("TieredPlants"):WaitForChild("Submit")
_S.PetLeadService_RE             = _S.GameEvents.PetLeadService_RE
_S.PetCooldownsUpdated           = _S.GameEvents.PetCooldownsUpdated
_S.TryUseGear                    = _S.GameEvents.TryUseGear -- RemoteEvent
_S.TryMapleSyrup                 = _S.GameEvents.TryMapleSyrup
_S.Reclaimer                     = _S.GameEvents.ReclaimerService_RE

_S.BuySeasonPassStock            = _S.GameEvents:WaitForChild("SeasonPass"):WaitForChild("BuySeasonPassStock")

-- Containers
_S.petsContainer                 = _S.Workspace:WaitForChild("PetsPhysical")

-- UI references
_S.GearShopUI                    = _S.PlayerGui:WaitForChild("Gear_Shop")
_S.SeedShopUI                    = _S.PlayerGui:WaitForChild("Seed_Shop")
_S.PetShopUI                     = _S.PlayerGui:WaitForChild("PetShop_UI")
_S.TravelingMerchantShop_UI      = _S.PlayerGui:WaitForChild("TravelingMerchantShop_UI")

_S.DigRemote                     = _S.GameEvents:WaitForChild("DiggingMiniGame"):WaitForChild("DigRemoteEvent")

-- Modules
_S.fails                         = 0
function _S.safeRequire(path)
    local ok, result = pcall(require, path)
    if not ok or result == nil then
        warn("[SafeRequire] Failed to load:", path)
        _S.fails = _S.fails + 1
        return nil
    end
    return result
end

_S.DataService                         = _S.safeRequire(_S.ReplicatedStorage.Modules.DataService)
_S.ActivePetsService                   = _S.safeRequire(_S.ReplicatedStorage.Modules.PetServices.ActivePetsService)
_S.SeedData                            = _S.safeRequire(_S.ReplicatedStorage.Data.SeedData)
_S.PetUtilities                        = _S.safeRequire(_S.ReplicatedStorage.Modules.PetServices.PetUtilities)
_S.PlantTraitsData                     = _S.safeRequire(_S.ReplicatedStorage.Modules.PlantTraitsData)
_S.CraftingData_CraftingRecipeRegistry = _S.safeRequire(_S.ReplicatedStorage.Data.CraftingData.CraftingRecipeRegistry)
_S.FoodRecipeData                      = _S.safeRequire(_S.ReplicatedStorage.Data.FoodRecipeData)
_S.GearData                            = _S.safeRequire(_S.ReplicatedStorage.Data.GearData)
_S.SeasonPassShop                      = _S.safeRequire(_S.ReplicatedStorage.Data.SeasonPass.SeasonPassShopData)
_S.EventShopData                       = _S.safeRequire(_S.ReplicatedStorage.Data.EventShopData)
_S.PetList                             = _S.safeRequire(_S.ReplicatedStorage.Data.PetRegistry.PetList)
_S.PetRegistry                         = _S.safeRequire(_S.ReplicatedStorage.Data.PetRegistry)

_S.PetMutationRegistry                 = _S.safeRequire(_S.ReplicatedStorage.Data.PetRegistry.PetMutationRegistry)
_S.TravelingMerchantData               = _S.safeRequire(_S.ReplicatedStorage.Data.TravelingMerchant
    .TravelingMerchantData)
--_S.PetsService = require(_S.ReplicatedStorage.Modules.PetServices.PetsService)

_S.SeedPackData                        = _S.safeRequire(_S.ReplicatedStorage.Data.SeedPackData)
_S.VariantsEnums                       = _S.safeRequire(_S.ReplicatedStorage.Data.EnumRegistry.VariantsEnums)



function Addcantsleep()
    if (getconnections or get_signal_cons) then
        for i, v in pairs((getconnections or get_signal_cons)(_S.LocalPlayer.Idled)) do
            if v["Disable"] then
                v["Disable"](v)
            elseif v["Disconnect"] then
                v["Disconnect"](v)
            end
        end
    end
end

pcall(function()
    Addcantsleep()
end)



-- Alt backpack location
_S.ReplicatedStorageSharedFolder = _S.ReplicatedStorage:WaitForChild("Shared")
task.wait(1)

-- Webhook / Proxy
_S.WEBHOOK_URL = ""
_S.PROXY_URL = "https://bit.ly/exotichubp"




-- [SETUP UI]
--local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/9kinc/autoegg/refs/heads/main/ui.lua"))()
local Library = loadstring(game:HttpGet("https://exotichub.app/ui_loader.lua"))()
--local Library = getgenv().Library
if Library then
    Library:SetWatermarkVisibility(false)
    Library:SetWatermark("0:0:00")
end

if not Library then
    print("Ui Lib failed to load. Stopping")
    return
end

-- #start
_S.AppName = "Exotic Hub"
_S.CurentV = "v1.28.9"

local Varz = {}
Varz.dev_tools = true
Varz.is_pro = true
-- #pro

Varz.TEXT_HATCH_SYSTEM = ""
Varz.TEXT_AGEBREAK = ""
Varz.TEXT_CRAFT_TEAMS = ""
Varz.TEXT_TEAM_SYSTEM = ""
Varz.event_seeding_active = false
Varz.event_seeding_list = {}
Varz.alt_Plants_Physical = nil
Varz.RNG_EGG_OVERRIDE = 0
Varz.WAS_PRO_END = false

_S.LocalPlayer.CameraMaxZoomDistance = 350

-- Make required folders
-- Create a new folder
Varz.MakeAltFolder = function()
    local myFolder = Instance.new("Folder")
    myFolder.Name = "Plants_Physical"
    myFolder.Parent = _S.ReplicatedStorage
    Varz.alt_Plants_Physical = _S.ReplicatedStorage:FindFirstChild("Plants_Physical")
end
Varz.MakeAltFolder()

Varz.GetCheckIfPro = function()
    return Varz.is_pro
end



if _S.fails > 0 then
    warn("[EXO] --<> Important data not loaded. Please rejoin!")
end


-- UI Labels
local UI_LABELS = {
    lbl_home_info = nil,
    lbl_pet_mutation_status = nil,
    lbl_mutation_machine_status = nil,
    lbl_stats = nil,
    lbl_fruit_collect_live = nil,
    lbl_pet_system_live = nil,
    lbl_craftinggear_stats = nil,
    lbl_crafting_timeleft = nil,
    lbl_cooking_display_time = nil,
    lbl_cooking_stats = nil,
    lbl_ascenstats = nil,
    lbl_ascen_current_requirement = nil,
    lbl_ascen_cd = nil,
    lbl_selected_team1_count = nil,
    lbl_selected_team2_count = nil,
    lbl_selected_team3_count = nil,
    lbl_selected_team4_count = nil,
    lbl_reclaimer_stats = nil,
    lbl_smithman_status = nil,

    lbl_tradeevent_status = nil,

    lbl_craftteams_status = nil,

    lbl_agebreak_status = nil,

    lbl_pet_level_status = nil,
    lbl_pet_level_info = nil,

    lbl_marmot_information = nil,

    lbl_chubby_chipmunk_information = nil,
    lbl_redpanda_information = nil,
    lbl_elephant_booster_status = nil,

    -- trowel
    lbl_trowel_stats = nil,
    lbl_trowel_cframe = nil,
    lbl_trowel_progress = nil,

    -- water
    lbl_watering_stats = nil,
    lbl_watering_information = nil,

    -- shovel
    lbl_shovel_status = nil,
    lbl_shovel_information = nil,

    --  dropdowns
    MultiDropdownSellTeam = nil,
    MultiDropdownHatchTeam = nil,
    MultiDropdownEggReductionTeam = nil,
    MultiDropdownEggPetSizeTeam = nil,

    -- seed placement
    lbl_seed_information = nil,
    lbl_seed_location = nil,
    lbl_seed_status = nil,

    -- fall martket event
    lbl_fallevent_stats = nil,
    lbl_fallevent_progress = nil,
    lbl_fallevent_required_fruits = nil,
    lbl_fallevent_fall_bloom = nil,
    lbl_fallevent_fruit_ls = nil,

    -- jungle
    lbl_jungle_stats = nil,
    lbl_jungle_information = nil,


    lbl_questline_status = nil,
    lbl_questline_info = nil,

    lbl_farm_plants_counts = nil,
    lbl_sell_inventory_pets = nil,
}

Varz.UI_Buttons = {
    ButtonAutoCook = nil
}

local UI_Dropdown = {
    DropDownMarket = nil,
    ShovelDropDown = nil,
    PetLevelDropDown = nil,
    PetBoostSelectDropdown = nil,

    dropdown_support_team = nil,
    dropdown_target_team = nil,
    dropdown_mut_cd_team = nil,
    dropdown_claimpet_team = nil,

    customteams_team1 = nil,
    dd_reduction_teamfirst = nil,
    dd_reduction_teamafter = nil,

    agebreaktarget_team = nil,
    agebreakdup_team = nil,
    agebreakidle_team = nil,
    agebreakclaim_team = nil,
    agebreaksubmit_team = nil,

    craftteam_claim = nil,
    craftteam_submit = nil,
    craftteam_idle = nil,

    dropdown_petmutation_maxlevelteam = nil,
    dropdown_petmut_xpteam = nil,
    dropdown_petfiller_team = nil,
    dropdown_pettargetteam = nil,
    dropdown_petmutationteam = nil,
    dropdown_petbaseweightteam = nil,
    dropdown_sell_inventory_pets = nil,
}

Varz.UI_Toggles = {
    ToggleUnlockStore = nil,
}

-- #elephant
Varz.max_required_weight_elephant = 2.10
--#pickplace
Varz.pickplace_disable_delay = 0 -- how long to disable the pickplace system for
Varz.SetDisablePickPlaceFor = function(secs)
    if Varz.pickplace_disable_delay < 1 then
        Varz.pickplace_disable_delay = secs
    end
end

-- save for mutations and others
local FOtherSettings = {
    max_eggs_to_place = 0,
    -- mutation machine
    mut_max_level_successfulpets = false,
    mut_batch_process_enable = false,
    mut_pet_mode_enable = false,
    mut_batch_process_turn = "levelteam",
    mut_target_pets_uuid = {},
    mut_target_mutations = {},
    mut_support_team = {},
    mut_mutation_machineteam = {},
    mut_claimpet_team = {},
    mut_required_level = 50,
    mut_required_level_item = 40,
    mut_pet_inside_mutation = "",
    mut_was_running = false,
    max_mutation_count = 0,

    -- Chubby Chipmunk
    chubby_chipmunk_amount_collected = 0,
    chubby_chipmunk_auto_collect = true,
    chubby_chipmunk_item_watering_can = 0,
    chubby_chipmunk_item_event_lantern = 0,
    chubby_chipmunk_item_godly_sprinkler = 0,
    chubby_chipmunk_item_legendary_egg = 0,
    chubby_chipmunk_item_reclaimer = 0,
    chubby_chipmunk_item_nutty_crate = 0,
    chubby_chipmunk_item_silver_fertilizer = 0,
    chubby_chipmunk_item_nutty_chest = 0,
    chubby_chipmunk_item_master_sprinkler = 0,
    chubby_chipmunk_item_medium_treat = 0,
    chubby_chipmunk_item_medium_toy = 0,
    chubby_chipmunk_item_mythical_egg = 0,
    chubby_chipmunk_item_grandmaster_sprinkler = 0,
    chubby_chipmunk_item_rainbow_fertilizer = 0,
    chubby_chipmunk_item_petshardnutty = 0,

    -- marmot
    marmot_amount_collected = 0,
    marmot_auto_collect = true,
    marmot_item_firefly = 0,
    marmot_item_maple_leaf_kite = 0,
    marmot_item_sky_lantern = 0,
    marmot_item_leaf_blower = 0,
    marmot_item_maple_syrup = 0,
    marmot_item_maple_sprinkler = 0,
    marmot_item_golden_acorn = 0,

    -- jungle
    is_auto_jungle = false,

    feeding_auto_collectfruits = true,
    feed_food_insteadoffruits = false,
    feeding_pets_timer = 120,
    feeding_pets_auto = false,
    force_feed_all_pets = false,
    feeding_list_pets = {},
    pet_level_boost_list = "-",
    pet_auto_level_auto = false,
    pet_auto_level_max = 1,
    pet_auto_level_min = 0,
    pet_level_selected_pets = {},
    feeding_exlude_food_list = {},
    g_fruit_weight_max = 99,
    g_fruit_weight_min = 0,
    is_fall_event_running = false,
    is_fall_event_fastmode = false,
    is_fall_questline_auto = false,
    is_fall_questline_reroll = false,
    is_playerstats_running = true,
    hatch_rare_withbigsizetm = false,
    web_api_key = "",
    ascension_max_seeds = 1,
    auto_ascension = false,
    auto_sellbackpack = false,
    is_collect_fruit = false,
    pet_override_weight = {},
    mutation_whitelist = {},
    mutation_blacklist = {},
    fruit_variants_select = {},
    fruit_collector_turbo = false,
    collection_plants = {},
    sell_mutation_whitelist = {},
    sell_mutation_blacklist = {},
    sell_fruit_list = {},
    auto_sell_backpack_time = false,
    auto_sell_backpack_every = 60,

    -- SeasonPassShop
    season_pass_shop_items = {},

    -- Cooking
    cook_potone_item1 = "-",
    cook_potone_item2 = "-",
    cook_potone_item3 = "-",
    cook_potone_item4 = "-",
    cook_potone_item5 = "-",
    is_auto_cook = false,
    cooking_autocollect_required = true,
    cooking_autoplant_required = true,
    -- trowel etc
    trowel_plants_list = {},
    trowel_saved_cframe = "0,0,0",
    shovel_plants_list = {},
    shovel_keep_amount = 0,
    is_auto_shovel = false,

    -- water
    watering_list_plants = {},
    watering_is_auto = false,
    watering_amount_to_water = 2,
    watering_speed_time = 0.3,

    -- event shops
    fall_pets_shop = {},
    fall_seeds_shop = {},
    fall_cosmetic_shop = {},
    fall_gear_shop = {},

    jungle_seed_stages1 = {},
    jungle_auto_plants_list = {},

    -- team based boosts
    boost_auto_team_placed_koi = false,
    boost_koi_team_list = {},
    boost_sprinkler_koi_team = false,

    -- sprinklers
    is_auto_place_sprinkler_hatch = false,

    -- craft
    list_gear_event_workbench = {},
    is_auto_craft = false,
    craft_autoplant_workbench = true,
    craft_autofruit_workbench = true,
    quest_recoll_max_cost = "1.6M",

    seed_placement_list = {},
    is_auto_seed = false,
    seed_keep_amount = 0,
    seed_speed_timer1 = 0.5,
    is_seed_random = true,
    seed_location_vector = "0,0,0",

}


local FSessionDx = {
    was_dc = false,
    LevelTimer = {
        times = {},
        startTime = 0,
    },
    test_a = {},
    farm = {
        delete_plants = true,
        delete_fruits = true,
        change_parent = false,
        enable_delete_fruits = false,
    },
    timerecording = {},
    oldtest = {},
}

-- Save and other settings
local FSettings = {
    is_pc_mode = false,
    fast_ascen = false,
    rng_use_system = false,
    rng_auto_rejoin = false,
    char_farm_middle = false,
    fav_fruit_enhancer = false,
    fav_fruit_enhance_sell = false,
    is_running_custom_teams = false,
    customteams_team1 = {},
    pause_systems = false,
    disable_event_notify_button = false,
    auto_claim_season_points = false,
    only_show_baseweight = false,
    use_noti = false,
    fast_egg_placement = false,
    safe_fruits = {},
    tradeevent = {
        enable_trade_event = false,
        fruit_collect = true,
        seed_place = false,

    },
    overridepets = {
        selected_pets = {},
        is_enabled = false,
        delay_amount = 0.9,
    },
    craftevent = {
        smith_auto = false,
        egg_list = {},
        gear_list = {},
        fruit_list = {},
    },
    agebreak = {
        is_active_agebreak = false,
        target_team = {},
        dup_team = {},
        claim_team = {},
        submit_team = {},
        idle_team = {},
        max_level = 125,
        use_filters = false,
        avoid_age_filter = false,
        avoid_weight_filter = true,
    },
    allcraft = {
        auto_craft_event = false,
        teams_enabled = false,
        receipe_data = {},
        team_claim = {},
        team_submit = {},
        team_idle = {},
    },
    reclaim = {
        plants = {},
        keep_amount = 0,
    },
    elephant = {
        boost_list = {},
        pet_list = {},
        delay_before_unequip = 0.4,
        delay_before_place = 0.2,
        boost_amount = 1,
    },
    seedpack = {
        is_active = false,
        selected_packs = {},
        openwithoutui = false,
    },
    auto_restartjoin_server = false,
    auto_rejoin_after_hatchcount = 30,
    halloween = {
        shops = {},
        auto_dig = true,
        auto_reaper = true,
    },
    sellingpets = {
        manual_sell_fav = false,
        auto_pet_sell = false,
        auto_sell_weight_min = 0,
        auto_sell_age = 0,
        auto_sell_override_fav = false,
        auto_sell_selected = {},
    },

    mut_system = {
        level = 40,
        lvl_baseweight = 40,
        required_weight = 2.10,
        turbo_max_level = 25,
        custom_max_level = 100,
        only_level_mode = false,
        is_ruuning = false,
        maxlevel_team = {},
        xpteam = {},
        mut_team = {},
        baseweight_team = {},
        targetteam = {},
        filler_team = {},
        wanted = {},
        state = "level",
        max_level_enable = true,
        max_lvl_batch = true,
        continue_enable = true,
        elephant_hotswap = true,
        single_unit_allowed = false,
        is_baseweight_mode = false,
        turbo_xp_teams = false,
    },
    show_activepets_ui = true,
    auto_remove_sprinklers = false,
    auto_remove_sp_list = {},
    mutation_boost_team_claim = {},
    mutation_boost_claim_enabled = false,
    mutation_boost_level_team = {},
    mutation_boost_level_team_enabled = false,
    mutation_boost_cd_team = {},
    mutation_boost_cd_team_enabled = false,
    red_panda_restock = {},
    red_panda_restock_total = 0,
    red_panda_record_items = true,

    pet_mutation_boost_list = {},
    pet_mutation_team_boost_enabled = false,
    pet_mutation_team_list = {},

    pet_mut_xpteam_boosts = {},
    pet_mut_xpteam_boost_enabled = false,
    pet_mut_xpteam_petlist = {},

    ui_rescale_val = 100,

    -- hatching team boosts
    hatch_boost_seal_team = {},
    hatch_boost_seal_enabled = false,
    hatch_boost_bron_team = {},
    hatch_boost_bron_enabled = false,
    hatch_boost_eggcd_team = {},
    hatch_team_boost_targets = {},
    hatch_boost_eggcd_enabled = false,
    always_active_boosts = true,

    merchant_shop_data = {},
    disconnect_rejoin = false,
    is_sell_only_hatch_pet = true,
    is_auto_hatch_enabled = false,
    is_egg_esp = true,
    is_fairy_scanner_active = false,
    buy_gearshop = false,
    buy_seedshop = false,
    buy_eggshop = false,
    buy_merchant = false,
    gearshop_items = {},
    seedshop_items = {},
    eggshop_items = {},
    is_test = false,
    is_hatch_in_batch = true,
    hatch_sell_delayed = false,
    is_session_based = true,
    is_first_time = true,
    is_auto_rejoin = false,
    is_running = false,
    is_age_hatch_mode = false,
    hatch_mode_age_to_keep = 75,
    sell_weight = 3,
    sell_age = 0,
    pet_team_size = 8,
    pets_hatched_total = 0,
    eggs_hatched_in_10_min_session = 0,
    eggs_hatched_in_hourly_session = 0,
    last_10min_report_time = 0,
    last_hourly_report_time = 0,
    disable_team1 = false,
    disable_team2 = false,
    disable_team3 = false,
    disable_team4 = false,
    disable_team5 = false, -- added
    disable_team6 = false, -- adedd
    disable_team7 = false, -- added
    auto_hatch_big_pets = true,
    send_everyhatch_alert = true,
    send_rare_pet_alert = true,
    send_big_pet_alert = true,
    auto_remove_plants_folder = false,
    webhook_url = _S.WEBHOOK_URL,
    mut_webhook_url = "",
    team1 = {},
    team2 = {},
    team3 = {}, -- added
    team4 = {}, -- added
    team5 = {}, -- added
    team6 = {}, -- added
    team7 = {}, -- added
    team_reduction_placefirst = {},
    team_reduction_placeafter = {},
    team_reduction_timer = 16.5,
    team_reduction_enabled_teams = false,
    hatch_fast_mode = false,
    hatch_slow_mode = false,
    pet_pickplacehatchingstage = {},
    pet_pickplace_enabled = false,
    pet_pickplace_anywhere = false,
    pet_pickplace_threading = true,
    pet_pickplace_random = true,
    pet_pickplace_random_equip = true,
    pet_pickplace_cooldownsecs = 1,
    pet_pickplace_activactiondelay = 0.67,
    pet_pickplace_equipe_delay = 0.13,

    sell_pets = {
        -- Eggs [dont need, no one can get it]
        -- Exotic Bug Egg [is same as bug egg, dont need]
        -- Pet Eggs [dont need]
        -- Corrupted Zen Egg [dnt need]
        -- Premium Primal | Egg Premium Anti Bee Egg || Premium Oasis Egg (dont need these, same as normal versions)

        -- Gem Egg
        ["Gem Egg"] = {
            ["Topaz Snail"] = true,
            ["Amethyst Beetle"] = true,
            ["Emerald Snake"] = true,
            ["Sapphire Macaw"] = true,
            ["Diamond Panther"] = false,
            ["Ruby Squid"] = false
        },
        -- Safari Egg
        ["Safari Egg"] = {
            ["Oxpecker"] = true, ["Zebra"] = true, ["Giraffe"] = true, ["Rhino"] = true, ["Elephant"] = false
        },

        -- Spooky Egg
        ["Spooky Egg"] = {
            ["Bat"] = true, ["Bone Dog"] = true, ["Spider"] = true, ["Black Cat"] = true, ["Headless Horseman"] = false
        },

        -- Jungle Egg
        ["Jungle Egg"] = {
            ["Tree Frog"] = true, ["Hummingbird"] = true, ["Iguana"] = true, ["Chimpanzee"] = true, ["Tiger"] = false
        },
        -- Fall Egg
        ["Fall Egg"] = {
            ["Robin"] = true, ["Badger"] = true, ["Grizzly Bear"] = true, ["Barn Owl"] = true, ["Swan"] = false
        },

        -- Common Summer Egg
        ["Common Summer Egg"] = {
            ["Starfish"] = true, ["Seagull"] = true, ["Crab"] = true
        },

        -- Uncommon Egg
        ["Uncommon Egg"] = {
            ["Black Bunny"] = true, ["Chicken"] = true, ["Cat"] = true, ["Deer"] = true
        },

        -- Mythical Egg
        ["Mythical Egg"] = {
            ["Grey Mouse"] = true, ["Brown Mouse"] = true, ["Squirrel"] = true, ["Red Giant Ant"] = true, ["Red Fox"] = false
        },

        -- Legendary Egg
        ["Legendary Egg"] = {
            ["Cow"] = true, ["Silver Monkey"] = true, ["Sea Otter"] = true, ["Turtle"] = true, ["Polar Bear"] = false
        },

        -- Rainbow Premium Primal Egg
        ["Rainbow Premium Primal Egg"] = {
            ["Rainbow Parasaurolophus"] = true,
            ["Rainbow Iguanodon"] = true,
            ["Rainbow Pachycephalosaurus"] = true,
            ["Rainbow Dilophosaurus"] = true,
            ["Rainbow Ankylosaurus"] = true,
            ["Rainbow Spinosaurus"] = false
        },
        -- Enchanted Egg
        ["Enchanted Egg"] = {
            ["Ladybug"] = true, ["Pixie"] = true, ["Imp"] = true, ["Glimmering Sprite"] = true, ["Cockatrice"] = false
        },

        -- Rare Egg
        ["Rare Egg"] = {
            ["Orange Tabby"] = true, ["Spotted Deer"] = true, ["Pig"] = true, ["Rooster"] = true, ["Monkey"] = true
        },

        -- Common Egg
        ["Common Egg"] = {
            ["Dog"] = true, ["Golden Lab"] = true, ["Bunny"] = true
        },

        -- Sprout Egg
        ["Sprout Egg"] = {
            ["Dairy Cow"] = true, ["Jackalope"] = true, ["Seedling"] = true, ["Golem"] = true, ["Golden Goose"] = false
        },

        -- Bee Egg
        ["Bee Egg"] = {
            ["Bee"] = true, ["Honey Bee"] = true, ["Bear Bee"] = true, ["Petal Bee"] = true, ["Queen Bee"] = false
        },

        -- Anti Bee Egg
        ["Anti Bee Egg"] = {
            ["Wasp"] = true, ["Tarantula Hawk"] = true, ["Moth"] = true, ["Butterfly"] = false, ["Disco Bee"] = false
        },

        -- Oasis Egg
        ["Oasis Egg"] = {
            ["Meerkat"] = true, ["Sand Snake"] = true, ["Axolotl"] = true, ["Hyacinth Macaw"] = true, ["Fennec Fox"] = false
        },

        -- Gourmet Egg
        ["Gourmet Egg"] = {
            ["Bagel Bunny"] = true,
            ["Pancake Mole"] = true,
            ["Sushi Bear"] = true,
            ["Spaghetti Sloth"] = true,
            ["French Fry Ferret"] = false
        },

        -- Paradise Egg
        ["Paradise Egg"] = {
            ["Ostrich"] = true, ["Peacock"] = true, ["Capybara"] = true, ["Scarlet Macaw"] = true, ["Mimic Octopus"] = false
        },

        -- Bug Egg
        ["Bug Egg"] = {
            ["Caterpillar"] = true, ["Snail"] = true, ["Giant Ant"] = true, ["Praying Mantis"] = true, ["Dragonfly"] = false
        },

        -- Zen Egg
        ["Zen Egg"] = {
            ["Shiba Inu"] = true,
            ["Nihonzaru"] = true,
            ["Tanuki"] = true,
            ["Tanchozuru"] = true,
            ["Kappa"] = true,
            ["Kitsune"] = false
        },

        -- Primal Egg
        ["Primal Egg"] = {
            ["Parasaurolophus"] = true,
            ["Iguanodon"] = true,
            ["Pachycephalosaurus"] = true,
            ["Dilophosaurus"] = true,
            ["Ankylosaurus"] = true,
            ["Spinosaurus"] = false
        },

        -- Dinosaur Egg
        ["Dinosaur Egg"] = {
            ["Raptor"] = true,
            ["Triceratops"] = true,
            ["Stegosaurus"] = true,
            ["Pterodactyl"] = true,
            ["Brontosaurus"] = false,
            ["T-Rex"] = false
        },

        -- Rare Summer Egg
        ["Rare Summer Egg"] = {
            ["Flamingo"] = true, ["Toucan"] = true, ["Sea Turtle"] = true, ["Orangutan"] = true, ["Seal"] = true
        },

        -- Night Egg
        ["Night Egg"] = {
            ["Hedgehog"] = true,
            ["Mole"] = true,
            ["Frog"] = true,
            ["Echo Frog"] = true,
            ["Night Owl"] = true,
            ["Raccoon"] = false,
        }
    },

    eggs_to_place_array = {
        ["Gem Egg"] = { enabled = false, order = 1, color = Color3.fromRGB(220, 40, 70) },                    -- red
        ["Safari Egg"] = { enabled = false, order = 1, color = Color3.fromRGB(189, 155, 84) },                -- Safari Gold
        ["Spooky Egg"] = { enabled = false, order = 1, color = Color3.fromRGB(106, 13, 173) },                -- Spooky Purple
        ["Jungle Egg"] = { enabled = false, order = 1, color = Color3.fromRGB(50, 205, 50) },                 -- Lime Green
        ["Fall Egg"] = { enabled = false, order = 1, color = Color3.fromRGB(255, 140, 0) },                   -- pumpkin orange
        ["Common Egg"] = { enabled = true, order = 1, color = Color3.fromRGB(255, 0, 255) },                  -- bright magenta
        ["Anti Bee Egg"] = { enabled = false, order = 2, color = Color3.fromRGB(255, 128, 0) },               -- neon orange
        ["Enchanted Egg"] = { enabled = false, order = 3, color = Color3.fromRGB(0, 255, 255) },              -- bright cyan
        ["Paradise Egg"] = { enabled = false, order = 4, color = Color3.fromRGB(0, 255, 128) },               -- neon green
        ["Premium Primal Egg"] = { enabled = false, order = 6, color = Color3.fromRGB(255, 255, 0) },         -- bright yellow
        ["Rainbow Premium Primal Egg"] = { enabled = false, order = 7, color = Color3.fromRGB(255, 0, 128) }, -- neon pink
        ["Zen Egg"] = { enabled = false, order = 8, color = Color3.fromRGB(128, 0, 255) },                    -- neon purple
        ["Night Egg"] = { enabled = false, order = 9, color = Color3.fromRGB(0, 128, 255) },                  -- bright blue
        ["Rare Egg"] = { enabled = false, order = 10, color = Color3.fromRGB(255, 64, 0) },                   -- neon red-orange
        ["Oasis Egg"] = { enabled = false, order = 11, color = Color3.fromRGB(0, 255, 255) },                 -- bright cyan
        ["Rare Summer Egg"] = { enabled = false, order = 12, color = Color3.fromRGB(255, 0, 0) },             -- neon red
        ["Primal Egg"] = { enabled = false, order = 13, color = Color3.fromRGB(128, 255, 0) },                -- neon lime
        ["Dinosaur Egg"] = { enabled = false, order = 14, color = Color3.fromRGB(0, 255, 128) },              -- bright green
        ["Gourmet Egg"] = { enabled = false, order = 15, color = Color3.fromRGB(255, 0, 255) },               -- neon magenta
        ["Sprout Egg"] = { enabled = false, order = 16, color = Color3.fromRGB(0, 255, 64) },                 -- neon mint
        ["Bee Egg"] = { enabled = false, order = 17, color = Color3.fromRGB(255, 255, 0) },                   -- bright yellow
        ["Bug Egg"] = { enabled = false, order = 18, color = Color3.fromRGB(255, 128, 0) },                   -- neon orange
        ["Premium Night Egg"] = { enabled = false, order = 19, color = Color3.fromRGB(255, 0, 128) },         -- neon pink
        ["Common Summer Egg"] = { enabled = false, order = 20, color = Color3.fromRGB(255, 192, 203) },       -- pink
        ["Exotic Bug Egg"] = { enabled = false, order = 23, color = Color3.fromRGB(255, 165, 0) },            -- orange
        ["Legendary Egg"] = { enabled = false, order = 24, color = Color3.fromRGB(255, 215, 0) },             -- gold
        ["Mythical Egg"] = { enabled = false, order = 25, color = Color3.fromRGB(0, 255, 255) },              -- cyan
        ["Premium Anti Bee Egg"] = { enabled = false, order = 27, color = Color3.fromRGB(255, 140, 0) },      -- dark orange
        ["Premium Oasis Egg"] = { enabled = false, order = 28, color = Color3.fromRGB(0, 191, 255) },         -- deep sky blue
        ["Uncommon Egg"] = { enabled = false, order = 29, color = Color3.fromRGB(173, 255, 47) },             -- green-yellow
    }
}

-- these not needed for now
--  ["Pet Eggs"] = {enabled = false, order = 26, color = Color3.fromRGB(255, 105, 180)}, -- hot pink
-- ["Eggs"] = {enabled = false, order = 0, color = Color3.fromRGB(255, 255, 255)}, -- white *
--  ["Corrupted Zen Egg"] = {enabled = false, order = 21, color = Color3.fromRGB(128, 128, 128)}, -- grey *


-- Logs, contains all errors related logs, when something fails and saves and loads . maximum 100 log
Varz.logs = {}
Varz.user_s_key = ""

-- holds all vars {system}
-- #manager
local FallEventManager = {}
local _FruitCollectorMachine = {}
local _EventShops = {}
local AscensionManager = {}
local FarmManager = {}
local _PlantsManager = {}
local MonsterBoostManager = {}
local InventoryManager = {}
local MutationMachineManager = {}
local MonsterFeeder = {}
local MonsterManager = {}
local CraftManager = {}
local _Helper = {}
local CookingManager = {}
local SaveManager = {}
local ShovelManager = {}
local SeedManager = {}
local MoneyMarkets = {}
local VulnManager = {}
local EventsManager = {}
local WaterManager = {}
local TaskManager = {}
local PetMutation = {}
local EventQuestsManager = {}
local GameDataManager = {}

-- Data Bind
Varz.InventoryDataBind = {}

_Helper.PetDataLocal = {}

PetMutation.is_running = false

-- Event switch off
EventsManager.shutdown_event_jungle_event = true

-- Important
Varz.RequireDataSync_Save = false
Varz.RequireDataSync_SaveOther = false
Varz.DisablePickPlace = false

-- Events

-- #pro
Varz.GetProMessage = function()
    local dx = string.format(
        "ðŸ”’ <stroke th='0.1' joins='round' sizing='fixed' color='#8C1600'><font color='#FA2B00'> Premium Feature - Join discord server to get Key.</font></stroke>");
    return dx
end

EventQuestsManager.PriceListReroll = {
    "1.6M",
    "6.4M",
    "25.6M",
    "102.4M",
    "409.6M",
    "1.6B",
    "6.6B",
    "26.2B",
    "104.9B",
    "419.4B",
    "1.7T",
    "6.7T",
    "26.8T",
    "126.8T",
    "207.3T",
    "998.9T",
    "90.88SX",
}

EventQuestsManager.AvoidQuests = {}

CookingManager.TimeDisplayPots = {}
CookingManager.SpeedOffset = 0.25

Varz.all_pets_data_list = {}
Varz.all_pets_names_list = {}
Varz.craft_data_GearEventWorkbench = {}
Varz.egg_hatch_time_left = 0

Varz.map_event_item_added = false

Varz.IS_CRAFTING = false
Varz.IS_COOKING = false
Varz.IS_HATCHING = false
Varz.IS_FEEDING = false
Varz.IS_SEEDING = false
Varz.QUEST_TASK_RUNNING = false
Varz.IS_SHOVELING = false
Varz.IS_JUNGLE_RUNNING = false
Varz.IS_LEVELUP_RUNNING = false
Varz.IS_WATERING = false
Varz.IS_Sprinkler = false
Varz.IS_MUTATION_RUNNING = false
Varz.IS_PET_MUTATION_RUNNING = false
Varz.IS_DIG = false
Varz.IS_PACKOPEN = false

Varz.BigData = {}

Varz.sell_selected_pets = {}

-- Find this craft table
CraftManager.Current_Recipe_Name = ""
CraftManager.Current_Recipe_MissingItemName = ""

_PlantsManager.trowel_is_running = false


Varz.st_rng_detector_stable = "afk"
Varz.rng_found_stable_tools = false

-- #rng
Varz.GetIsRNGStable = function()
    if not Varz.GetCheckIfPro() then return false end

    if Varz.st_rng_detector_stable == "good" then
        return true
    end

    if Varz.st_rng_detector_stable == "bald" then
        return true
    end

    return Varz.rng_found_stable_tools
    --return _S.LocalPlayer:GetAttribute("BLOCK_TIME_UPDATES") == true
end


MonsterBoostManager.Boost_Types = {
    ["PASSIVE_BOOST"] = true,
    ["PET_XP_BOOST"] = true,
    ["ABILITY_REFRESH"] = true,
}

MonsterBoostManager.boosts_list = {
    ["Small Pet Toy [Passive Boost]"] = true,
    ["Medium Pet Toy [Passive Boost]"] = true,
    ["Large Pet Toy [Passive Boost]"] = true,
    ["Small Pet Treat [XP Boost]"] = true,
    ["Medium Pet Treat [XP Boost]"] = true,
}

MonsterBoostManager.ItemAmounts = {
    -- PASSIVE BOOSTS (Toys)
    ["Small Pet Toy [Passive Boost]"]  = 0.1,
    ["Medium Pet Toy [Passive Boost]"] = 0.2,
    ["Large Pet Toy [Passive Boost]"]  = 0.3,

    -- XP BOOSTS (Treats)
    ["Small Pet Treat [XP Boost]"]     = 0.5,
    ["Medium Pet Treat [XP Boost]"]    = 2,
}

-- Helper: Convert "Item Name" to "Boost Type" based on your list
MonsterBoostManager.GetTypeFromItemName = function(item_name)
    if string.find(item_name, "Passive Boost") then
        return "PASSIVE_BOOST"
    elseif string.find(item_name, "XP Boost") then
        return "PET_XP_BOOST"
    end
    return nil
end


_Helper.IsPrivateServer = function()
    -- Check 1: Standard VIP or Reserved Servers always have a PrivateServerId
    if game.PrivateServerId ~= "" and game.PrivateServerId ~= nil then
        return true
    end

    -- Check 2: Fallback for older VIP servers (OwnerID is not 0)
    if game.PrivateServerOwnerId ~= 0 and game.PrivateServerOwnerId ~= nil then
        return true
    end

    return false
end



Varz.recent_bloom_fall_notfi = false
Varz.max_pet_inventory_space = false



--- Seed Stages Seeds
Varz.JungleSeedStage1 = {
    ["Evo Beetroot I"] = false,
    ["Evo Blueberry I"] = false,
    ["Evo Pumpkin I"] = false,
    ["Evo Mushroom I"] = false,
}




----------------- Fall Event Shop Data
-- Fall Event Shop Data
Varz.FallEvent_Pet_Shop_ItemList = {
    ["Fall Egg"] = false,
    ["Chipmunk"] = false,
    ["Marmot"] = false,
    ["Red Squirrel"] = false,
    ["Space Squirrel"] = false,
    ["Sugar Glider"] = false,
    ["Mallard"] = false,
    ["Red Panda"] = false,
    ["Salmon"] = false,
    ["Woodpecker"] = false,
}



Varz.FallEvent_Seeds_Shop_ItemList = {
    ["Carnival Pumpkin"] = false,
    ["Golden Peach"] = false,
    ["Kniphofia"] = false,
    ["Maple Resin"] = false,
    ["Meyer Lemon"] = false,
    ["Parsley"] = false,
    ["Turnip"] = false,
    ["Fall Seed Pack"] = false,
}



Varz.FallEvent_Cosmetic_Shop_ItemList = {
    ["Fall Crate"] = false,
    ["Fall Fountain"] = false,
    ["Fall Leaf Chair"] = false,
    ["Flying Kite"] = false,
    ["Maple Flag"] = false,
    ["Fall Hay Bale"] = false,
    ["Fall Wreath"] = false,
    ["Maple Crate"] = false,
    ["Pile Of Leaves"] = false,
}


Varz.FallEvent_Gear_Shop_ItemList = {
    ["Bonfire"] = false,
    ["Firefly Jar"] = false,
    ["Golden Acorn"] = false,
    ["Harvest Basket"] = false,
    ["Leaf Blower"] = false,
    ["Maple Leaf Charm"] = false,
    ["Maple Leaf Kite"] = false,
    ["Maple Sprinkler"] = false,
    ["Maple Syrup"] = false,
    ["Sky Lantern"] = false,
    ["Acorn Bell"] = false,
    ["Acorn Lollipop"] = false,
    ["Rake"] = false,
    ["Super Leaf Blower"] = false,
}

-- Json output
_Helper.JsonPrint = function(_object)
    if _S.HttpService then
        warn(_S.HttpService:JSONEncode(_object))
    end
end

_Helper.log = function(_txt)
    if _txt then
        print(_txt)
    else
        warn("(log) error passed val nil")
    end
end


Varz.All_Variants = {}

Varz.LoadVariants = function()
    for key, value in pairs(_S.VariantsEnums) do
        Varz.All_Variants[key] = true
    end
end
Varz.LoadVariants()

_Helper.canReroll = function(currentText, userCapText)
    local success, result = pcall(function()
        local suffixes = {
            K  = 1e3,
            M  = 1e6,
            B  = 1e9,
            T  = 1e12,
            Q  = 1e15,
            QA = 1e18,
            SX = 1e21,
            SP = 1e24,
            O  = 1e27,
            N  = 1e30,
        }

        local function parseCost(text)
            local num, suffix = text:match("([%d%.]+)(%a*)")
            num = tonumber(num)
            if not num then return 0 end
            if suffix ~= "" and suffixes[suffix] then
                return num * suffixes[suffix]
            end
            return num
        end

        local current = parseCost(currentText)
        local cap = parseCost(userCapText)
        return current <= cap
    end)

    if success then
        return result
    else
        return false
    end
end


_Helper.GetProgressLeft = function(progressString)
    if not progressString or type(progressString) ~= "string" then
        return 0, 0, 0
    end

    local current, total = string.match(progressString, "(%d+)/(%d+)")

    if not current or not total then
        return 0, 0, 0
    end

    current = tonumber(current)
    total = tonumber(total)

    if total == 0 then
        return current, total, 0
    end

    local percentage = (current / total) * 100
    return current, total, percentage
end



_Helper.Vector3ToCFrame = function(v3)
    if not v3 then return nil end
    return CFrame.new(v3)
end

_Helper.StringToVector3 = function(str)
    if not str then return nil end

    local x, y, z = str:match("([^,]+),([^,]+),([^,]+)")
    if not x or not y or not z then return nil end

    return Vector3.new(tonumber(x), tonumber(y), tonumber(z))
end

-- coverts text to color
_Helper.StringToColor3 = function(str)
    -- Default color if anything goes wrong
    local default_color = "#FFFF00"

    -- Ensure input is a string
    if type(str) ~= "string" then
        return default_color
    end

    local success, result = pcall(function()
        -- Simple hash function (adapted djb2)
        local hash = 0
        for i = 1, #str do
            local c = string.byte(str, i)
            hash = (hash * 31 + c) % 16777216 -- keep hash within 24-bit
        end

        -- Extract RGB components
        local r = math.floor(hash / 65536) % 256
        local g = math.floor(hash / 256) % 256
        local b = hash % 256

        -- Convert to hex and return
        return string.format("#%02x%02x%02x", r, g, b)
    end)

    -- Return result if successful, otherwise default
    return success and result or default_color
end




-- ==== Load pet list
_Helper.AllPetPassiveData = {}
_Helper.GetAllPetDataPassives = function()
    for key, value in pairs(_S.PetList) do
        local pv = value.Passives or {}
        _Helper.AllPetPassiveData[key] = pv
    end
end
_Helper.GetAllPetDataPassives()

_Helper.AllEggNamesList = {}
_Helper.GetAllEggNames = function()
    for eggName, value in pairs(_S.PetRegistry.PetEggs) do
        table.insert(_Helper.AllEggNamesList, eggName)
    end
    return _Helper.AllEggNamesList
end
_Helper.GetAllEggNames()


Varz.AscensionFruitName = nil
Varz.AscensionFruitMutations = {}
Varz.PlantsCategoryData = {}




Varz.garden_coins = 0
Varz.honey_coins = 0
Varz.sleep_ascend = 3
Varz.is_garden_full_seed = false

-- pet data for esp
Varz.found_pet_data = {}
Varz.found_crate_data = {}
-- stores big pets that we can't hatch
Varz.big_pets_hatch_models = {}
Varz.hatch_history_list = {}


Varz.pets_sold_count = 0
Varz.pets_fav_count = 0
Varz.found_pets_to_sell_count = 0
Varz.has_koi_repaint = false
Varz.has_seal_sold_happen = false

Varz.is_forced_stop = false

Varz.is_max_eggs_reached = false;

local main_thread
local mutation_thread
local petmut_thread
local custom_team_system_thread = nil

Varz.tracked_bonus_egg_recovery = 0
Varz.tracked_bonus_egg_sell_refund = 0
Varz.shops_can_function = false; -- shops can't start unless told to

Varz.backpack_full = false

Varz.player_userid = _S.LocalPlayer.UserId

local MutationTableWebhook = {}
Varz.HatchingWebhookData = {}

if not Varz.player_userid then
    warn("Invalid player detected.")
    return
end


_Helper.formatDuration = function(totalSeconds)
    if not totalSeconds then
        return 0
    end
    -- Define time constants
    local SECONDS_IN_A_DAY = 86400
    local SECONDS_IN_AN_HOUR = 3600
    local SECONDS_IN_A_MINUTE = 60

    -- Ensure the input is a number
    totalSeconds = tonumber(totalSeconds) or 0

    -- Calculate all time units first
    local days = math.floor(totalSeconds / SECONDS_IN_A_DAY)
    local remainder = totalSeconds % SECONDS_IN_A_DAY
    local hours = math.floor(remainder / SECONDS_IN_AN_HOUR)
    remainder = remainder % SECONDS_IN_AN_HOUR
    local minutes = math.floor(remainder / SECONDS_IN_A_MINUTE)
    local seconds = math.floor(remainder % SECONDS_IN_A_MINUTE)

    -- Conditionally build the string, hiding leading zero values
    if days > 0 then
        -- If we have days, show everything
        return string.format("%dd:%dh:%dm:%ds", days, hours, minutes, seconds)
    elseif hours > 0 then
        -- If no days but we have hours, show from hours down
        return string.format("%dh:%dm:%ds", hours, minutes, seconds)
    elseif minutes > 0 then
        -- If no days or hours but we have minutes, show from minutes down
        return string.format("%dm:%ds", minutes, seconds)
    else
        -- Otherwise, just show seconds
        return string.format("%ds", seconds)
    end
end

-- TABLE THAT WILL BE DISPLAYED ON SCREEN #stats
Varz.PlayerSecrets = {
    EggRecoveryChance = 0,
    PetSellEggRefundChance = 0,
    PetEggHatchAgeBonus = 0,
    PetEggHatchSizeBonus = 0,
    PetPassiveBonus = 0,
    SessionTime = 0,
    SellSilverFruitRewardChance = 0,
    Grow_Amount = 0
}


-- Holds our current eggs
Varz.egg_counts = {
    ["Gem Egg"] = { current_amount = 0, new_amount = 0 },           -- #
    ["Safari Egg"] = { current_amount = 0, new_amount = 0 },        -- #
    ["Spooky Egg"] = { current_amount = 0, new_amount = 0 },        -- #
    ["Jungle Egg"] = { current_amount = 0, new_amount = 0 },        -- #
    ["Fall Egg"] = { current_amount = 0, new_amount = 0 },          -- #
    ["Enchanted Egg"] = { current_amount = 0, new_amount = 0 },     -- #
    ["Anti Bee Egg"] = { current_amount = 0, new_amount = 0 },      -- #
    ["Bee Egg"] = { current_amount = 0, new_amount = 0 },           --#
    ["Bug Egg"] = { current_amount = 0, new_amount = 0 },           --#
    ["Common Egg"] = { current_amount = 0, new_amount = 0 },        --#
    ["Common Summer Egg"] = { current_amount = 0, new_amount = 0 }, --#
    ["Corrupted Zen Egg"] = { current_amount = 0, new_amount = 0 },
    ["Dinosaur Egg"] = { current_amount = 0, new_amount = 0 },      --#
    ["Eggs"] = { current_amount = 0, new_amount = 0 },
    ["Exotic Bug Egg"] = { current_amount = 0, new_amount = 0 },
    ["Gourmet Egg"] = { current_amount = 0, new_amount = 0 }, --#
    ["Legendary Egg"] = { current_amount = 0, new_amount = 0 },
    ["Mythical Egg"] = { current_amount = 0, new_amount = 0 },
    ["Night Egg"] = { current_amount = 0, new_amount = 0 }, --#
    ["Oasis Egg"] = { current_amount = 0, new_amount = 0 },
    ["Paradise Egg"] = { current_amount = 0, new_amount = 0 },
    ["Pet Eggs"] = { current_amount = 0, new_amount = 0 },
    ["Premium Anti Bee Egg"] = { current_amount = 0, new_amount = 0 },
    ["Premium Night Egg"] = { current_amount = 0, new_amount = 0 },
    ["Premium Oasis Egg"] = { current_amount = 0, new_amount = 0 },
    ["Premium Primal Egg"] = { current_amount = 0, new_amount = 0 },
    ["Primal Egg"] = { current_amount = 0, new_amount = 0 },
    ["Rainbow Premium Primal Egg"] = { current_amount = 0, new_amount = 0 },
    ["Rare Egg"] = { current_amount = 0, new_amount = 0 },
    ["Rare Summer Egg"] = { current_amount = 0, new_amount = 0 },
    ["Sprout Egg"] = { current_amount = 0, new_amount = 0 },
    ["Uncommon Egg"] = { current_amount = 0, new_amount = 0 },
    ["Zen Egg"] = { current_amount = 0, new_amount = 0 },
}



local all_plants_list = {}
Varz.all_seed_pack_names = {}

FarmManager.cache_objects = {}

FarmManager.FindObjectInWorkSpace = function(name, objectType, dontCache)
    local target = string.lower(name)

    if FarmManager.cache_objects[target] then
        return FarmManager.cache_objects[target]
    end

    for _, d in ipairs(_S.Workspace:GetDescendants()) do
        if string.lower(d.Name) == target and d:IsA(objectType) then
            if dontCache then
                FarmManager.cache_objects[target] = d
            end
            return d
        end
    end

    return nil
end

-- #pack
GameDataManager.GetAllSeedPackNames = function()
    local packDisplayNames = {}

    -- Iterate over the main table
    for packKey, packData in pairs(_S.SeedPackData.Packs) do
        -- Check if a DisplayName exists for this pack
        if packData.DisplayName then
            table.insert(packDisplayNames, packData.DisplayName)
        end
    end

    return packDisplayNames
end

Varz.all_seed_pack_names = GameDataManager.GetAllSeedPackNames()


_Helper.CloneArray = function(arr)
    local copy = {}
    for i, v in ipairs(arr) do
        copy[i] = v
    end
    return copy
end

Varz.SeedRarity = {}
-- Get all plants / seeds
local function FetchAllSeedNames()
    local xall_seed_names = {}
    for _, seed in pairs(_S.SeedData) do
        if seed.SeedName then
            local name = seed.SeedName
            local SeedRarity = seed.SeedRarity
            -- Removes " Seed" from the end of the name for a cleaner list
            name = name:gsub("%s+Seed$", "")
            Varz.SeedRarity[name] = SeedRarity
            table.insert(xall_seed_names, name)
        end
    end

    for _, value in ipairs(xall_seed_names) do
        all_plants_list[value] = false
    end
end
FetchAllSeedNames()

local function GetKeyValuesFromList(list)
    local tblx = {}
    for key, value in pairs(list) do
        table.insert(tblx, key)
    end
    table.sort(tblx, function(a, b)
        return a:lower() < b:lower()
    end)
    return tblx
end

-- #shops
Varz.TeleportLocations = {
    GetLocationSellShopV3 = function()
        local new_pos = Vector3.new(0, 0, 0)
        local shop_name = "Sell Stands"
        local _type = "Model"
        local sellmodel = FarmManager.FindObjectInWorkSpace(shop_name, _type)
        if not sellmodel then return new_pos end
        local ShopStand = sellmodel:FindFirstChild("Shop Stand") -- type is part
        if not ShopStand then return new_pos end


        local frontPos = (ShopStand.CFrame * CFrame.new(0, 0, 3)).Position
        return frontPos
    end
}

-- Teleport function
local function TeleportPlayerToCFrame(targetCFrame)
    local player = _S.LocalPlayer

    -- Function to set the HumanoidRootPart CFrame
    local function setCFrame(character)
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = targetCFrame
        end
    end

    -- If character exists, teleport immediately
    if player.Character then
        setCFrame(player.Character)
    end

    -- Handle future respawns
    player.CharacterAdded:Connect(function(character)
        -- Wait until HumanoidRootPart exists
        character:WaitForChild("HumanoidRootPart")
        setCFrame(character)
    end)
end

-- pause all systems
Varz.IsPaused = function()
    return FSettings.pause_systems
end


local function GetRealPetWeight(BaseWeight, level)
    if not _S.PetUtilities then return BaseWeight end
    local weight = _S.PetUtilities:CalculateWeight(BaseWeight or 1, level or 1)
    return weight;
end

_Helper.getEggAmounts = function(name)
    local egg = Varz.egg_counts[name]
    if egg then
        return egg.current_amount, egg.new_amount
    end
    return 0, 0 -- or 0, 0 if you prefer default values
end

-- Function to update Varz.PlayerSecrets with safe checks
_Helper.UpdatePlayerStats = function()
    if not _S.LocalPlayer then
        warn("UpdatePlayerStats called without a valid LocalPlayer")
        return
    end

    for key, _ in pairs(Varz.PlayerSecrets) do
        local value = _S.LocalPlayer:GetAttribute(key) -- safely try to get attribute
        if value ~= nil then
            Varz.PlayerSecrets[key] = value
        else
            Varz.PlayerSecrets[key] = 0 -- fallback default
        end
    end
end

-- Get all pets list from sell list
_Helper.GetAllPets = function()
    local allPets = {}

    for _, pets in pairs(FSettings.sell_pets) do
        for petName, available in pairs(pets) do
            if available then
                allPets[petName] = false
            end
        end
    end

    return allPets
end



-- Teleport buttons ingame
_Helper.ShopTeleportButtons = function()
    local teleportFrame = _S.LocalPlayer.PlayerGui.Teleport_UI.Frame
    if not teleportFrame then
        return
    end
    -- enable all buttons
    for _, button in ipairs(teleportFrame:GetChildren()) do
        if button:IsA("GuiButton") then
            button.Visible = true
        end
    end
end

_Helper.ShopTeleportButtons()

if _G.EggDataStreamListener then
    _G.EggDataStreamListener:Disconnect()
end

if _G.EggEspUiRunning then
    _G.EggEspUiRunning = false
    task.wait() -- give the old loop a frame to exit
end

_G.EggEspUiRunning = true

-- Stop previous loop if it exists
if _G.GearShopLoopRunning then
    _G.GearShopLoopRunning = false
    _G.SeedShopLoopRunning = false
    _G.EggShopLoopRunning = false
    _G.MerchantShopLoopRunning = false
    task.wait(0.1)
end

_G.GearShopLoopRunning = true
_G.SeedShopLoopRunning = true
_G.EggShopLoopRunning = true
_G.MerchantShopLoopRunning = true

--============== SHOPS




EventsManager.AllTravelingMerchantData = {}


_EventShops.GetCandyCornCount = function()
    local success, value = pcall(function()
        return _S.PlayerGui.CandyCornCurrency_UI.Frame.TextLabel1.val.Value
    end)

    return tonumber(success and value) or 0
end

local function FetchGardenCoins()
    local success, value = pcall(function()
        return _S.PlayerGui.GardenCoinCurrency_UI.Frame.TextLabel1.val.Value
    end)

    Varz.garden_coins = tonumber(success and value) or 0
end



local function FetchHoneyCoins()
    local success, value = pcall(function()
        return _S.PlayerGui.Honey_UI.Frame.TextLabel1.val.Value
    end)

    Varz.honey_coins = tonumber(success and value) or 0
end


EventsManager.TravelingMerchantBuy = function()
    local succ, res = pcall(function()
        return _S.PlayerGui.TravelingMerchantShop_UI.Frame.Frame.ShopTitle.ContentText
    end)

    if not succ or type(res) ~= "string" then
        return
    end

    for ShopName, ShopData in pairs(EventsManager.AllTravelingMerchantData) do
        local Title = ShopData.Title
        if string.find(string.lower(res), string.lower(Title)) then
            --warn("Buy items for ..." ..Title)
            local Chance = ShopData.Chance
            local saved_data = FSettings.merchant_shop_data[ShopName] or {}

            for item_name, saved_data in pairs(saved_data) do
                _S.BuyTravelingMerchantShopStock:FireServer(item_name)
                --warn("Buy item: " .. item_name)
            end
        end
    end
end


local function ShopPurchaseLoop(shopUI, buySettingKey, itemsSettingKey, fireEvent, loopRunningKey)
    local is_firsttime = true
    local stockTable = {}
    local m_item_list = {}
    local ScrollingFrame = shopUI.Frame.ScrollingFrame

    local _success, shop_name = pcall(function()
        return shopUI.Frame.Frame.ShopTitle.ContentText
    end)
    local coins = tonumber(Varz.honey_coins) or 0
    local shop_n = ""
    if _success and shop_name == "Honey Shop" and coins < 10 then
        shop_n = shop_name
        FetchHoneyCoins()
    else
        --warn("Failed: ", tostring(shop_name))
    end

    local function UpdateStock()
        for _, itemFrame in ipairs(ScrollingFrame:GetChildren()) do
            local itemName = itemFrame.Name
            local itemStock = itemFrame:FindFirstChild("Frame") and itemFrame.Frame:FindFirstChild("Value")

            if not itemStock or not itemStock:IsA("NumberValue") then
                continue
            end

            local stock = tonumber(itemStock.Value) or 0
            stockTable[itemName] = { stock = stock }

            if is_firsttime then
                m_item_list[itemName] = true
                FSettings[itemsSettingKey] = m_item_list
            end
        end
        -- must run after the loop
        if is_firsttime then
            FSettings[itemsSettingKey] = m_item_list
        end

        is_firsttime = false
    end

    while _G[loopRunningKey] do
        task.wait(1)
        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        if FSettings[buySettingKey] == false then
            task.wait(1)
            continue
        end




        --print("Running " .. buySettingKey .. " buy")


        if Varz.shops_can_function == false then
            continue
        end

        local success, fail = pcall(function()
            UpdateStock() -- can update to fill in the settings
        end)
        if not success then
            warn("Error ", fail)
        end


        for itemName, val in pairs(stockTable) do
            local stock = val.stock
            if stock <= 0 or FSettings[itemsSettingKey][itemName] == false then
                continue
            end

            if shop_n == "Honey Shop" then
                if Varz.honey_coins < 9 then
                    --warn("not not coins")
                    continue
                end
            end



            for i = 1, stock do
                if buySettingKey == "buy_seedshop" then
                    --warn("Stock: " .. stock)
                    fireEvent:FireServer("Shop", itemName)
                else
                    fireEvent:FireServer(itemName)
                end
            end
        end

        task.wait(10)
    end
end

-- Seed Shop
task.spawn(function()
    ShopPurchaseLoop(_S.SeedShopUI, "buy_seedshop", "seedshop_items", _S.BuySeedStock, "SeedShopLoopRunning")
end)

-- GearShop
task.spawn(function()
    ShopPurchaseLoop(_S.GearShopUI, "buy_gearshop", "gearshop_items", _S.BuyGearStock, "GearShopLoopRunning")
end)

-- EggShop
task.spawn(function()
    ShopPurchaseLoop(_S.PetShopUI, "buy_eggshop", "eggshop_items", _S.BuyPetEgg, "EggShopLoopRunning")
end)



if not EventsManager.task_buy_merc then
    EventsManager.task_buy_merc = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(2)
            pcall(function()
                EventsManager.TravelingMerchantBuy()
            end)

            task.wait(20)
        end
    end)
end

--======= END Shops

local list_mutations = {}

local function GetKeyMutListUsingDir(ls)
    local _data = {}
    for key, value in pairs(ls) do
        table.insert(_data, key)
    end

    return _data
end


Varz.GetAllPlantsWithCategory = function()
    Varz.PlantsCategoryData = _S.PlantTraitsData.Traits
end

Varz.GetAllPlantsWithCategory()

--=== Build mutations list safely #mutlist
Varz.GetAllMutations = function()
    local MutationHandler = require(game.ReplicatedStorage.Modules.MutationHandler)

    -- Get all mutations from the handler
    local allMutations = MutationHandler.GetMutations()

    -- Initialise whitelist and blacklist separately
    --FOtherSettings.mutation_whitelist = {}
    --FOtherSettings.mutation_blacklist = {}

    for mutationName, _ in pairs(allMutations) do
        --FOtherSettings.mutation_whitelist[mutationName] = false
        --FOtherSettings.mutation_blacklist[mutationName] = false
        list_mutations[mutationName] = false
    end

    -- list_mutations["Sliver"] = false
    -- list_mutations["Gold"] = false
    -- list_mutations["Rainbow"] = false
end

-- Apply them
Varz.GetAllMutations()

-- Saving and loading
SaveManager.save_fname = "a_acssave_v15.json"
SaveManager.save_fname_other = "a_acssave_v15_other.json"
SaveManager.save_s_data = "p_sessioondf.json"

if not isfile(SaveManager.save_fname) then
    -- make per user saving files
    local folder_name = "exotichub99"
    if not isfolder(folder_name) then
        makefolder(folder_name)
    end
    SaveManager.save_fname = folder_name .. "/" .. Varz.player_userid .. "file1.json"
    SaveManager.save_fname_other = folder_name .. "/" .. Varz.player_userid .. "file2.json"
    SaveManager.save_s_data = folder_name .. "/" .. Varz.player_userid .. "filesession.json"
end

SaveManager.SaveSessionSettings = {
    SaveFile = function()
        local success, err = pcall(function()
            local json = _S.HttpService:JSONEncode(FSessionDx)
            writefile(SaveManager.save_s_data, json)
        end)

        if not success then
            warn("âŒ Failed to save settings: " .. tostring(err))
            return false
        end
        return true
    end,

    LoadFile = function()
        --print("loading saved data")
        if not isfile(SaveManager.save_s_data) then
            return
        end

        local json = readfile(SaveManager.save_s_data)
        if not json or json == "" then
        end

        local success, decoded = pcall(_S.HttpService.JSONDecode, _S.HttpService, json)
        if not success then
            return
        end
        local function merge(target, source)
            for key, sourceValue in pairs(source) do
                local targetValue = target[key]
                if type(sourceValue) == "table" and type(targetValue) == "table" then
                    merge(targetValue, sourceValue)
                else
                    target[key] = sourceValue
                end
            end
            return target
        end
        merge(FSessionDx, decoded)
    end

}

SaveManager.SaveSessionSettings.LoadFile()



SaveManager.SyncSaveData = function()
    local success, json = pcall(function()
        return _S.HttpService:JSONEncode(FSettings)
    end)

    if success then
        writefile(SaveManager.save_fname, json)
    else
        --warn("âŒ Error: Failed to encode settings to JSON. Data not saved.")
    end
end
-- Saving and loading
local function SaveData(safeSave)
    -- if user passes something then direct save
    if safeSave then
        SaveManager.SyncSaveData()
        --warn("Direct SaveData")
        return
    end

    Varz.RequireDataSync_Save = true
end


SaveManager.SyncSaveDataOther = function()
    local success, json = pcall(function()
        return _S.HttpService:JSONEncode(FOtherSettings)
    end)

    if success then
        writefile(SaveManager.save_fname_other, json)
        -- warn(json)
    else
        --warn("âŒ Error: Failed to encode other settings to JSON. Data not saved.")
    end
end

local function SaveDataOther(safeSave)
    -- if user passes something then direct save
    if safeSave then
        SaveManager.SyncSaveDataOther()
        --warn("Direct SaveDataOther")
        return
    end
    -- slower save
    Varz.RequireDataSync_SaveOther = true
end


local function LoadDataOther()
    --print("loading saved data")
    if not isfile(SaveManager.save_fname_other) then
        --print("âš ï¸ No save file found, using defaults")
        return
    end

    local json = readfile(SaveManager.save_fname_other)
    if not json or json == "" then
        --print("âš ï¸ Save file is empty, using defaults")
        return
    end

    local success, decoded = pcall(_S.HttpService.JSONDecode, _S.HttpService, json)
    if not success then
        --print("âŒ Error decoding JSON from save file. It might be corrupted. Using defaults.")
        return
    end

    -- The deep merge logic is now inside this function
    local function merge(target, source)
        for key, sourceValue in pairs(source) do
            local targetValue = target[key]
            if type(sourceValue) == "table" and type(targetValue) == "table" then
                merge(targetValue, sourceValue) -- Recurse for nested tables
            else
                target[key] = sourceValue       -- Overwrite non-table values
            end
        end
        return target
    end

    -- Merge the loaded data into the default settings
    merge(FOtherSettings, decoded)
end

local function LoadData()
    --print("loading saved data")
    if not isfile(SaveManager.save_fname) then
        --print("âš ï¸ No save file found, using defaults")
        return
    end

    local json = readfile(SaveManager.save_fname)
    if not json or json == "" then
        --print("âš ï¸ Save file is empty, using defaults")
        return
    end

    local success, decoded = pcall(_S.HttpService.JSONDecode, _S.HttpService, json)
    if not success then
        --print("âŒ Error decoding JSON from save file. It might be corrupted. Using defaults.")
        return
    end

    -- The deep merge logic is now inside this function
    local function merge(target, source)
        for key, sourceValue in pairs(source) do
            local targetValue = target[key]
            if type(sourceValue) == "table" and type(targetValue) == "table" then
                merge(targetValue, sourceValue) -- Recurse for nested tables
            else
                target[key] = sourceValue       -- Overwrite non-table values
            end
        end
        return target
    end

    -- Merge the loaded data into the default settings
    merge(FSettings, decoded)
    --print("ðŸ“‚ Data loaded from " .. SaveManager.save_fname)
end

-- Call LoadData() once at the start of your script
LoadData()
LoadDataOther();
task.wait(0.1);
-- Now your script can continue, and FSettings will be correctly populated.
print("Loading complete.")
Varz.shops_can_function = true -- shops can now function

-- If we are here for the first time
if FSettings.is_first_time then
    FSettings.is_first_time = false
    SaveData(true)
    SaveDataOther(true)
    task.wait(0.1)
    LoadData();
    LoadDataOther();
end


--  these are pets. its only used to detect if we found and rare pet.

Varz.rare_pets = {
    ["Diamond Panther"] = true,
    ["Ruby Squid"] = true,
    ["Elephant"] = true,
    ["Headless Horseman"] = true,
    ["Tiger"] = true,
    ["Swan"] = true,
    ["T-Rex"] = true,
    ["Brontosaurus"] = true,
    ["Spinosaurus"] = true,
    ["Kitsune"] = true,
    ["Mimic Octopus"] = true,
    ["Red Fox"] = true,
    ["French Fry Ferret"] = true,
    ["Fennec Fox"] = true,
    ["Dragonfly"] = true,
    ["Raccoon"] = true,
    ["Queen Bee"] = true,
    ["Golden Goose"] = true,
    ["Butterfly"] = true,
    ["Disco Bee"] = true,
    ["Cockatrice"] = true,
    ["Ankylosaurus"] = true,
}



-- Slow data save
if _Helper.task_data_sync then
    task.cancel(_Helper.task_data_sync)
    _Helper.task_data_sync = nil
end
_Helper.task_data_sync = task.spawn(function()
    while true do
        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end
        task.wait(1)
        if Varz.RequireDataSync_Save then
            --warn("[SAFE] data saved  (SaveData)")
            Varz.RequireDataSync_Save = false
            SaveManager.SyncSaveData()
        end

        if Varz.RequireDataSync_SaveOther then
            --warn("[SAFE] data saved  (SyncSaveDataOther)")
            Varz.RequireDataSync_SaveOther = false
            SaveManager.SyncSaveDataOther()
        end
    end
end)



_EventShops.HalloweenShopData = {}
_EventShops.Halloween = {
    GetShopItems = function()
        local dx = {}

        for ShopName, items in pairs(_S.EventShopData) do
            dx[ShopName] = {}

            for ItemName, _ in pairs(items) do
                table.insert(dx[ShopName], ItemName)
            end

            -- optional: sort items alphabetically
            table.sort(dx[ShopName])
        end
        return dx
    end,

    BuyItems = function()
        local BuyEventShopStock = _S.GameEvents.BuyEventShopStock -- RemoteEvent
        --local cur = _EventShops.GetCandyCornCount()
        for sName, items in pairs(FSettings.halloween.shops) do
            for _item, _ in pairs(items) do
                -- if cur < 9 then
                --     break
                -- end
                for i = 1, 3, 1 do
                    BuyEventShopStock:FireServer(_item, sName)
                    task.wait(0.1)
                end
            end
        end
    end
}

_EventShops.HalloweenShopData = _EventShops.Halloween.GetShopItems()

--============ PetData
-------------------------------------------------
MonsterManager.GetAllPetData = function()
    for petName, petInfo in pairs(_S.PetList) do
        table.insert(Varz.all_pets_names_list, petName)
        Varz.all_pets_data_list[petName] = {
            hunger = tonumber(petInfo.DefaultHunger),
            rarity = petInfo.Rarity
        }
    end
end
-- fill up data
MonsterManager.GetAllPetData()

MonsterManager.GetPetDataUsingName = function(_name)
    if not _name then return nil end
    return Varz.all_pets_data_list[_name]
end


---------------=========== Craft #craft

Varz.BringBackStuff = function()
    local success, fail
    pcall(function()
        local m = _S.ReplicatedStorage.Modules.UpdateService.SmithingEvent
        if m then
            m.Parent = _S.Workspace
        end
    end)

    if not success then
        warn("bb ", fail)
    end
end

Varz.BringBackStuff()

CraftManager.AllReceipeData = {}
CraftManager.BenchModels = {}



CraftManager.FindAllBenchModels = function()
    for _, d in ipairs(_S.Workspace:GetDescendants()) do
        local CraftingObjectType = d:GetAttribute("CraftingObjectType")
        if CraftingObjectType and CraftManager.AllReceipeData[CraftingObjectType] then
            if d:IsA("Model") then
                CraftManager.BenchModels[CraftingObjectType] = d
            end
        end
    end
end

CraftManager.GetWorkBenchModelUsingName = function(_name)
    if not CraftManager.BenchModels[_name] then
        CraftManager.FindAllBenchModels()
        return CraftManager.BenchModels[_name]
    end
    return CraftManager.BenchModels[_name]
end


CraftManager.GetRecipeUsingBenchName = function(_name)
    if CraftManager.AllReceipeData[_name] then
        return {}
    end
    local dx = CraftManager.AllReceipeData[_name]

    local ls = {}
    for key, _data in pairs(dx) do
        local inputs = _data.inputs
        local bname = _data.name
        ls[bname] = true
    end

    return ls
end

CraftManager.LoadCraftData = function()
    local success, fail = pcall(function()
        local sortedRecipes = _S.CraftingData_CraftingRecipeRegistry.RecipiesSortedByMachineType

        for WorkbenchName, gearWorkbenchRecipes in pairs(sortedRecipes) do
            local listx = {}
            for _name, _info in pairs(gearWorkbenchRecipes) do
                local recipe_data = {}
                for _, inputItem in ipairs(_info.Inputs) do
                    local ingredient = {
                        Name = inputItem.ItemData.ItemName,
                        Type = inputItem.ItemType
                    }
                    table.insert(recipe_data, ingredient)
                end

                local dx = {
                    inputs = recipe_data
                }
                -- receipe name and its list of requirements
                listx[_name] = dx
            end
            -- remove the event keyword, the workspace has a different name
            --local new_name = WorkbenchName:gsub("Event", "")
            CraftManager.AllReceipeData[WorkbenchName] = listx
        end
    end)

    if not success then
        warn("Error GearEventWorkbench: ", fail)
    end
end

CraftManager.LoadCraftData()
task.wait(0.2)
CraftManager.FindAllBenchModels() -- call this after craft data loaded

-- craft data
CraftManager.LoadCraftData_GearEventWorkbench = function()
    local success, fail = pcall(function()
        local sortedRecipes = _S.CraftingData_CraftingRecipeRegistry.RecipiesSortedByMachineType

        local gearWorkbenchRecipes = sortedRecipes["GearEventWorkbench"]

        for _name, _info in pairs(gearWorkbenchRecipes) do
            local recipe_data = {}
            for _, inputItem in ipairs(_info.Inputs) do
                local ingredient = {
                    Name = inputItem.ItemData.ItemName,
                    Type = inputItem.ItemType
                }
                table.insert(recipe_data, ingredient)
            end

            Varz.craft_data_GearEventWorkbench[_name] = {
                Inputs = recipe_data
            }
        end
    end)

    if not success then
        warn("Error GearEventWorkbench: ", fail)
    end
end

CraftManager.LoadCraftData_GearEventWorkbench()




CraftManager.GetCraftItemsGearEventWorkbench = function()
    local ls = {}

    if not Varz.craft_data_GearEventWorkbench then return ls end

    for _name, _info in pairs(Varz.craft_data_GearEventWorkbench) do
        ls[_name] = true
    end
    return ls
end

-- Build reverse lookup (pet â†’ egg) after loading
local pet_to_egg = {}
for egg, pets in pairs(FSettings.sell_pets) do
    for pet, _ in pairs(pets) do
        pet_to_egg[pet] = egg
    end
end



local function ParseWholeNumber(input)
    -- Check input is valid (not nil/empty)
    if input == nil or (type(input) == "string" and input:match("^%s*$")) then
        return nil
    end

    -- Try converting to number
    local num = tonumber(input)
    if not num then
        return nil
    end

    -- Only allow whole numbers (integers)
    if num % 1 ~= 0 then
        return nil
    end

    return num
end

local function ParseWeightNumber(input)
    -- Check input is valid (not nil/empty)
    if input == nil or (type(input) == "string" and input:match("^%s*$")) then
        return nil
    end

    -- Try converting to number
    local num = tonumber(input)
    if not num then
        return nil
    end

    return num
end

-- Function to check if a pet is sellable
local function IsPetHatchable(petName)
    if not petName then return false end

    for _, pets in pairs(FSettings.sell_pets) do
        if pets[petName] ~= nil then
            return true
        end
    end

    return false
end

-- Fast lookup when we pass in the pet name
local function getEggNameByPetName(petName)
    return pet_to_egg[petName] or "Unknown Egg"
end


_Helper.ShortName = function(str, max)
    max = max or 5
    if #str > max then
        return str:sub(1, max) .. "..."
    else
        return str
    end
end

_Helper.CountTable = function(t)
    local n = 0
    for _ in pairs(t) do
        n = n + 1
    end
    return n
end


-- these can be in settings and some on stats screen, main page, they are also sent in webhooks
local newlyHatchedNames = {};
local canSendReport = false;
local got_eggs_back = 0;
local recovered_eggs = 0;
local passive_pet_bonus = 0
local pet_size_bonus = 0

local new_pets_hatched_list = {}
Varz.hatched_pets = {}

local is_loadout_ready = false; -- not used, but keep
local is_pet_inventory_full = false
local is_plants_folder_removed = false


local was_backpack_updated = false;

-- Find your farm, do not change this, its tested and reliable
FarmManager.findMyFarm = function()
    for _, farm in ipairs(_S.Workspace:WaitForChild("Farm"):GetChildren()) do
        local owner = farm:FindFirstChild("Important")
            and farm.Important:FindFirstChild("Data")
            and farm.Important.Data:FindFirstChild("Owner")
        if owner and owner:IsA("StringValue") and owner.Value == _S.LocalPlayer.Name then
            return farm
        end
    end
    warn("Farm not found for " .. _S.LocalPlayer.Name)
    return nil
end

FarmManager.mFarm = FarmManager.findMyFarm();
if not FarmManager.mFarm then
    warn("Farm not found")
    return
end
--workspace.Farm.Farm.Important.Objects_Physical
FarmManager.important = FarmManager.mFarm:FindFirstChild("Important")
FarmManager.mObjects_Physical = FarmManager.important and FarmManager.important:FindFirstChild("Objects_Physical")

-- workspace.Farm.Farm.Important.Cosmetic_Physical:GetChildren()
FarmManager.Cosmetic_Physical = FarmManager.important and FarmManager.important:FindFirstChild("Cosmetic_Physical")

FarmManager.Plants_Physical = FarmManager.mFarm:FindFirstChild("Important"):WaitForChild("Plants_Physical")
if not FarmManager.Plants_Physical then return warn("Could not start script: Plants_Physical folder not found.") end

task.wait(0.3)
if not FarmManager.mObjects_Physical then
    warn("Not found mObjects_Physical")
    return
end

FarmManager.Get_Plants_Physical_Objects = function()
    local dx = {}
    if not FarmManager.Plants_Physical then
        return dx
    end
    for index, value in ipairs(FarmManager.Plants_Physical:GetChildren()) do
        table.insert(dx, value)
    end

    if Varz.alt_Plants_Physical then
        for index, value in ipairs(Varz.alt_Plants_Physical:GetChildren()) do
            table.insert(dx, value)
        end
    end

    return dx
end

-- Data
GameDataManager.GetPlayerEggRecovery = function()
    return _S.LocalPlayer:GetAttribute("EggRecoveryChance") or 0
end

GameDataManager.GetPlayerPetSellEggRefundChance = function()
    return _S.LocalPlayer:GetAttribute("PetSellEggRefundChance") or 0
end





FarmManager.IsFarmFullyLoaded = function()
    if _S.LocalPlayer:GetAttribute("FarmFullyLoaded") then
        return true
    end
    return false
end

FarmManager.IsDataFullyLoaded = function()
    if _S.LocalPlayer:GetAttribute("DataFullyLoaded") then
        return true
    end
    return false
end

local UPDATE_LABELS_FUNC = {
    -- updates the main hatching stats
    UpdateSetLblStats = function(_txt)
        if UI_LABELS.lbl_stats then
            UI_LABELS.lbl_stats:SetText(_txt)
        end

        Varz.TEXT_HATCH_SYSTEM = _txt
    end,
    UpdateReclaimStatus = function(_txt)
        if UI_LABELS.lbl_reclaimer_stats then
            UI_LABELS.lbl_reclaimer_stats:SetText(_txt)
        end
    end
}

FarmManager.GetPetsUUIDFromUI = function()
    local a_uuids = {}
    pcall(function()
        local p = _S.PlayerGui.ActivePetUI.Frame.Main.PetDisplay.ScrollingFrame
        if not p then
            return
        end
        for index, item in ipairs(p:GetChildren()) do
            if item:IsA("Frame") and item.Name ~= "PetTemplate" then
                local uuid = item.Name
                if uuid then
                    table.insert(a_uuids, uuid)
                end
            end
        end
    end)

    return a_uuids
end

-- Get all active pets on the farm
FarmManager.GetActivePetsUUIDS = function()
    local pet_uuid_data = {}
    if not _S.petsContainer then return pet_uuid_data end
    local pet_datax = {}
    local owner_name = _S.LocalPlayer.Name

    for _, petmoverpart in ipairs(_S.petsContainer:GetChildren()) do
        if petmoverpart:IsA("Part") and petmoverpart:GetAttribute("OWNER") == owner_name then
            if not petmoverpart:FindFirstChildWhichIsA("Model") then
                continue
            end
            local xuuid = petmoverpart:GetAttribute("UUID")
            if xuuid then
                -- Add the UUID
                pet_uuid_data[xuuid] = true
            end
        end
    end



    local get_ui_pets_uuids = FarmManager.GetPetsUUIDFromUI()

    for _, uuida in ipairs(get_ui_pets_uuids) do
        pet_uuid_data[uuida] = true
    end


    for uuid, value in pairs(pet_uuid_data) do
        table.insert(pet_datax, uuid)
    end


    return pet_datax
end


-- Get all active pets on the farm
FarmManager.GetActivePetsParts = function()
    local pet_uuid_data = {}
    if not _S.petsContainer then return pet_uuid_data end

    for _, petmoverpart in ipairs(_S.petsContainer:GetChildren()) do
        if petmoverpart:IsA("Part") and petmoverpart:GetAttribute("OWNER") == _S.LocalPlayer.Name then
            if not petmoverpart:FindFirstChildWhichIsA("Model") then
                continue
            end
            table.insert(pet_uuid_data, petmoverpart)
        end
    end
    return pet_uuid_data
end

FarmManager.GetActivePetsPetMoverObject = function(_uuid)
    if not _S.petsContainer then return nil end

    for _, petmoverpart in ipairs(_S.petsContainer:GetChildren()) do
        if petmoverpart:IsA("Part") and petmoverpart:GetAttribute("OWNER") == _S.LocalPlayer.Name then
            if not petmoverpart:FindFirstChildWhichIsA("Model") then
                continue
            end
            local UUID = petmoverpart:GetAttribute("UUID")
            if UUID and UUID == _uuid then
                return petmoverpart
            end
        end
    end
    return nil
end


FarmManager.GetSprinklerOnFarm = function(_obname)
    local succ, res = pcall(function()
        local children = FarmManager.mObjects_Physical:GetChildren()
        for _, Item in ipairs(children) do
            local OBJECT_TYPE = Item:GetAttribute("OBJECT_TYPE")
            local OBJECT_UUID = Item:GetAttribute("OBJECT_UUID")
            local READY = Item:GetAttribute("READY")

            if OBJECT_TYPE and OBJECT_UUID then
                if OBJECT_TYPE == _obname then
                    return Item
                end
            end
        end
        return nil
    end)

    if succ then
        return res
    else
        -- print the error
        warn("[FarmManager] GetSprinklerOnFarm failed:", res)
        return nil
    end
end

FarmManager.GetObjectCountByName = function(_PlantName)
    local succ, res = pcall(function()
        local children = FarmManager.mObjects_Physical:GetChildren()
        local count = 0
        for i = 1, #children do
            if children[i].Name == _PlantName then
                count = count + 1
            end
        end
        return count
    end)

    if succ then
        return res
    else
        -- print the error
        warn("[FarmManager] GetObjectCountByName failed:", res)
        return 0
    end
end


FarmManager.GetNameCountByName = function(_PlantName)
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        local count = 0
        for i = 1, #children do
            if children[i].Name == _PlantName then
                count = count + 1
            end
        end
        return count
    end)

    if succ then
        return res
    else
        -- print the error
        warn("[FarmManager] GetObjectCountByName failed:", res)
        return 0
    end
end

FarmManager.GetSinglePlantsObjectUsingName = function(seedName)
    -- Gets all the plant instance for this seedName
    local plantls = nil
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        for _, child in ipairs(children) do
            if child.Name == seedName then
                return child
            end
        end
        return plantls
    end)

    if succ then
        return res
    else
        return plantls
    end
end

FarmManager.GetAllPlantsObjectUsingName = function(seedName)
    -- Gets all the plant instance for this seedName
    local plantls = {}
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        for _, child in ipairs(children) do
            -- if not _FruitCollectorMachine.IsFruitReadyToCollect(child) then
            --     continue
            -- end
            if child.Name == seedName then
                table.insert(plantls, child)
            end
        end
        return plantls
    end)

    if succ then
        return res
    else
        return plantls
    end
end

FarmManager.GetPlantCountBySeed = function(seedName)
    local count = 0
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        for _, child in ipairs(children) do
            if child.Name == seedName then
                count = count + 1
            end
        end
        return count
    end)

    if succ then
        return res
    else
        warn("Failed to count plants:", res)
        return count
    end
end

FarmManager.GetPlantCountBySeedNamesPairs = function(plants_table)
    local keyval = {}
    local result = {}

    -- Build key table for fast lookup
    for plantName, val in pairs(plants_table) do
        keyval[plantName] = true
        result[plantName] = 0 -- initialise count
    end
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        for _, child in ipairs(children) do
            if not keyval[child.Name] then
                continue
            end

            result[child.Name] = result[child.Name] + 1
        end
        return result
    end)

    if succ then
        return res
    else
        warn(" failed:", res)
        return result -- return what we have so far
    end
end


FarmManager.GetPlantCountByNameArrayTable = function(plants_table)
    local keyval = {}
    local result = {}

    -- Build key table for fast lookup
    for _, plantName in ipairs(plants_table) do
        if not plantName.Name then continue end
        keyval[plantName.Name] = true
        result[plantName.Name] = 0 -- initialise count
    end
    local succ, res = pcall(function()
        local children = FarmManager.Get_Plants_Physical_Objects()
        for _, child in ipairs(children) do
            if not keyval[child.Name] then
                continue
            end

            result[child.Name] = result[child.Name] + 1
        end
        return result
    end)

    if succ then
        return res
    else
        warn(" failed:", res)
        return result -- return what we have so far
    end
end




EventsManager.LoadMerchantData = function()
    local merchants = {}

    for MerchantName, MerchantData in pairs(_S.TravelingMerchantData) do
        local shop_items = {}
        local ShopData = MerchantData.ShopData
        local AppearanceChance = MerchantData.AppearanceChance
        local shopName = MerchantData.ShopName
        local Title = MerchantData.Title

        for _key, _val in pairs(ShopData) do
            table.insert(shop_items, _key)
        end

        local dx = {
            ShopItems = shop_items,
            Chance = AppearanceChance,
            Title = Title
        }
        merchants[MerchantName] = dx
    end
    return merchants
end
-- Has data like this ["Shop Name"] = {ShopItems = {"1", "2"},Chance = -1 }
EventsManager.AllTravelingMerchantData = EventsManager.LoadMerchantData()



_Helper.GetPetDataUsingUUID = function(uuid, snapchat)
    local petData = snapchat.Data[uuid]
    return petData
end


_Helper.cache_recent_pet_data = {}



-- Pet info
local function GetPetDataByUUID(uuid)
    local succes, dx = pcall(function()
        local _petData
        --local playerData = _S.ActivePetsService:GetPlayerDatastorePetData(_S.LocalPlayer.Name)
        local playerData = VulnManager.GetBigDataUsingKey("PetsData")

        if playerData and playerData.PetInventory.Data[uuid] then
            _petData = playerData.PetInventory.Data[uuid]
        else
            --warn("Pet not found or ActivePetsService returned nil")
        end

        -- local _petData = _S.PetUtilities:GetPetByUUID(_S.LocalPlayer, uuid) -- do not use, not supported in all execu
        if not _petData then
            --print("pet not found")
            return nil
        end

        local UUID = _petData.UUID
        local PetData = _petData.PetData

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight

        local PetType = _petData.PetType
        local PetAbility = _petData.PetAbility

        return _petData;
    end)

    if succes then return dx end

    warn("Error", dx)
    return nil
end



MutationMachineManager.is_running = false
MutationMachineManager.AllMutationsList = {}
MutationMachineManager.AllMutationListEnum = {}
MutationMachineManager.MaxLevelReachedWantedPets_webhook = {}
MutationMachineManager.AgeBreakWebHook = {}



MutationMachineManager.ResetPetSavedUUID = function()
    FOtherSettings.mut_pet_inside_mutation = ""
    SaveDataOther()
end

MutationMachineManager.SavePetUUID = function(_uuid)
    local success, err = pcall(function()
        -- 1. Fix the 'nil' bug by defaulting to an empty string.
        FOtherSettings.mut_pet_inside_mutation = tostring(_uuid or "")

        -- 2. Call the save function.
        SaveDataOther()
    end)

    -- 3. Check if the pcall failed and warn the user.
    if not success then
        warn("âš ï¸ Failed to save pet UUID:", tostring(err))
    end
end

MutationMachineManager.GetUUID_PetInMachine = function()
    local success, result = pcall(function()
        local old_uuid = FOtherSettings.mut_pet_inside_mutation
        if not old_uuid or old_uuid == "" then
            return ""
        end

        -- Check if the pet is still present
        if not GetPetDataByUUID(old_uuid) then
            -- Pet is in the machine
            return tostring(old_uuid)
        end

        -- Pet exists, so clear the saved state
        MutationMachineManager.ResetPetSavedUUID()
        return ""
    end)

    return success and result or ""
end

MutationMachineManager.GetAllMutationsNoneMachine_KeyPair = function()
    local mut = {}
    for name, data in pairs(_S.PetMutationRegistry.PetMutationRegistry) do
        if not data.AvaliableFromMutationMachine then
            mut[name] = false
        end
    end
    return mut
end


MutationMachineManager.GetAllMutationAsKeyPair = function()
    for name, data in pairs(_S.PetMutationRegistry.PetMutationRegistry) do
        if data.AvaliableFromMutationMachine then

        end

        MutationMachineManager.AllMutationsList[name] = false
        local EnumId = data.EnumId
        MutationMachineManager.AllMutationListEnum[EnumId] = name
    end
    return MutationMachineManager.AllMutationsList
end
MutationMachineManager.GetAllMutationAsKeyPair()

-- seed placements
local function getGridSeedPositions(center)
    local positions = {}

    -- ## Tweak these values to change the shape ##
    local OUTER_WIDTH = 70 -- The total width of the placement area.
    local OUTER_DEPTH = 50 -- The total depth of the placement area.
    local INNER_WIDTH = 14 -- The width of the empty "walk area" in the middle.
    local INNER_DEPTH = 60 -- The depth of the empty "walk area" in the middle.
    local SPACING = 1.5    -- The distance between each spot, smaller for denser packing.

    -- ## Tweak these values to change the shape ##
    -- local OUTER_WIDTH = 70  -- The total width of the placement area.
    -- local OUTER_DEPTH = 50  -- The total depth of the placement area.
    -- local INNER_WIDTH = 14  -- The width of the empty "walk area" in the middle.
    -- local INNER_DEPTH = 60  -- The depth of the empty "walk area" in the middle.
    -- local SPACING = 5       -- The distance between each spot.

    -- Calculate boundaries from the center point
    local halfOuterW = OUTER_WIDTH / 2
    local halfOuterD = OUTER_DEPTH / 2
    local halfInnerW = INNER_WIDTH / 2
    local halfInnerD = INNER_DEPTH / 2

    -- Generate points in a grid pattern
    for x = center.X - halfOuterW, center.X + halfOuterW, SPACING do
        for z = center.Z - halfOuterD, center.Z + halfOuterD, SPACING do
            -- This condition ensures we only add points OUTSIDE the inner walk area
            if math.abs(x - center.X) > halfInnerW or math.abs(z - center.Z) > halfInnerD then
                table.insert(positions, Vector3.new(x, center.Y, z))
            end
        end
    end

    return positions
end


-- This function generates the list of possible egg locations.
local function getPredefinedEggPositions(center)
    local positions = {}

    -- ## Tweak these values to change the shape ##
    local OUTER_WIDTH = 70 -- The total width of the placement area.
    local OUTER_DEPTH = 50 -- The total depth of the placement area.
    local INNER_WIDTH = 14 -- The width of the empty "walk area" in the middle.
    local INNER_DEPTH = 60 -- The depth of the empty "walk area" in the middle.
    local SPACING = 5      -- The distance between each spot.

    -- Calculate boundaries from the center point
    local halfOuterW = OUTER_WIDTH / 2
    local halfOuterD = OUTER_DEPTH / 2
    local halfInnerW = INNER_WIDTH / 2
    local halfInnerD = INNER_DEPTH / 2

    -- Generate points in a grid pattern
    for x = center.X - halfOuterW, center.X + halfOuterW, SPACING do
        for z = center.Z - halfOuterD, center.Z + halfOuterD, SPACING do
            -- This condition ensures we only add points OUTSIDE the inner walk area
            if math.abs(x - center.X) > halfInnerW or math.abs(z - center.Z) > halfInnerD then
                table.insert(positions, Vector3.new(x, center.Y, z))
            end
        end
    end

    return positions
end




-- cleans names for boosts
local function CleanItemNameXpBoosts(rawName)
    if not rawName then return nil end
    local cleaned = rawName:gsub("x%d+", "")
    -- Trim any extra spaces
    cleaned = cleaned:gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")
    return cleaned
end



local function MakeFruitsFav(list)
    for _, item in ipairs(list) do
        _S.FavItem:FireServer(item)
    end
end

local function MakeFruitsFavSingle(_itemTool)
    if not _itemTool then return end
    _S.FavItem:FireServer(_itemTool)
end

_Helper.FavItemCustom = function(_itemTool, fav)
    if not _itemTool then return end
    local is_fav = _itemTool:GetAttribute("d")
    if is_fav and fav then
        return
    end
    _S.FavItem:FireServer(_itemTool)
end


_Helper.IsSafeFruit = function(_toolName)
    for key, value in pairs(FSettings.safe_fruits) do
        local item = InventoryManager.GetFruitUsingToolName(_toolName)
        if item then
            return true
        end
    end
    return false
end

_Helper.SafeFruitsProccess = function()
    local didfav = false
    for key, value in pairs(FSettings.safe_fruits) do
        local item = InventoryManager.GetFruitUsingToolName(key)
        if item then
            _Helper.FavItemCustom(item, key)
        end
    end

    if didfav then
        task.wait(1.5)
    end
end



-- prevent fruits from being collected
function IsPreventAscensionFruitRequirement(fruit)
    if not fruit then
        return false
    end
    if not Varz.AscensionFruitName then
        return false
    end

    if fruit.Name ~= Varz.AscensionFruitName then
        return false
    end

    for mutationName in pairs(Varz.AscensionFruitMutations) do
        if not fruit:GetAttribute(mutationName) then
            --return false -- missing one mutation â†’ fail
        end
    end
    return true -- all mutations present
end

-- Check overrides for pet ["petname"] = {weight:1, override = false}
function IsOverridePetWeight(petName)
    if not petName then return false, false, 0 end
    local overrideData = FOtherSettings.pet_override_weight[petName]
    if not overrideData then
        warn("overrideData is false,false, 0 for " .. petName)
        return false, false, 0
    end

    local is_override = overrideData.override;
    local _weight = tonumber(overrideData.weight);
    local is_big = overrideData.is_big;

    return is_override, is_big, _weight
end

local function extractFirstNumber(str)
    local num = str:match("%d+")
    return tonumber(num) or 0
end


local function IsSprinklerHeld()
    local succ, res = pcall(function()
        local char = _S.Character
        if not char or not char:IsA("Model") then
            return false
        end

        -- Find any equipped tool
        local tool = char:FindFirstChildOfClass("Tool")
        if not tool then
            return false
        end

        -- Check fruit attributes
        local isSprink = tool:GetAttribute("b")
        if not isSprink then
            return false
        end

        local ItemName = tool:GetAttribute("f")

        if ItemName then
            if isSprink == "d" then
                return true
            end
        end

        return false
    end)

    if not succ then
        warn("[IsSprinklerHeld] pcall error:", res)
        return false
    end

    return res
end

local function IsFruitToolHeld()
    local succ, res = pcall(function()
        local char = _S.Character
        if not char or not char:IsA("Model") then
            return false
        end

        -- Find any equipped tool
        local tool = char:FindFirstChildOfClass("Tool")
        if not tool then
            return false
        end

        -- Check fruit attributes
        local isFruit = (tool:GetAttribute("b") == "j")
        local fruitName = tool:GetAttribute("f")

        if isFruit and fruitName then
            return true, fruitName
        end

        return false
    end)

    if not succ then
        warn("[IsFruitToolHeld] pcall error:", res)
        return false
    end

    return res
end

InventoryManager.GetHeldTool = function()
    -- Find any equipped tool
    local char = _S.Character
    if not char or not char:IsA("Model") then
        return nil
    end
    local tool = char:FindFirstChildOfClass("Tool")
    if not tool then
        return nil
    end
    return tool
end

InventoryManager.IsToolHeldAny = function()
    local success, result = pcall(function()
        local char = _S and _S.Character
        if not char or not char:IsA("Model") then
            return false
        end

        return char:FindFirstChildOfClass("Tool") ~= nil
    end)

    if not success then
        warn("[IsToolHeldAny] Error:", result)
        return false
    end

    return result
end


local function IsToolHeldNew(_tool)
    local succ, res = pcall(function()
        if not _tool or typeof(_tool) ~= "Instance" then
            warn("[IsToolHeld] Invalid tool passed:", _tool)
            return false
        end

        local char = _S.Character
        if not char or not char:IsA("Model") then
            return false
        end

        local toolName = _tool.Name
        if not toolName or type(toolName) ~= "string" then
            return false
        end

        for _, child in ipairs(char:GetChildren()) do
            if child:IsA("Tool") then
                if child == _tool then
                    return true
                end
                if string.find(child.Name, toolName, 1, true) then
                    return true
                end
            end
        end

        return false
    end)

    if not succ then
        warn("[IsToolHeld] pcall error:", res)
        return false
    end

    return res
end

local function IsToolHeld(_tool)
    local char = _S.Character
    if not char or not _tool then return false end

    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            -- plain substring match for Trowel
            if string.find(tool.Name, _tool.Name, 1, true) then
                -- compare with the passed-in tool by name
                return true
            end

            if tool == _tool then
                return true
            end
        end
    end

    return false -- no matching trowel held
end

local function EquipToolOnChar(_tool)
    local humanoid = _S.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end

    local success, err = pcall(function()
        humanoid:EquipTool(_tool)
    end)

    if not success then
        warn("âŒ Failed to equip tool:", err)
        return false
    end
    task.wait(0.2)
    return true
end

local function unequipTools()
    local humanoid = _S.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    humanoid:UnequipTools()
    task.wait(0.1)
end



-------------------- Helper

_Helper.ContainsWords = function(str, searchPhrase)
    -- Split the search phrase into individual words
    local words = {}
    for word in string.gmatch(searchPhrase, "%S+") do
        table.insert(words, word)
    end

    -- Check if all words exist in the string
    for _, word in ipairs(words) do
        if not string.find(str, word, 1, true) then
            return false
        end
    end

    return true
end


_Helper.FormatTime = function(seconds)
    -- Handle invalid input
    if not seconds or type(seconds) ~= "number" then
        return "0:00:00"
    end

    -- Prevent negative values
    if seconds < 0 then
        seconds = 0
    end

    -- Round to nearest whole second (in case of floats)
    seconds = math.floor(seconds + 0.5)

    local hours = math.floor(seconds / 3600)
    local minutes = math.floor((seconds % 3600) / 60)
    local secs = seconds % 60

    return string.format("%d:%02d:%02d", hours, minutes, secs)
end


_Helper.UI = {
    updateHomeStats = function(_txt)
        if UI_LABELS.lbl_home_info then
            UI_LABELS.lbl_home_info:SetText(_txt)
        end
    end
}



-- #timer

_Helper.fmt_time = function(secs)
    local m = math.floor(secs / 60)
    local s = math.floor(secs % 60)
    return string.format("%02d:%02d", m, s)
end

_Helper.GetTime = function()
    return DateTime.now().UnixTimestampMillis / 1000
end


-- ðŸ”¹ (Internal Helper) Safely gets or creates the data table for a key
_Helper.GetTimerData = function(key)
    if not FSessionDx.timerecording[key] then
        -- If this key doesn't exist, create its default table
        FSessionDx.timerecording[key] = {
            times = {},
            startTime = 0,
        }
    end
    return FSessionDx.timerecording[key]
end

---


_Helper.StartTimer = function(key)
    local timerData = _Helper.GetTimerData(key)

    -- Check if a timer for this key is already running
    if timerData.startTime ~= 0 then
        -- --- (Optional) Anti-Spam Check ---
        -- If the timer started less than 0.5s ago,
        -- assume this is an accidental double-call and do nothing.
        local liveTime = _Helper.GetTime() - timerData.startTime
        if liveTime < 0.5 then
            return -- Ignore the new call
        end
        -- -------------------------------------

        -- It's a real, running timer. Stop and record it first.
        -- We call StopTimer, let it save, and then we'll start the new one.
        _Helper.StopTimer(key)
    end

    -- Start the new timer
    timerData.startTime = _Helper.GetTime()
end

---

-- ðŸ”¹ Stops a timer, records the time, and saves
-- I added an optional 'maxTimes' argument to make it more flexible
_Helper.StopTimer = function(key, maxTimes)
    maxTimes = maxTimes or 4 -- Default to 4 if not provided

    -- Get or create the data table
    local timerData = _Helper.GetTimerData(key)

    if timerData.startTime == 0 then
        return 0 -- Timer wasn't running
    end

    local elapsed = _Helper.GetTime() - timerData.startTime
    timerData.startTime = 0 -- Stop the timer

    -- Store the elapsed time
    local times = timerData.times
    table.insert(times, elapsed)
    while #times > maxTimes do -- Keep the list trimmed
        table.remove(times, 1)
    end

    SaveManager.SaveSessionSettings.SaveFile()
    return elapsed
end

---

-- ðŸ”¹ Gets the live elapsed time for an active timer
_Helper.GetLiveTime = function(key)
    -- Safely check for the data table
    local timerData = _Helper.GetTimerData(key)
    if not timerData or timerData.startTime == 0 then
        return 0
    end

    return _Helper.GetTime() - timerData.startTime
end

---

-- ðŸ”¹ Gets the average of all recorded times for a key
_Helper.GetAvgTime = function(key)
    -- Safely check for the data table
    local timerData = _Helper.GetTimerData(key)
    if not timerData or #timerData.times == 0 then
        return 0 -- No data, so average is 0
    end

    local times = timerData.times
    local sum = 0
    for _, t in ipairs(times) do
        sum = sum + t
    end

    return sum / #times
end

-- ðŸ”¹ Gets the most recently recorded (previous) time for a key
_Helper.GetPreviousTime = function(key)
    local timerData = _Helper.GetTimerData(key)

    -- Check if data and the 'times' table exist, and if it's not empty
    if not timerData or not timerData.times or #timerData.times == 0 then
        return 0 -- No previous times recorded
    end

    -- Return the last item in the table
    return timerData.times[#timerData.times]
end


_Helper.GetTimerFormatted = function(key)
    local _txt_avgtime = _Helper.GetAvgTime(key)
    local currentTimex = _Helper.GetLiveTime(key)
    local lasttime = _Helper.GetPreviousTime(key)

    -- nicely formatted timer display
    local timer_st = string.format(
        "<font color='#00FF88'>â±ï¸ %s</font> <font color='#FFDD55'>(avg %s) (last %s)</font>",
        _Helper.fmt_time(currentTimex), _Helper.fmt_time(_txt_avgtime), _Helper.fmt_time(lasttime))

    return timer_st
end


----------------- MarketplaceService
MoneyMarkets.CurrentSelectedProductId = ""


MoneyMarkets.UI = {
    UpdateDropDown = function()
        if UI_Dropdown.DropDownMarket then
            if next(MoneyMarkets.Market.products) ~= nil then
                --warn("---------------------- Got Data")
                UI_Dropdown.DropDownMarket:SetValues(GetKeyMutListUsingDir(MoneyMarkets.Market.products))
            else
                --warn("---------------------- Null")
            end
        else
            --warn("-----------------Dont have ui ")
        end

        --market_drop:SetValue();
    end
}



MoneyMarkets.Market = {
    products = {},

    BuySelected = function()
        if MoneyMarkets.CurrentSelectedProductId == 0 or MoneyMarkets.CurrentSelectedProductId == "" then
            Library:Notify("Invalid id: " .. MoneyMarkets.CurrentSelectedProductId)
            return
        end
        local product_id = MoneyMarkets.Market.products[MoneyMarkets.CurrentSelectedProductId]
        if not product_id then
            Library:Notify("Select id not valid ")
            return
        end
        warn("Buy: " .. tostring(product_id))
        Library:Notify("Buying.. Make sure to use right executors ")
        --_S.MarketplaceService:SignalPromptProductPurchaseFinished(_S.LocalPlayer.UserId, product_id, true)
        _S.MarketplaceService:PromptProductPurchase(_S.LocalPlayer, product_id)
    end,

    LoadProducts = function()
        MoneyMarkets.Market.products = {}
        local pages = _S.MarketplaceService:GetDeveloperProductsAsync()

        while true do
            for _, item in ipairs(pages:GetCurrentPage()) do
                MoneyMarkets.Market.products[item.Name] = item.ProductId
                --_Helper.JsonPrint(item)
            end
            if pages.IsFinished then break end
            pages:AdvanceToNextPageAsync()
        end
        Library:Notify("Products Loaded", 2)
        MoneyMarkets.UI.UpdateDropDown()
    end,



}

















-------------------------------------------------
-------- Inventory functions
-------------------------------------------------

InventoryManager.GetFoodCategoryNames = function()
    if not _S or not _S.FoodRecipeData or type(_S.FoodRecipeData.Recipes) ~= "table" then
        --warn("[ListFoodRecipes] FoodRecipeData.Recipes is missing or invalid.")
        return {}
    end

    local recipes = {}
    for name, _ in pairs(_S.FoodRecipeData.Recipes) do
        --print("Food:", name)
        table.insert(recipes, name)
    end

    return recipes
end

InventoryManager.IsFruitAndNotFav = function(_tool)
    local success, isMatch = pcall(function()
        return _tool
            and _tool:IsA("Tool")
            and _tool:GetAttribute("b") == "j"
            and not _tool:GetAttribute("d")
    end)

    return success and isMatch
end

InventoryManager.IsFruit = function(_tool)
    local success, isMatch = pcall(function()
        return _tool
            and _tool:IsA("Tool")
            and _tool:GetAttribute("b") == "j"
    end)

    return success and isMatch
end


InventoryManager.IsFavFruit = function(_tool)
    local isF = _tool:GetAttribute("d")
    if isF then
        return true
    end
    return false
end




InventoryManager.GetFruitCount = function()
    local fcount = 0
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(fruit) then
            fcount = fcount + 1
        end
    end


    local item = _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if InventoryManager.IsFruit(fruit) then
            fcount = fcount + 1
        end
    end

    return fcount
end

InventoryManager.GetFruitCountUsingNameFromData = function(_fruitName)
    local count = 0
    if not Varz.InventoryDataBind or not _fruitName then return count end
    for uuid, data in pairs(Varz.InventoryDataBind) do
        local itemType = data.ItemType
        if itemType ~= "Holdable" then
            continue
        end

        local itemData = data.ItemData
        if not itemData then
            continue
        end

        local itemName = itemData.ItemName
        if itemName == _fruitName then
            count = count + 1
        end
    end
    return count
end



InventoryManager.SprayFruit = function(_fruit)
    _S.SprayService_RE:FireServer("TrySpray", _fruit)
    task.wait(0.1)
end

InventoryManager.IsMutationSpray = function(_tool)
    if not _tool or not _tool:IsA("Tool") then
        return false
    end

    local l = _tool:GetAttribute("l")
    local b = _tool:GetAttribute("b")

    if not l or not b then
        return false
    end
    if b ~= "s" then
        return false
    end

    return l == "Mutation Spray"
end



InventoryManager.GetPetAnyBoostUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        -- must be exactly "z"
        if item:GetAttribute("b") ~= "z" then
            continue
        end
        -- check name here
        if _Helper.ContainsWords(item.Name, _name) then
            return item
        end
        -- another check
        if string.find(item.Name, _name, 1, true) then return item end
    end

    if _S.Character then
        local item = _S.Character:FindFirstChildOfClass("Tool")
        if item then
            if item:GetAttribute("b") ~= "z" then
                return nil
            end
            -- check name here
            if _Helper.ContainsWords(item.Name, _name) then
                return item
            end
            -- another check
            if string.find(item.Name, _name, 1, true) then return item end
        end
    end

    return nil
end



InventoryManager.GetIsFavPetUsingUUID = function(uuid)
    local success, result = pcall(function()
        -- Check backpack
        for _, item in ipairs(_S.Backpack:GetChildren()) do
            if item:IsA("Tool") and item:GetAttribute("PetType") then
                local petUUID = item:GetAttribute("PET_UUID")
                if petUUID and petUUID == uuid then
                    local isFav = item:GetAttribute("d")
                    if isFav then return true end
                end
            end
        end

        -- Check currently equipped tool
        if _S.Character then
            local equipped = _S.Character:FindFirstChildOfClass("Tool")
            if equipped and equipped:IsA("Tool") and equipped:GetAttribute("PetType") then
                local petUUID = equipped:GetAttribute("PET_UUID")
                if petUUID and petUUID == uuid then
                    local isFav = equipped:GetAttribute("d")
                    if isFav then return true end
                end
            end
        end

        return false
    end)

    if success then
        return result
    else
        return false
    end
end

InventoryManager.GetPetUsingName = function(_PetName)
    local is_valid_pet = function(item)
        if item:IsA("Tool") and item:GetAttribute("PetType") then
            local petUUID = item:GetAttribute("PET_UUID")
            if petUUID then
                local _petData = GetPetDataByUUID(petUUID)
                if not _petData then
                    return nil
                end

                local PetData = _petData.PetData
                local IsFavorite = PetData.IsFavorite
                if IsFavorite then
                    return nil
                end

                local Level = PetData.Level
                local BaseWeight = PetData.BaseWeight

                local PetType = _petData.PetType -- name

                if PetType == _PetName then
                    return true
                end
            end
            return nil
        end
    end
    local success, result = pcall(function()
        -- Check backpack
        for _, item in ipairs(_S.Backpack:GetChildren()) do
            if is_valid_pet(item) then
                return item
            end
        end

        -- Check currently equipped tool
        if _S.Character then
            local equipped = _S.Character:FindFirstChildOfClass("Tool")
            if equipped then
                if is_valid_pet(equipped) then
                    return equipped
                end
            end
        end

        return nil
    end)

    if success then
        return result
    else
        warn("Error in GetPetUsingName:", result)
        return nil
    end
end

InventoryManager.GetPetUsingNameForCraft = function(_PetName)
    local is_valid_pet = function(item)
        if item:IsA("Tool") and item:GetAttribute("PetType") then
            local petUUID = item:GetAttribute("PET_UUID")
            if petUUID then
                local _petData = GetPetDataByUUID(petUUID)
                if not _petData then
                    return nil
                end

                local PetData = _petData.PetData
                local IsFavorite = PetData.IsFavorite
                if IsFavorite then
                    return nil
                end

                local Level = PetData.Level
                local BaseWeight = PetData.BaseWeight
                local real_weight = GetRealPetWeight(BaseWeight, 1)
                if real_weight > 3 then
                    return nil
                end

                if Level >= 100 then
                    return nil
                end

                local PetType = _petData.PetType -- name

                if PetType == _PetName then
                    return true
                end
            end
            return nil
        end
    end
    local success, result = pcall(function()
        -- Check backpack
        for _, item in ipairs(_S.Backpack:GetChildren()) do
            if is_valid_pet(item) then
                return item
            end
        end

        -- Check currently equipped tool
        if _S.Character then
            local equipped = _S.Character:FindFirstChildOfClass("Tool")
            if equipped then
                if is_valid_pet(equipped) then
                    return equipped
                end
            end
        end

        return nil
    end)

    if success then
        return result
    else
        warn("Error in GetPetUsingNameForCraft:", result)
        return nil
    end
end

InventoryManager.GetPetUsingUUID = function(uuid)
    local success, result = pcall(function()
        -- Check backpack
        for _, item in ipairs(_S.Backpack:GetChildren()) do
            if item:IsA("Tool") and item:GetAttribute("PetType") then
                local petUUID = item:GetAttribute("PET_UUID")
                if petUUID and petUUID == uuid then
                    return item
                end
            end
        end

        -- Check currently equipped tool
        if _S.Character then
            local equipped = _S.Character:FindFirstChildOfClass("Tool")
            if equipped and equipped:IsA("Tool") and equipped:GetAttribute("PetType") then
                local petUUID = equipped:GetAttribute("PET_UUID")
                if petUUID and petUUID == uuid then
                    return equipped
                end
            end
        end

        return nil
    end)

    if success then
        return result
    else
        warn("Error in GetPetUsingUUID:", result)
        return nil
    end
end

InventoryManager.GetPetBoostUsingName = function(_name)
    local validBoostTypes = { ["PASSIVE_BOOST"] = true, ["PET_XP_BOOST"] = true, ["ABILITY_REFRESH"] = true }
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        -- must be exactly "z"
        if item:GetAttribute("b") ~= "z" then
            continue
        end

        -- must be in valid boost types
        local boostType = item:GetAttribute("q")
        if not validBoostTypes[boostType] then
            continue
        end

        -- check name here
        if _Helper.ContainsWords(item.Name, _name) then
            return item
        end
        -- another check
        if string.find(item.Name, _name, 1, true) then return item end
    end


    -- Check currently equipped tool
    local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if equipped then
        if equipped:GetAttribute("b") ~= "z" then
            return nil
        end

        -- must be in valid boost types
        local boostType = equipped:GetAttribute("q")
        if not validBoostTypes[boostType] then
            return nil
        end

        -- check name here
        if _Helper.ContainsWords(equipped.Name, _name) then
            return equipped
        end
        -- another check
        if string.find(equipped.Name, _name, 1, true) then return equipped end
    end
    return nil
end

InventoryManager.IsFood = function(item)
    if not item:IsA("Tool") then return false end
    if not item:GetAttribute("f") then return false end
    local b = item:GetAttribute("b")
    if b and b == "u" then
        return true
    end

    return false
end


InventoryManager.GetCleansingPetShard = function()
    local _name = "Cleansing Pet Shard"
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "A" then
            continue
        end

        local f = item:GetAttribute("u")
        if not f then continue end
        -- check name here
        if f == _name then
            return item
        end
    end
    return nil
end

InventoryManager.GetFoodUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "u" then
            continue
        end

        local f = item:GetAttribute("f")
        if not f then continue end
        -- check name here
        if f == _name then
            return item
        end
    end
    return nil
end

InventoryManager.UseAnyToolOnScreen = function()
    local args = {
        true,
        CFrame.new(-106.47234344482422, 0, 35.128082275390625, -0.6552270650863647, -0.2765785753726959,
            0.7029806971549988, -1.4901161193847656e-08, 0.9305678606033325, 0.36611974239349365, -0.7554320096969604,
            0.23989154398441315, -0.6097332239151001)
    }
    game:GetService("Players").LocalPlayer.Character:WaitForChild("InputGateway"):WaitForChild("Activation"):FireServer(
        unpack(args))
end

InventoryManager.TryUseGear = function(_name)
    pcall(function()
        _S.TryUseGear:FireServer(_name)
    end)
end

InventoryManager.TryUseGearBoost = function(_name, _petmovermodel)
    pcall(function()
        _S.TryUseGear:FireServer(_name, _petmovermodel)
    end)
end

InventoryManager.TryUseSyrup = function(_pet_object)
    pcall(function()
        _S.TryMapleSyrup:FireServer(_pet_object)
    end)
end

InventoryManager.TryReclaim = function(plantObject)
    pcall(function()
        _S.Reclaimer:FireServer("TryReclaim", plantObject)
    end)
end


InventoryManager.CurrentToolEquipped = function()
    -- currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    return item
end

InventoryManager.OpenSeedPackFast = function(_name)
    if not _name or type(_name) ~= "string" then return print("Invalid pack name") end

    local success, err = pcall(function()
        local pack = _S.GameEvents.SeedPack

        if pack and pack.Open and pack.SpinFinished then
            pack.Open:FireServer(_name)
            task.wait(1)
            pack.SpinFinished:FireServer()
        end
    end)

    if not success then warn(" Failed to open SeedPack: " .. tostring(err)) end
end

InventoryManager.OpenSeedPack = function(_name)
    if not _name or type(_name) ~= "string" then return warn("Invalid pack name") end

    local success, err = pcall(function()
        local pack = _S.GameEvents.SeedPack
        if pack and pack.Open and pack.SpinFinished then
            pack.Open:FireServer(_name)
            task.wait(2)
            pack.SpinFinished:FireServer()
        end
    end)

    if not success then warn(" Failed to open SeedPack: " .. tostring(err)) end
end

InventoryManager.GetSeedPackUsingName = function(packname)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local attr = item:GetAttribute("b")
        if attr and attr ~= "a" then
            continue
        end

        local _name = item:GetAttribute("n")
        if not _name then continue end
        -- check name here
        if _name == packname then
            return item
        end
    end


    -- Check currently equipped tool
    local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if equipped then
        local attr = equipped:GetAttribute("b")
        if attr and attr ~= "a" then
            return nil
        end
        local _name = equipped:GetAttribute("n")
        if not _name then return nil end
        -- check name here
        if _name == packname then
            return equipped
        end
    end


    return nil
end

InventoryManager.UseWateringCan = function(_pos)
    -- flatten y to farm center or fixed height (e.g., 0)
    local flatPos = Vector3.new(_pos.X, 0, _pos.Z)
    _S.Water_RE:FireServer(flatPos)
end

InventoryManager.GetWateringCan = function(_ToolName)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        if not item:GetAttribute("b") then
            continue
        end

        if item:GetAttribute("b") ~= "o" then
            continue
        end
        if string.find(item.Name, _ToolName, 1, true) then
            return item
        end
    end

    -- Check equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if not item:GetAttribute("b") then
            return nil
        end

        if item:GetAttribute("b") ~= "o" then
            return nil
        end
        if string.find(item.Name, _ToolName, 1, true) then
            return item
        end
    end
    return nil
end



-- #petteam
InventoryManager.GetPetTeamData = function(_uuids)
    local dx = {}
    for index, uuid in ipairs(_uuids) do
        local pet_data = GetPetDataByUUID(uuid)
        if not pet_data then continue end

        local PetData = pet_data.PetData
        local PetType = pet_data.PetType or "" -- name

        -- local IsFavorite = PetData.IsFavorite
        --local Boosts = PetData.Boosts
        -- local Name = PetData.Name
        -- local LevelProgress = PetData.LevelProgress
        -- local EggName = PetData.EggName
        local Level = PetData.Level or 1
        -- local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight or 0
        local realw = GetRealPetWeight(BaseWeight, Level)

        local real_weightx = tonumber(string.format("%.2f", realw))

        local MutationType = PetData.MutationType or ""
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""

        local d = {
            petname = PetType,
            weight = real_weightx,
            mutation = CurrentMutationOnPet,
            level = Level,
        }

        table.insert(dx, d);

        --local PetAbility = _petData.PetAbility
    end
    return dx
end





InventoryManager.GetToolUsingName = function(_ToolName)
    if _ToolName == "Watering Can" then
        return InventoryManager.GetWateringCan(_ToolName)
    end

    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        if string.find(item.Name, _ToolName) then
            return item
        end
    end


    -- Check currently equipped tool
    local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if equipped then
        if string.find(equipped.Name, _ToolName) then
            return equipped
        end
    end

    return nil
end

InventoryManager.GetToolUsingNameNormalised = function(_ToolName)
    if not _ToolName then return nil end

    if _ToolName == "Watering Can" then
        return InventoryManager.GetWateringCan(_ToolName)
    end

    -- normalise search term
    local search = _ToolName:gsub("%s+", ""):lower()

    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            local normalised = item.Name:gsub("%s+", ""):lower()
            if string.find(normalised, search, 1, true) then
                return item
            end
        end
    end

    -- Check equipped tool
    local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if equipped then
        local normalised = equipped.Name:gsub("%s+", ""):lower()
        if string.find(normalised, search, 1, true) then
            return equipped
        end
    end

    return nil
end


InventoryManager.GetSeedCountQuantity = function(_tool)
    if not _tool then return 0 end
    local quantity = _tool:GetAttribute("Quantity")
    if quantity then
        return quantity
    end
    return 0
end



InventoryManager.GetSeedUsingName = function(_name)
    local success, result = pcall(function()
        -- Check backpack
        for _, item in ipairs(_S.Backpack:GetChildren()) do
            if not item:IsA("Tool") then continue end

            local b = item:GetAttribute("b")
            if b and b ~= "n" then continue end

            local f = item:GetAttribute("f")
            if not f then continue end

            local seed = item:GetAttribute("Seed")
            if (seed and seed == _name) or (f and f == _name) then
                return item
            end
        end

        -- Check currently equipped tool
        local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
        if equipped then
            local b = equipped:GetAttribute("b")
            if not b or b == "n" then
                local f = equipped:GetAttribute("f")
                local seed = equipped:GetAttribute("Seed")
                if (seed and seed == _name) or (f and f == _name) then
                    return equipped
                end
            end
        end

        return nil
    end)

    if success then
        return result
    else
        warn("Error in GetSeedUsingName:", result)
        return nil
    end
end


InventoryManager.GetSeedCountUsingName = function(_name)
    local _tool = InventoryManager.GetSeedUsingName(_name)
    if _tool then
        local count = InventoryManager.GetSeedCountQuantity(_tool)
        return count
    end
    return 0
end


InventoryManager.GetFruitRandomOrHeld = function()
    -- Check currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if InventoryManager.IsFruit(item) then
            return item
        end
    end
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(fruit) then
            return fruit
        end
    end
    return nil
end

InventoryManager.GetFruitUsingToolName = function(_name)
    -- Check currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if InventoryManager.IsFruit(item) then
            if item.Name == _name then
                return item;
            end
        end
    end
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(fruit) then
            if fruit.Name == _name then
                return fruit;
            end
        end
    end
    return ls
end

InventoryManager.GetTableFruitToolNames = function()
    -- Check currently equipped tool
    local ls = {}
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if InventoryManager.IsFruit(item) then
            table.insert(ls, item.Name);
        end
    end
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(fruit) then
            table.insert(ls, fruit.Name);
        end
    end
    return ls
end

InventoryManager.GetFruitRandom = function()
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(fruit) then
            return fruit
        end
    end
    return nil
end

InventoryManager.GetFruitUsingMutation = function(_mut)
    local hasMut = function(_tool)
        for key, value in pairs(_mut) do
            if _tool:GetAttribute(key) then
                return true
            end
        end
        return false
    end

    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not fruit:IsA("Tool") then continue end
        if fruit:GetAttribute("d") then continue end
        if fruit:GetAttribute("b") ~= "j" then continue end
        local fname = fruit:GetAttribute("f")
        if hasMut(fruit) then
            return fruit
        end
    end
    return nil
end

InventoryManager.GetFruitUsingNameAndMutation = function(_fname, _mut)
    local hasMut = function(_tool)
        if next(_mut) == nil then
            return true
        end
        for key, value in pairs(_mut) do
            if _tool:GetAttribute(key) then
                return true
            end
        end
        return false
    end

    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not fruit:IsA("Tool") then continue end
        if fruit:GetAttribute("d") then continue end
        if fruit:GetAttribute("b") ~= "j" then continue end
        local fname = fruit:GetAttribute("f")
        if hasMut(fruit) and fname == _fname then
            return fruit
        end
    end
    return nil
end

InventoryManager.GetFruitUsingName = function(_name)
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not fruit:IsA("Tool") then continue end
        if fruit:GetAttribute("d") then continue end
        if fruit:GetAttribute("b") ~= "j" then continue end
        local fname = fruit:GetAttribute("f")
        if fname == _name then
            --warn("## Found fruit: " .. fruit.Name)
            return fruit
        end
    end
    return nil
end

InventoryManager.GetFruitUsingUUID = function(_uuid)
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not InventoryManager.IsFood(fruit) then continue end
        local uuid = fruit:GetAttribute("c")
        if uuid == _uuid then
            --warn("## Found fruit: " .. fruit.Name)
            return fruit
        end
    end
    return nil
end

InventoryManager.GetHoldableUsingName = function(_name)
    local is_valid_item = function(item)
        if not item:IsA("Tool") then return nil end
        local b = item:GetAttribute("b")
        if b and b ~= "j" then
            return nil
        end
        local isF = item:GetAttribute("d")
        if isF then
            return nil
        end

        local f = item:GetAttribute("f")
        if not f then return nil end

        -- check name here
        if f == _name then
            return item
        end
        return nil
    end


    for _, item in ipairs(_S.Backpack:GetChildren()) do
        local _t = is_valid_item(item)
        if not _t then continue end
        return item
    end

    -- Check currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        local _t = is_valid_item(item)
        if _t then return item end
    end

    return nil
end

InventoryManager.IsEggTool = function(tool)
    if not tool or not tool:IsA("Tool") then
        return false
    end

    local b = tool:GetAttribute("b")
    local h = tool:GetAttribute("h")

    -- Only allow "c" category and h must exist
    if b == "c" and h then
        return true
    end

    return false
end


InventoryManager.GetEggUsingNameNew = function(_name)
    if typeof(_name) ~= "string" or _name == "" then
        print("fail not a string")
        return nil
    end

    -- First check equipped tool (more accurate)
    local equipped = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if equipped and InventoryManager.IsEggTool(equipped) then
        local eggname = equipped:GetAttribute("h")
        if eggname and string.find(eggname, _name, 1, true) then
            return equipped
        end
    end

    -- Then scan backpack
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsEggTool(item) then
            local eggname = item:GetAttribute("h")

            if eggname and string.find(eggname, _name, 1, true) then
                return item
            end
        end
    end

    return nil
end

InventoryManager.GetEggUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "c" then
            continue
        end
        local h = item:GetAttribute("h")
        if not h then continue end
        -- check name here
        if h == _name then
            return item
        end
    end


    -- Check currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        local b = item:GetAttribute("b")
        if b and b ~= "c" then
            return nil
        end
        local h = item:GetAttribute("h")
        if not h then return nil end
        -- check name here
        if h == _name then
            return item
        end
    end
    return nil
end

InventoryManager.GetCosmeticCrateUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "r" then
            continue
        end
        local i = item:GetAttribute("i")
        if not i then continue end
        -- check name here
        if i == _name then
            return item
        end
    end
    return nil
end

InventoryManager.PlaceBonfire = function(pos)
    _S.BonfireService:FireServer("Create", _Helper.Vector3ToCFrame(pos))
end

InventoryManager.GetBonfire = function()
    local _name = "Bonfire"
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local nx = item:GetAttribute("f")
        if not nx then
            continue
        end
        if nx == _name then
            return item
        end
    end
    return nil
end

InventoryManager.GetShovel = function()
    local succ, res = pcall(function()
        local _name = "Shovel [Destroy Plants]"
        local _uuid = "SHOVEL"

        -- check backpack
        if _S.Backpack then
            for _, item in ipairs(_S.Backpack:GetChildren()) do
                if not item:IsA("Tool") then continue end

                local nx = item:GetAttribute("UUID")
                if nx == _uuid then
                    return item
                end

                if string.find(item.Name, _name, 1, true) then
                    return item
                end
            end
        end

        -- check if player is currently holding the tool
        local char = _S.Character
        if char and char:IsA("Model") then
            for _, child in ipairs(char:GetChildren()) do
                if not child:IsA("Tool") then continue end

                local nx = child:GetAttribute("UUID")
                if nx == _uuid then
                    return child
                end

                if string.find(child.Name, _name, 1, true) then
                    return child
                end
            end
        end

        return nil
    end)

    if not succ then
        warn("[InventoryManager.GetShovel] Error:", res)
        return nil
    end

    return res
end

InventoryManager.GetLightningRod = function()
    local _name = "Lightning Rod"
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "i" then
            continue
        end

        -- check name here
        if string.find(item.Name, _name, 1, true) then
            return item
        end
    end
    return nil
end

InventoryManager.GetRecallWrench = function()
    local _name = "Recall Wrench"
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "q" then
            continue
        end

        -- check name here
        if string.find(item.Name, _name, 1, true) then
            return item
        end
    end
    return nil
end

InventoryManager.GetSmithHammerofHarvest = function()
    local _name         = "Smith Hammer Harvest"

    local is_valid_tool = function(item, pName)
        if not item:IsA("Tool") then return false end
        -- check name here
        if string.find(item.Name, pName) then
            return true
        end
        return false
    end

    local tool          = InventoryManager.CurrentToolEquipped()
    if tool then
        if is_valid_tool(item, _name) then
            return tool
        end
    end

    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if is_valid_tool(item, _name) then
            return item
        end
    end
    return nil
end



InventoryManager.GetHarvestTool = function()
    local _name = "Harvest Tool"
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "f" then
            continue
        end

        -- check name here
        if string.find(item.Name, _name, 1, true) then
            return item
        end
    end
    return nil
end

InventoryManager.GetCleaningSpray = function()
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "s" then
            continue
        end
        local l = item:GetAttribute("l")
        if l and l == "Cleaning Spray" then
            return item
        end
    end
    return nil
end

InventoryManager.GetSprayBottleUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "s" then
            continue
        end
        -- check name here
        if string.find(item.Name, _name, 1, true) then
            return item
        end
    end
    return nil
end

InventoryManager.GetSprinklerUsingName = function(_name)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not item:IsA("Tool") then continue end
        local b = item:GetAttribute("b")
        if b and b ~= "d" then
            continue
        end
        local f = item:GetAttribute("f")
        if f and f == _name then
            return item
        end
    end
    return nil
end



InventoryManager.GetMutSprayChilled = function()
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not InventoryManager.IsMutationSpray(item) then continue end
        local m = item:GetAttribute("m")
        if m and m == "Chilled" then
            return item
        end
    end
    return nil
end

InventoryManager.GetMutSprayWindstruck = function()
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if not InventoryManager.IsMutationSpray(item) then continue end
        local m = item:GetAttribute("m")
        if m and m == "Windstruck" then
            return item
        end
    end
    return nil
end


InventoryManager.ApplySpray = function(fruit, sprayTool, timeOffset)
    if not fruit or not sprayTool then
        return false
    end
    EquipToolOnChar(sprayTool)
    task.wait(0.1 + timeOffset)
    InventoryManager.SprayFruit(fruit)
    task.wait(0.2 + timeOffset)
    unequipTools()
    return true
end

InventoryManager.PlaceSprinkler = function(_location)
    local success, results = pcall(function()
        _S.SprinklerService:FireServer("Create", _Helper.Vector3ToCFrame(_location))
    end)
    if not success then
        warn("Failed to place Sprinkler " .. tostring(results))
        return false
    end
    return true
end



InventoryManager.FavAllFruitsInBackpack = function(markFav, nounequipordelay)
    if not nounequipordelay then
        unequipTools()
    end


    local list = {}

    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(item) then
            local isFav = item:GetAttribute("d")

            -- Skip if already fav
            if not (isFav and markFav) then
                table.insert(list, item)
            end
        end
    end

    -- Check currently equipped tool
    local item = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if item then
        if InventoryManager.IsFruit(item) then
            local isFav = item:GetAttribute("d")

            -- Skip if already fav
            if not (isFav and markFav) then
                table.insert(list, item)
            end
        end
    end

    if #list > 0 then
        MakeFruitsFav(list)
    end

    if not nounequipordelay then
        task.wait(0.5)
    end
end



-- #big
InventoryManager.GetAllPetsUUIDS_Backpack = function()
    local ls = {}
    -- Check backpack
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("PetType") then
            local petUUID = item:GetAttribute("PET_UUID")
            local isFav = item:GetAttribute("d")
            if petUUID and not isFav then
                table.insert(ls, petUUID)
            end
        end
    end

    -- Check currently equipped tool
    if _S.Character then
        local equipped = _S.Character:FindFirstChildOfClass("Tool")
        if equipped and equipped:IsA("Tool") and equipped:GetAttribute("PetType") then
            local petUUID = equipped:GetAttribute("PET_UUID")
            local isFav = equipped:GetAttribute("d")
            if petUUID and not isFav then
                table.insert(ls, petUUID)
            end
        end
    end

    return ls
end



InventoryManager.Gear = {
    GetGearBoosts = function()
        local dx = {}
        for key, value in pairs(_S.GearData) do
            if string.find(key, "Chew", 1) then
                table.insert(dx, key)
            end
        end
        return dx
    end,
    GetAllGearData = function()
        local dx = {}
        for key, value in pairs(_S.GearData) do
            table.insert(dx, key)
        end
        return dx
    end,
    GetAllGearItems = function()
        local dx = {}
        for key, value in pairs(_S.GearData) do
            if string.find(key, "Lollipop", 1) then
                table.insert(dx, key)
                continue
            end
            if string.find(key, "Syrup", 1) then
                table.insert(dx, key)
                continue
            end

            if string.find(key, "Jelly", 1) then
                table.insert(dx, key)
                continue
            end
        end
        return dx
    end,

    GetAllSprinklers = function()
        local dx = {}
        for key, value in pairs(_S.GearData) do
            if string.find(key, "Sprinkler", 1) then
                table.insert(dx, key)
            end
        end
        return dx
    end
}



---------------------------------------------- END InventoryManager


FarmManager.GetTotalFarmPlantCount = function()
    if not FarmManager.Plants_Physical then
        warn("FarmManager.Plants_Physical is nil")
        return 0
    end

    local total_amount = #FarmManager.Get_Plants_Physical_Objects()
    Varz.is_garden_full_seed = total_amount >= 800
    return total_amount
end

-- #seed

Varz.IsSingleHarvest = function(_name)
    if string.find(_name, "Evo") then
        -- return true
    end

    local singleHarvestCrops = {
        ["Aloe Vera"] = true,
        ["Artichoke"] = true,
        ["Bamboo"] = true,
        ["Bendboo"] = true,
        ["Boneboo"] = true,
        ["Buttercup"] = true,
        ["Candy Sunflower"] = true,
        ["Carrot"] = true,
        ["Chocolate Carrot"] = true,
        ["Crocus"] = true,
        ["Daffodil"] = true,
        ["Dandelion"] = true,
        ["Delphinium"] = true,
        ["Dezen"] = true,
        ["Firework Flower"] = true,
        ["Fissure Berry"] = true,
        ["Golden Egg"] = true,
        ["Horsetail"] = true,
        ["Lavender"] = true,
        ["Mandrake"] = true,
        ["Manuka Flower"] = true,
        ["Monoblooma"] = true,
        ["Mushroom"] = true,
        ["Nectarshade"] = true,
        ["Nightshade"] = true,
        ["Onion"] = true,
        ["Orange Tulip"] = true,
        ["Parasol Flower"] = true,
        ["Peace Lily"] = true,
        ["Pink Tulip"] = true,
        ["Pumpkin"] = true,
        ["Radish"] = true,
        ["Rafflesia"] = true,
        ["Red Lollipop"] = true,
        ["Spring Onion"] = true,
        ["Stonebite"] = true,
        ["Taro Flower"] = true,
        ["Watermelon"] = true,
        ["Wild Carrot"] = true,
        ["Zen Rocks"] = true
    }

    if singleHarvestCrops[_name] then
        return true
    end

    return false
end

Varz.GetEfficientEventFruits = function()
    local traits = Varz.PlantsCategoryData
    if not traits then
        warn("PlantsCategoryData not loaded.")
        return {}
    end

    local requiredCategories = {
        ["Berry"] = true,
        ["Flower"] = true,
        ["Fruit"] = true,
        ["Leafy"] = true,
        ["Tropical"] = true,
        ["Vegetable"] = true,
        ["Woody"] = true,
        ["Prickly"] = true,
        ["Stalky"] = true,
    }

    local RarityWeight = {
        Common = 5,
        Uncommon = 4,
        Rare = 3,
        Legendary = 2,
        Mythical = 1,
        Divine = 1,
        Prismatic = 1,
    }

    local categoryScore = {}
    local finalScore = {}

    ----------------------------------------------------------
    -- STEP 1: Count category coverage per fruit
    ----------------------------------------------------------
    for category, enabled in pairs(requiredCategories) do
        local list = traits[category]
        if enabled and list then
            for _, fruit in ipairs(list) do
                if not Varz.IsSingleHarvest(fruit) then
                    local rarity = Varz.SeedRarity[fruit]
                    if rarity then
                        categoryScore[fruit] = (categoryScore[fruit] or 0) + 1
                    end
                end
            end
        end
    end

    ----------------------------------------------------------
    -- STEP 2: Compute final score (seed count dominant)
    ----------------------------------------------------------
    for fruit, count in pairs(categoryScore) do
        local rarity = Varz.SeedRarity[fruit]
        local weight = rarity and RarityWeight[rarity] or 1

        local seedCount = InventoryManager.GetSeedCountUsingName(fruit) or 0

        -- Make seed count dominant by multiplying
        local seedWeight = seedCount * 1.5 -- adjust factor if needed

        -- Final score = seed count weighted + category coverage + rarity
        finalScore[fruit] = seedWeight + (count * weight)
    end

    ----------------------------------------------------------
    -- STEP 3: Build category lists with top 3 fruits
    ----------------------------------------------------------
    local output = {}

    for category, enabled in pairs(requiredCategories) do
        if enabled then
            local list = traits[category]
            output[category] = {}

            if list then
                local scored = {}

                for _, fruit in ipairs(list) do
                    if not Varz.IsSingleHarvest(fruit) then
                        local score = finalScore[fruit]
                        if score then
                            local seedCount = InventoryManager.GetSeedCountUsingName(fruit) or 0

                            table.insert(scored, {
                                name = fruit,
                                score = score,
                                count = seedCount
                            })
                        end
                    end
                end

                -- Sort by seed count first (dominant), then by score
                table.sort(scored, function(a, b)
                    if a.count == b.count then
                        return a.score > b.score
                    end
                    return a.count > b.count
                end)

                -- Take top 3 per category
                for i = 1, 3 do
                    local entry = scored[i]
                    if not entry then break end

                    table.insert(output[category], {
                        seed = entry.name,
                        count = entry.count
                    })
                end
            end
        end
    end


    return output
end



Varz.GetSeedsToPlaceBalanced = function(output, space_onfarm)
    local seedstoplace = {}
    local current_seeds = FarmManager.GetTotalFarmPlantCount()
    local maxSeeds = 800

    if space_onfarm then
        if space_onfarm <= 1 then
            return seedstoplace
        end
        maxSeeds = space_onfarm
    end

    if maxSeeds <= 0 then
        return seedstoplace
    end

    -- Collect all categories
    local categories = {}
    for category, _ in pairs(output) do
        table.insert(categories, category)
    end
    local numCategories = #categories
    if numCategories == 0 then return seedstoplace end

    -- Determine target seeds per category
    local seedsPerCategory = math.floor(maxSeeds / numCategories)
    local leftoverSeeds = maxSeeds - (seedsPerCategory * numCategories)

    -- Track remaining availability per seed globally
    local seedAvailability = {}
    for category, seeds in pairs(output) do
        for _, entry in ipairs(seeds) do
            seedAvailability[entry.seed] = entry.count
        end
    end

    -- Allocate seeds per category
    for _, category in ipairs(categories) do
        local seeds = output[category]
        if seeds and #seeds > 0 then
            local seedsLeftToAllocate = seedsPerCategory

            while seedsLeftToAllocate > 0 do
                local progress = false
                for _, entry in ipairs(seeds) do
                    local seedName = entry.seed
                    local available = seedAvailability[seedName] -
                        (seedstoplace[seedName] and seedstoplace[seedName].placeamount or 0)
                    if available > 0 and seedsLeftToAllocate > 0 then
                        seedstoplace[seedName] = seedstoplace[seedName] or { placeamount = 0 }
                        seedstoplace[seedName].placeamount = seedstoplace[seedName].placeamount + 1
                        seedsLeftToAllocate = seedsLeftToAllocate - 1
                        progress = true
                    end
                end
                if not progress then break end
            end
        end
    end


    local idx = 1
    while leftoverSeeds > 0 do
        -- 1. Add a progress flag
        local progress = false

        -- 2. Loop a maximum of one full cycle (numCategories times)
        for i = 1, numCategories do
            local category = categories[idx]
            local seeds = output[category]
            if seeds and #seeds > 0 then
                for _, entry in ipairs(seeds) do
                    local seedName = entry.seed
                    local available = seedAvailability[seedName] -
                        (seedstoplace[seedName] and seedstoplace[seedName].placeamount or 0)
                    if available > 0 then -- We know leftoverSeeds > 0 from the 'while'
                        seedstoplace[seedName] = seedstoplace[seedName] or { placeamount = 0 }
                        seedstoplace[seedName].placeamount = seedstoplace[seedName].placeamount + 1
                        leftoverSeeds = leftoverSeeds - 1
                        progress = true -- We successfully allocated a seed
                        break           -- break from inner 'for' loop
                    end
                end
            end

            idx = idx + 1
            if idx > numCategories then idx = 1 end

            if progress or leftoverSeeds == 0 then
                break
            end
        end

        -- 5. If we did a full cycle and made no progress, we are stuck.
        --    Break the outer 'while' loop.
        if not progress then
            break
        end
    end

    return seedstoplace
end

Varz.BuildEventSeedText = function(data)
    local function colour(txt, hex)
        return "<font color='" .. hex .. "'>" .. txt .. "</font>"
    end

    local final = {}

    -- category colour
    local catColour = "#43B581"   -- greenish
    local seedColour = "#FEE75C"  -- gold
    local countColour = "#99AAB5" -- grey

    for category, list in pairs(data) do
        -- CATEGORY TITLE
        table.insert(final, colour("<b>" .. category .. "</b>", catColour))

        -- SEEDS
        if #list == 0 then
            table.insert(final, colour("  â€¢ No seeds available", "#FF5555"))
        else
            for _, info in ipairs(list) do
                table.insert(
                    final,
                    "  â€¢ "
                    .. colour(info.seed, seedColour)
                    .. colour(" (x" .. info.count .. ")", countColour)
                )
            end
        end

        table.insert(final, "") -- spacing
    end

    return table.concat(final, "\n")
end



-- Store references inside the _Helper table
_Helper.compactStatusContainer = nil
_Helper.compactStatusLabel = nil

-- New function name to avoid conflicts
_Helper.updateCompactStatus = function(statusTable)
    -- 1. ENSURE THE GUI EXISTS
    -- Access the container and label via the _Helper table
    local right_edge_margin = 20
    local screen_percent_width = 0.35


    local default_text_size = 18
    local small_text_size = 14          -- You can adjust this
    local small_screen_threshold = 1000 -- (e.g., 700px) Adjust this width threshold

    local textsize = default_text_size  -- Default

    local currentCamera = workspace.CurrentCamera
    if currentCamera then
        -- If screen width is less than the threshold, use the small size
        if currentCamera.ViewportSize.X < small_screen_threshold then
            textsize = small_text_size
        end
    end

    if not _Helper.compactStatusContainer or not _Helper.compactStatusContainer.Parent then
        local player = _S.LocalPlayer
        if not player then return end

        local playerGui = _S.PlayerGui
        -- Use a unique name for this ScreenGui
        local statusGui = playerGui:FindFirstChild("CompactStatusGui")
        if not statusGui then
            statusGui = Instance.new("ScreenGui")
            statusGui.Name = "CompactStatusGui" -- Unique name
            statusGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            statusGui.ResetOnSpawn = false
            statusGui.Parent = playerGui
            statusGui.DisplayOrder = 0 -- Different display order
        end

        -- This Frame will hold our single text label
        _Helper.compactStatusContainer = statusGui:FindFirstChild("CompactStatusContainer")
        if not _Helper.compactStatusContainer then
            _Helper.compactStatusContainer = Instance.new("Frame")
            _Helper.compactStatusContainer.Name = "CompactStatusContainer" -- Unique name
            _Helper.compactStatusContainer.Parent = statusGui
            _Helper.compactStatusContainer.BackgroundTransparency = 1

            -- Position: Right-side, center, with 10px padding from the edge
            _Helper.compactStatusContainer.AnchorPoint = Vector2.new(1, 0.5)
            _Helper.compactStatusContainer.Position = UDim2.new(1, -right_edge_margin, 0.5, 0)

            -- Size: 30% of screen width, height will be automatic
            _Helper.compactStatusContainer.Size = UDim2.new(screen_percent_width, 0, 0, 0)
            _Helper.compactStatusContainer.AutomaticSize = Enum.AutomaticSize.Y
        end

        -- Find or create the single TextLabel
        _Helper.compactStatusLabel = _Helper.compactStatusContainer:FindFirstChild("CompactStatusDisplay")
        if not _Helper.compactStatusLabel then
            -- Clean up just in case
            for _, child in ipairs(_Helper.compactStatusContainer:GetChildren()) do
                if child:IsA("TextLabel") then
                    child:Destroy()
                end
            end

            _Helper.compactStatusLabel = Instance.new("TextLabel")
            _Helper.compactStatusLabel.Name = "CompactStatusDisplay" -- Unique name
            _Helper.compactStatusLabel.Parent = _Helper.compactStatusContainer

            -- --- Styling ---
            _Helper.compactStatusLabel.Size = UDim2.new(1, 0, 1, 0)         -- Fill the container
            _Helper.compactStatusLabel.AutomaticSize = Enum.AutomaticSize.Y -- Grow height with text
            _Helper.compactStatusLabel.BackgroundTransparency = 1
            _Helper.compactStatusLabel.RichText = true
            _Helper.compactStatusLabel.Font = Enum.Font.SourceSansBold
            _Helper.compactStatusLabel.TextColor3 = Color3.new(1, 1, 1)
            _Helper.compactStatusLabel.TextSize = textsize
            _Helper.compactStatusLabel.TextStrokeTransparency = 0.5
            _Helper.compactStatusLabel.TextWrapped = true
            _Helper.compactStatusLabel.ZIndex = 1

            -- Align text to the right, starting from the top
            _Helper.compactStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
            _Helper.compactStatusLabel.TextYAlignment = Enum.TextYAlignment.Top
            --_Helper.compactStatusLabel.Text = ""
        end
    elseif not _Helper.compactStatusLabel or not _Helper.compactStatusLabel.Parent then
        -- Fallback in case the label gets destroyed somehow
        _Helper.compactStatusLabel = _Helper.compactStatusContainer:FindFirstChild("CompactStatusDisplay")
        if not _Helper.compactStatusLabel then
            _Helper.compactStatusContainer = nil -- Force a full rebuild next frame
            return
        end
    end

    -- 2. UPDATE THE SINGLE LABEL
    -- Combine all strings in the table with a newline character
    local combinedText = table.concat(statusTable, "\n")

    -- Set the text
    _Helper.compactStatusLabel.Text = combinedText
end


-- This will now store our single TextLabel
local statusLabel        = nil

_Helper.updateStatusList = function(statusTable)
    -- 1. FIND OR CREATE THE GUI AND SINGLE TEXT LABEL

    local default_text_size = 18
    local small_text_size = 14          -- You can adjust this
    local small_screen_threshold = 1000 -- (e.g., 700px) Adjust this width threshold

    local textsize = default_text_size  -- Default

    local currentCamera = workspace.CurrentCamera
    if currentCamera then
        -- If screen width is less than the threshold, use the small size
        if currentCamera.ViewportSize.X < small_screen_threshold then
            textsize = small_text_size
        end
    end


    if not statusLabel or not statusLabel.Parent then
        local player = _S.LocalPlayer
        if not player then return end

        local playerGui = _S.PlayerGui
        local statusGui = playerGui:FindFirstChild("StatusGui")
        if not statusGui then
            statusGui = Instance.new("ScreenGui")
            statusGui.Name = "StatusGui"
            statusGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            statusGui.ResetOnSpawn = false
            statusGui.Parent = playerGui
            statusGui.DisplayOrder = 3
        end

        -- This single TextLabel will hold all of our status lines
        statusLabel = statusGui:FindFirstChild("StatusDisplay")
        if not statusLabel then
            statusLabel = Instance.new("TextLabel")
            statusLabel.Name = "StatusDisplay"
            statusLabel.Parent = statusGui

            -- --- Positioning (from old container) ---
            statusLabel.Size = UDim2.new(0.3, 0, 0.4, 0)
            statusLabel.AnchorPoint = Vector2.new(0, 0.5)
            statusLabel.Position = UDim2.new(0, 120, 0.65, 0)

            -- --- Text Styling (from old label) ---
            statusLabel.BackgroundTransparency = 1
            statusLabel.RichText = true
            statusLabel.Font = Enum.Font.SourceSansBold
            statusLabel.TextColor3 = Color3.new(1, 1, 1)
            statusLabel.TextSize = textsize
            statusLabel.TextStrokeTransparency = 0.5

            -- Align text to the top-left
            statusLabel.TextXAlignment = Enum.TextXAlignment.Left
            statusLabel.TextYAlignment = Enum.TextYAlignment.Top
        end
    end

    -- 2. UPDATE THE SINGLE TEXT LABEL
    -- Combine all lines from the table, separated by a newline ("\n")
    local combinedText = table.concat(statusTable, "\n")

    -- Set the text of our single label
    statusLabel.Text = combinedText
end










-------Event Shops

_EventShops.Season = {
    -- Returns a table of all season shop items with default selection `false`
    ClaimSeasonPoints = function()
        if not FSettings.auto_claim_season_points then
            return
        end
        -- Remote
        pcall(function()
            local ClaimSeasonPassInfReward = _S.ReplicatedStorage.GameEvents.SeasonPass
                .ClaimSeasonPassInfReward -- RemoteEvent

            ClaimSeasonPassInfReward:FireServer(
                51,
                false
            )
        end)
    end,
    GetAllSeasonShopItems = function()
        local productNames = {}

        local success, err = pcall(function()
            for name in pairs(_S.SeasonPassShop.ShopItems) do
                table.insert(productNames, name)
            end
        end)

        if not success then
            warn("Failed to get season shop items:", err)
        end

        return productNames
    end,

    -- Buys all selected items in the season shop
    BuySeasonShopItem = function()
        local items = FOtherSettings.season_pass_shop_items
        for name, selected in pairs(items) do
            if selected then
                for i = 1, 3 do
                    _S.BuySeasonPassStock:FireServer(name)
                    task.wait(0.7)
                end
            end
        end
    end
}

_EventShops.FallBuyPetsShop = function()
    local shop_index = 3
    local success, result = pcall(function()
        for key, value in pairs(FOtherSettings.fall_pets_shop) do
            if value then
                for i = 1, 10 do
                    _S.BuyEventShopStock:FireServer(key, shop_index)
                end
            end
        end
        return true
    end)

    if success then
        return true
    else
        return false
    end
end

_EventShops.FallBuySeedsShop = function()
    local shop_index = 1
    local success, result = pcall(function()
        for key, value in pairs(FOtherSettings.fall_seeds_shop) do
            if value then
                for i = 1, 10 do
                    _S.BuyEventShopStock:FireServer(key, shop_index)
                end
            end
        end
        return true
    end)

    if success then
        return true
    else
        return false
    end
end


_EventShops.FallBuyCosmeticsShop = function()
    local shop_index = 4
    local success, result = pcall(function()
        for key, value in pairs(FOtherSettings.fall_cosmetic_shop) do
            if value then
                for i = 1, 10 do
                    _S.BuyEventShopStock:FireServer(key, shop_index)
                end
            end
        end
        return true
    end)

    if success then
        return true
    else
        return false
    end
end

_EventShops.FallBuyGearsShop = function()
    local shop_index = 2
    local success, result = pcall(function()
        for key, value in pairs(FOtherSettings.fall_gear_shop) do
            if value then
                for i = 1, 10 do
                    _S.BuyEventShopStock:FireServer(key, shop_index)
                end
            end
        end
        return true
    end)

    if success then
        return true
    else
        return false
    end
end




---------------------------------------------------
------------------ Boost Manager #boost
---------------------------------------------------

MonsterBoostManager.GetBoostAmounts = function(boost_name)
    return MonsterBoostManager.ItemAmounts[boost_name] or 0
end


-- Helper to check if a specific boost is active in the list
-- MonsterBoostManager.GetBoostTimeLeft = function(boost_list, boost_name, amount)
--     local times = 0
--     if not boost_list or type(boost_list) ~= "table" then return times end

--     for _, boost in pairs(boost_list) do
--         -- Check if the type matches (e.g., "PASSIVE_BOOST")
--         if boost.BoostType == boost_name and MonsterBoostManager.GetBoostAmounts(boost_name) == amount then
--             if boost.Time < 0 then
--                 return 0
--             else
--                 times = boost.Time
--             end
--         end
--     end
--     return times
-- end

MonsterBoostManager.GetBoostTimeLeft = function(boost_list, target_type, target_amount)
    if not boost_list then return 0 end

    for _, boost in pairs(boost_list) do
        if boost.BoostType == target_type then
            -- If we provided a specific amount to look for...
            if target_amount then
                -- Check if the active boost is equal to or better than what we want
                if boost.BoostAmount and boost.BoostAmount == target_amount then
                    return boost.Time
                end
            else
                -- If no amount specified, just return the time matches the type
                return boost.Time
            end
        end
    end
    return 0
end


MonsterBoostManager.FindBoostToolUsingName = function(_boostname)
    if not _boostname then return nil end


    for _, tool in ipairs(_S.Backpack:GetChildren()) do
        if not tool:IsA("Tool") then continue end
        local q = tool:GetAttribute("q")
        if not q then continue end
        if not MonsterBoostManager.Boost_Types[q] then
            continue
        end

        local _name = tool.Name
        local _cleanname = CleanItemNameXpBoosts(_name)

        if _cleanname and _cleanname == _boostname then
            return tool
        end
    end

    -- Check currently equipped tool
    local tool = _S.Character and _S.Character:FindFirstChildOfClass("Tool")
    if tool then
        local q = tool:GetAttribute("q")
        if q and MonsterBoostManager.Boost_Types[q] then
            local _name = tool.Name
            local _cleanname = CleanItemNameXpBoosts(_name)

            if _cleanname and _cleanname == _boostname then
                return tool
            end
        end
    end


    -- tool not found
    return nil
end

MonsterBoostManager.ApplyBoostToPet = function(uuid)
    _S.BoostService:FireServer("ApplyBoost", uuid)
end

MonsterBoostManager.ApplyBoostHeldKoi = function()
    local active_pet_list = FarmManager:GetActivePetsUUIDS()
    if not active_pet_list then return nil end

    for key, value in pairs(FOtherSettings.boost_koi_team_list) do
        if value then
            -- find and hold this tool.
            local _tool = MonsterBoostManager.FindBoostToolUsingName(key)
            if not _tool then
                --warn("Tool not found for " .. key)
                continue
            end
            unequipTools()
            task.wait(0.1)
            EquipToolOnChar(_tool)
            task.wait(0.3)
            for _, pet_uuid in ipairs(active_pet_list) do
                _S.BoostService:FireServer("ApplyBoost", pet_uuid)
            end
            task.wait(1)
        end
    end
    unequipTools()
    task.wait(0.1)
end

MonsterBoostManager.ApplyBoostSelected = function(_boostlist)
    local active_pet_list = FarmManager:GetActivePetsUUIDS()
    if not active_pet_list then return false end
    if not _boostlist then
        return false
    end

    for key, value in pairs(_boostlist) do
        if value then
            -- find and hold this tool.
            local _tool = MonsterBoostManager.FindBoostToolUsingName(key)
            if not _tool then
                --warn("Tool not found for " .. key)
                continue
            end
            unequipTools()
            task.wait(0.1)
            if not EquipToolOnChar(_tool) then
                continue
            end
            task.wait(0.3)
            for _, pet_uuid in ipairs(active_pet_list) do
                _S.BoostService:FireServer("ApplyBoost", pet_uuid)
            end
            task.wait(0.9)
        end
    end
    task.wait(0.1)
    unequipTools()
end

-- #boost
MonsterBoostManager.ApplyBoostSelectedWithPetNames = function(_boostlist, petListNames)
    local active_pet_list = FarmManager:GetActivePetsUUIDS()
    if not active_pet_list then return false end
    if not _boostlist then
        return false
    end

    if not petListNames then return false end
    -- empty check
    local allow_all_pets = false
    if next(petListNames) == nil then
        allow_all_pets = true
    end

    local pet_uuid_filtered = {}

    for _, muuid in pairs(active_pet_list) do
        local _petData = GetPetDataByUUID(muuid)
        if not _petData then continue end
        if _petData == nil then continue end

        --local UUID = _petData.UUID
        local PetData = _petData.PetData
        local Boosts = PetData.Boosts

        --local Name = PetData.Name
        --local LevelProgress = PetData.LevelProgress
        --local EggName = PetData.EggName
        --local Level = PetData.Level
        --local Hunger = PetData.Hunger
        --local BaseWeight = PetData.BaseWeight


        local PetType = _petData.PetType -- pets name
        local PetAbility = _petData.PetAbility


        local needs_boost = false
        local need_boost_counter = 0

        for boostName, value in pairs(_boostlist) do
            local boost_type_convert = MonsterBoostManager.GetTypeFromItemName(boostName)
            -- [NEW] Get the specific amount required for this item
            local required_amount = MonsterBoostManager.GetBoostAmounts(boostName)
            local time_left = MonsterBoostManager.GetBoostTimeLeft(Boosts, boost_type_convert, required_amount)
            if time_left < 2 then
                needs_boost = true
                break
            end
        end

        if not needs_boost then continue end


        if allow_all_pets then
            table.insert(pet_uuid_filtered, muuid)
        else
            if petListNames[PetType] then
                table.insert(pet_uuid_filtered, muuid)
            end
        end
    end

    if #pet_uuid_filtered == 0 then
        return false
    end

    for key, value in pairs(_boostlist) do
        if value then
            -- find and hold this tool.
            local _tool = MonsterBoostManager.FindBoostToolUsingName(key)
            if not _tool then
                --print("Boost not found: " .. key)
                continue
            end
            unequipTools()
            task.wait(0.3)
            if not EquipToolOnChar(_tool) then
                continue
            end
            task.wait(0.6)
            for _, pet_uuid in ipairs(pet_uuid_filtered) do
                _S.BoostService:FireServer("ApplyBoost", pet_uuid)
            end
            task.wait(1.5)
        end
    end
    task.wait(0.1)
    unequipTools()
    return true
end



-- #ele

MonsterBoostManager.elephant = {
    UpdateStatus = function(_txt)
        if UI_LABELS.lbl_elephant_booster_status then
            UI_LABELS.lbl_elephant_booster_status:SetText(_txt)
        end
    end
}


MonsterBoostManager.ApplyBoostSelectedWithTargetPetsElephant = function(_boostlist, petListNames)
    -- local active_pet_list = FarmManager:GetActivePetsUUIDS()
    -- if not active_pet_list then return false end
    if not _boostlist then
        return false
    end

    if not petListNames then return false end

    local pet_uuid_filtered = {}

    for uuid, value in pairs(petListNames) do
        table.insert(pet_uuid_filtered, uuid)
    end

    -- for _, muuid in pairs(active_pet_list) do
    --     if petListNames[muuid] then
    --         table.insert(pet_uuid_filtered, muuid)
    --     end
    -- end

    for key, value in pairs(_boostlist) do
        -- find and hold this tool.
        local _tool = MonsterBoostManager.FindBoostToolUsingName(key)
        if not _tool then
            continue
        end
        if not IsToolHeldNew(_tool) then
            unequipTools()
            if not EquipToolOnChar(_tool) then
                continue
            end
        end
        for _, pet_uuid in ipairs(pet_uuid_filtered) do
            --warn("Applied boost to " .. pet_uuid)
            _S.BoostService:FireServer("ApplyBoost", pet_uuid)
        end
        --task.wait(0.8)
    end
end
---------------------------------------------------
------------------ End Boost Manager
---------------------------------------------------


------====== #GameData #data #pack

GameDataManager.IsAllowedPackOpen = function()
    if Varz.IS_DIG or Varz.QUEST_TASK_RUNNING or Varz.IS_COOKING or Varz.IS_HATCHING or Varz.IS_CRAFTING or Varz.IS_LEVELUP_RUNNING or Varz.IS_SEEDING or Varz.IS_WATERING or Varz.IS_Sprinkler or Varz.IS_SHOVELING then
        return false
    end
    return true
end

GameDataManager.IsAllowedSellPet = function()
    if Varz.IS_DIG or Varz.QUEST_TASK_RUNNING or Varz.IS_COOKING or Varz.IS_HATCHING or Varz.IS_CRAFTING or Varz.IS_LEVELUP_RUNNING or Varz.IS_SEEDING or Varz.IS_WATERING or Varz.IS_Sprinkler or Varz.IS_SHOVELING then
        return false
    end
    return true
end

GameDataManager.LoopPackOpenerAuto = function()
    if not FSettings.seedpack.is_active then
        return false
    end
    local selected_packs = FSettings.seedpack.selected_packs
    if next(selected_packs) == nil then
        return false
    end

    if not GameDataManager.IsAllowedPackOpen() then
        return false
    end

    if FSettings.seedpack.openwithoutui then
        if _S.PlayerGui:FindFirstChild("RollCrate_UI") then
            _S.PlayerGui.RollCrate_UI:Destroy()
        end
    end




    for Name, value in pairs(selected_packs) do
        if not GameDataManager.IsAllowedPackOpen() then
            break
        end

        -- Pause
        if Varz.IsPaused() then
            break
        end

        if not FSettings.seedpack.is_active then
            break
        end
        local tool = InventoryManager.GetSeedPackUsingName(Name)
        if not tool then
            --warn("Not found: " .. Name)
            continue
        end
        if tool then
            unequipTools()
            task.wait(0.1)
            EquipToolOnChar(tool)
            for i = 1, 100, 1 do
                if not GameDataManager.IsAllowedPackOpen() then
                    break
                end
                if not tool then
                    break
                end

                if not FSettings.seedpack.is_active then
                    break
                end

                if not IsToolHeld(tool) then
                    break
                end


                InventoryManager.OpenSeedPackFast(Name)

                task.wait(1)
            end
        end
    end

    return true
end


---------- FRUIT Collection Machine
_FruitCollectorMachine.avoid_category_names = {
    ["Summer"] = true,
    ["Zen"] = true,
    ["Magical"] = true,
    ["Prehistoric"] = true,
    ["Root"] = true,
    ["Toxic"] = true,
    ["Fungus"] = true,
}

_FruitCollectorMachine.IsAnyPlantsSelected  = function()
    for _name, _val in pairs(FOtherSettings.collection_plants) do
        if _val then
            return true
        end
    end
    return false
end



_FruitCollectorMachine.GetRandomFoodWithExcluded = function()
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not InventoryManager.IsFood(fruit) then
            continue
        end
        local _namestr = fruit:GetAttribute("f")
        if FOtherSettings.feeding_exlude_food_list[_namestr] then
            continue
        end
        if InventoryManager.GetFoodUsingName(_namestr) then
            return fruit
        end
    end
    return nil
end


_FruitCollectorMachine.GetRandomFood = function()
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not InventoryManager.IsFood(fruit) then
            continue
        end
        local _namestr = fruit:GetAttribute("f")
        if InventoryManager.GetFoodUsingName(_namestr) then
            return fruit
        end
    end
    return nil
end


_FruitCollectorMachine.GetRandomFruitForFeed = function()
    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruitAndNotFav(fruit) then
            return fruit
        end
    end
    return nil
end

_FruitCollectorMachine.GetFoodForFeedUsingName = function(_FoodName)
    for _, food in ipairs(_S.Backpack:GetChildren()) do
        if food:GetAttribute("b") ~= "u" then continue end
        local foodname = food:GetAttribute("f")
        if foodname and foodname == _FoodName then
            return food
        end
    end
    return nil
end

_FruitCollectorMachine.HasPlantByName = function(plantName)
    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if plantModel:IsA("Model") and plantModel.Name == plantName then
            --warn("HasPlantByName: ", plantName)
            local is_fav = plantModel:GetAttribute("Favorited")
            if is_fav then
                --warn("This fruit is fav");
                continue
            end
            return true
        end
    end
    return false
end

-- #fruit
_FruitCollectorMachine.HasPlantByNameAndMutationOnFarm = function(plantName, _mut)
    local _HasMut = function(fruit)
        if next(_mut) == nil then
            return true
        end
        for key, value in pairs(_mut) do
            if fruit:GetAttribute(key) then
                return true
            end
        end
        return false
    end
    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if plantModel:IsA("Model") and plantModel.Name == plantName then
            local is_fav = plantModel:GetAttribute("Favorited")
            if is_fav then
                continue
            end

            if not _HasMut(plantModel) then
                continue
            end

            return true
        end
    end
    return false
end

_FruitCollectorMachine.PlantSeed = function(position, seedName)
    local success, err = pcall(function()
        _S.PlantRemote:FireServer(position, seedName)
    end)
end


_FruitCollectorMachine.PlaceSeedSmart = function(_seedName, _amount)
    local seed_tool = InventoryManager.GetSeedUsingName(_seedName)
    if not seed_tool then
        --print("Don't have seed: " .. tostring(_seedName))
        return false
    end

    if Varz.IS_HATCHING then
        return false
    end

    local center = FarmManager.mFarm.Center_Point.Position
    local availablePositions = getGridSeedPositions(center)

    local placePos = availablePositions[math.random(1, #availablePositions)]
    -- teleport
    local hrp = _S.Character:WaitForChild("HumanoidRootPart")
    -- Save the current CFrame
    local originalCFrame = hrp.CFrame
    Varz.IS_SEEDING = true
    task.wait(2.5)

    local anyplaced = false
    if InventoryManager.IsToolHeldAny() then
        unequipTools()
        task.wait(0.4)
    end

    if not EquipToolOnChar(seed_tool) then
        Varz.IS_SEEDING = false
        return false
    end

    TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(placePos))
    task.wait(2)
    for i = 1, _amount, 1 do
        if IsToolHeldNew(seed_tool) then
            _FruitCollectorMachine.PlantSeed(placePos, _seedName)
            anyplaced = true
        else
            break
        end

        task.wait(0.8)
        if Varz.IS_HATCHING then
            break
        end
    end
    Varz.IS_SEEDING = false
    TeleportPlayerToCFrame(originalCFrame)

    if anyplaced then
        unequipTools()
    end
    return true
end

_FruitCollectorMachine.GetSeedForTree = function(fruitname)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "n" then
            local is_fav = item:GetAttribute("d")
            local f_uuid = item:GetAttribute("c")
            local fname = item:GetAttribute("f")   -- fruit name
            local Variant = item:GetAttribute("Variant");
            local Seed = item:GetAttribute("Seed") -- seed name
            local Quantity = item:GetAttribute("Quantity")

            if fname == fruitname or Seed == fruitname then
                return item;
            end
        end
    end

    -- player maybe holding this tool check it
    -- Then check Character (player might be holding it)
    for _, item in ipairs(_S.Character:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "n" then
            local fname = item:GetAttribute("f")
            local Seed = item:GetAttribute("Seed")

            if fname == fruitname or Seed == fruitname then
                return item
            end
        end
    end

    return nil
end

_FruitCollectorMachine.PlantsTrees = function(plants_array)
    if not plants_array or #plants_array == 0 then
        return false
    end

    if Varz.is_garden_full_seed then
        return false
    end

    local max_plant_per_tree = 1

    local center = FarmManager.mFarm.Center_Point.Position
    local availablePositions = getGridSeedPositions(center)

    for i = #availablePositions, 2, -1 do
        local j = math.random(i)
        availablePositions[i], availablePositions[j] = availablePositions[j], availablePositions[i]
    end

    local plants_clean = {}

    for _, fname in ipairs(plants_array) do
        if not plants_clean[fname] then
            plants_clean[fname] = 0
        end
        plants_clean[fname] = plants_clean[fname] + 1
    end

    for fruitName, amount in pairs(plants_clean) do
        local seed_tool = _FruitCollectorMachine.GetSeedForTree(fruitName)
        if not seed_tool then
            continue
        end

        if Varz.is_garden_full_seed then
            unequipTools()
            task.wait(0.1)
            return false
        end

        unequipTools()
        task.wait(0.3)
        EquipToolOnChar(seed_tool)
        task.wait(0.9)

        local famount = amount * max_plant_per_tree

        for i = 1, famount do
            if #availablePositions == 0 then
                --warn("No more predefined placement spots available.")
                break
            end
            --local placePos = table.remove(availablePositions)
            local placePos = availablePositions[math.random(1, #availablePositions)]
            if placePos then
                _FruitCollectorMachine.PlantSeed(placePos, fruitName)
                --warn("placed seed ")
                task.wait(0.2)
            else
                --warn("cant find palce")
            end
        end
    end

    unequipTools()
    task.wait(0.1)
    return true
end

_FruitCollectorMachine.GetPlantPosition = function(_fruit)
    -- First, check if the object exists and is a valid instance in the game.
    if not _fruit or not _fruit.Parent then
        return nil
    end

    -- Use a protected call (pcall) to safely execute the function.
    -- This catches any errors if _fruit doesn't have :GetPivot() or if it fails.
    local success, positionOrError = pcall(function()
        return _fruit:GetPivot().Position
    end)

    if success then
        return positionOrError -- âœ… On success, return the Vector3 position.
    else
        -- âŒ On failure, warn about the error and return nil.
        warn("Could not get fruit position:", tostring(_fruit), "| Error:", positionOrError)
        return nil
    end
end

_FruitCollectorMachine.IsFruitGrown = function(_fruit)
    -- Check to see if this fruit is ready for collection or is it still growing.
    if not _fruit then
        return false
    end

    local maxAge = _fruit:GetAttribute("MaxAge")


    local current_age = 0
    local xsuccess1, p_age = pcall(function()
        return tonumber(_fruit.Grow.Age.Value)
    end)

    if not xsuccess1 or not maxAge or not p_age then
        return false
    else
        current_age = p_age
    end

    local xxsuccess, promptEnabled = pcall(function()
        local prompt = _fruit:FindFirstChildWhichIsA("ProximityPrompt", true)
        return prompt and prompt.Enabled
    end)

    if xxsuccess and promptEnabled then
        --print("Prompt is enabled âœ…")
        return true
    elseif xxsuccess and not promptEnabled then
        --print("Prompt is disabled âŒ")
        return false
    else
        --warn("Error checking prompt:", promptEnabled) -- promptEnabled holds the error msg if pcall fails
    end

    if current_age >= maxAge then
        return true
    end

    return false
end

_FruitCollectorMachine.GetFruitVariant = function(_fruit)
    local successv, varresult = pcall(function()
        return _fruit.Variant.Value
    end)

    local Variant = "Normal"
    if successv then
        Variant = varresult
    end

    return Variant
end

_FruitCollectorMachine.IsFruitReadyToCollect = function(_fruit)
    -- Check to see if this fruit is ready for collection or is it still growing.
    if not _fruit then
        return false
    end

    local is_fav = _fruit:GetAttribute("Favorited")

    if is_fav == true then
        -- can't collect favourite fruits
        return false
    end

    local maxAge = _fruit:GetAttribute("MaxAge")



    local success, fweight = pcall(function()
        return tonumber(_fruit.Weight.Value)
    end)

    local fruit_weight = 0
    if success then
        fruit_weight = fweight
        --print("Weight:", fweight)
    else
        warn("Could not get weight:", weight) -- weight here is the error msg
        return false
    end
    local minWeight = tonumber(FOtherSettings.g_fruit_weight_min)
    local maxWeight = tonumber(FOtherSettings.g_fruit_weight_max)

    -- Check allowed weight it must be betwen min and max e.g. 1,100 and if fruit is 1 to 100 then is valid
    if fruit_weight > maxWeight or fruit_weight < minWeight then
        --warn("fruit weight out of range: " .. fruit_weight)
        return false
    end

    if maxAge then
        maxAge = tonumber(maxAge)
        local xsuccess, p_age = pcall(function()
            return tonumber(_fruit.Grow.Age.Value)
        end)

        if not xsuccess or not maxAge or not p_age then
            return false
        end

        --warn("Fruit age ".. p_age .."/" .. maxAge)

        if p_age < maxAge then
            -- can't collects fruits that are growing.
            --print("not ready")
            return false
        end

        local xxsuccess, promptEnabled = pcall(function()
            local prompt = _fruit:FindFirstChildWhichIsA("ProximityPrompt", true)
            return prompt and prompt.Enabled
        end)

        if xxsuccess and promptEnabled then
            return true
        elseif xxsuccess and not promptEnabled then
            return false
        else
            return false
        end
    end

    -- All checks passed. you may collect this fruit.
    return true
end

_FruitCollectorMachine.HarvestFruitsUsingNames = function(_fruitNames, amount_per_fruit)
    -- Collects fruits. table passed in
    local fruitsToCollect = {}
    local collectedCount = {}
    --- local MAX_PER_COLLECTION = 3 -- not used leave for future expansion
    local MAX_PER_FRUIT = 2

    if amount_per_fruit then
        MAX_PER_FRUIT = amount_per_fruit
    end

    -- only leave * fruit for asen at max
    local MAX_ASCENSION_TO_LEAVE = 1
    local ascensionFruitsFound = {}

    -- Turn _fruitNames into a multiset (counts)
    local fruitLimits = {}
    for _, fname in ipairs(_fruitNames) do
        if not fruitLimits[fname] then
            fruitLimits[fname] = MAX_PER_FRUIT
        else
            fruitLimits[fname] = fruitLimits[fname] + MAX_PER_FRUIT
        end
    end


    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end
        if not plantModel.Name then continue end
        if not fruitLimits[plantModel.Name] then
            continue
        end

        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            local fruitType = plantModel.Name
            ascensionFruitsFound[fruitType] = ascensionFruitsFound[fruitType] or 0
            collectedCount[fruitType] = collectedCount[fruitType] or 0

            -- per-fruit (multiset) cap
            if collectedCount[fruitType] >= fruitLimits[fruitType] then
                continue
            end

            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end
            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
                collectedCount[fruitType] = collectedCount[fruitType] + 1
            else
                --ascensionFruitsFound = ascensionFruitsFound + 1
                ascensionFruitsFound[fruitType] = ascensionFruitsFound[fruitType] + 1
                if ascensionFruitsFound[fruitType] > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                    collectedCount[fruitType] = collectedCount[fruitType] + 1
                end
            end
        end
    end

    --_Helper.JsonPrint(collectedCount)

    if #fruitsToCollect > 0 then
        --warn("fruitsToCollect --- " .. #fruitsToCollect)
        _S.collectEvent:FireServer(fruitsToCollect)
        task.wait(0.3)
        return true
    end

    --warn("NO fruits ")
    return false
end


_FruitCollectorMachine.CollectFruitByNamesBatchMode = function(_fruitNames, _amount)
    -- Collects fruits. key/val table passed in
    local fruitsToCollect = {}
    local MAX_PER_COLLECTION = _amount or 15

    -- only leave 2 fruit for asen at max
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end
        if plantModel.Name and not _fruitNames[plantModel.Name] then continue end

        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if #fruitsToCollect >= MAX_PER_COLLECTION then
                break
            end

            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end
            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    if #fruitsToCollect > 0 then
        --warn("fruitsToCollect --- ")
        task.spawn(function()
            _S.collectEvent:FireServer(fruitsToCollect)
        end)
        task.wait(0.1)



        --local collectedfruits = 0
        -- for _, fruitx in ipairs(fruitsToCollect) do
        --     _S.collectEvent:FireServer({ fruitx })
        --     collectedfruits = collectedfruits + 1
        --     task.wait(0.06)
        -- end

        return true
    end

    --warn("NO fruits ")
    return false
end

-- local SeedRarities = {
--     Common = 1,
--     Uncommon = 2,
--     Rare = 3,
--     Legendary = 4,
--     Mythical = 5,
--     Divine = 6,
--     Prismatic = 7,
-- }

local SeedRarities = {
    Common = 1,
    Uncommon = 2,
    Rare = 3,
    Legendary = 4,
    Mythical = 5,
    Divine = 6,
    Prismatic = 7,
    Transcendent = 8,
}

-- #mutcount
_FruitCollectorMachine.CountMutationOnFruit = function(fruit, countmutx)
    -- FIX 1 & 3: Ensure countmut is a number. Default to 1 if nil.
    local countmut = tonumber(countmutx) or 0

    -- Optimization: If we are looking for 0 or fewer mutations, it's always true
    if countmut <= 0 then return true end

    local found = 0
    local fruitAttrs = fruit:GetAttributes()
    if not fruitAttrs then return false end

    -- FIX 2: Ensure list_mutations exists (assuming it is global or file-local)
    -- If it's a global, you might need _G.list_mutations or ensure it is required above.
    if type(list_mutations) ~= "table" then
        print("Error: list_mutations table not found")
        return false
    end

    for attrName, _ in pairs(fruitAttrs) do
        if list_mutations[attrName] ~= nil then
            found = found + 1
            -- Optimization: Stop looping as soon as we meet the requirement
            if found >= countmut then return true end
        end
    end

    return found >= countmut
end





-- Sort backpack tools by fruit rarity
InventoryManager.GetFruitOfRarity = function(rarity_list, amount, bypassrarity)
    local sortableList = {}

    -- 1. Gather tools and pre-calculate their weight
    local children = _S.Backpack:GetChildren()
    local added = 0

    local filter_rarity = true

    if bypassrarity then
        filter_rarity = false
    end

    for _, tool in ipairs(children) do
        if tool:IsA("Tool") and InventoryManager.IsFruit(tool) then
            local fruitName = tool:GetAttribute("f")

            -- Get the Rarity String (e.g., "Legendary")
            -- Ensure Varz exists, otherwise default to Common
            local rarityName = Varz.SeedRarity[fruitName] or "Common"
            -- print("Rarity: ", rarityName)

            if filter_rarity then
                if rarity_list[rarityName] then
                    table.insert(sortableList, tool)
                    added = added + 1
                end
            else
                table.insert(sortableList, tool)
                added = added + 1
            end



            if added >= amount then
                break
            end
        end
    end
    return sortableList
end

-- Sort backpack tools by fruit rarity
InventoryManager.GetFruitsFromBackpackSorted = function()
    local sortableList = {}

    -- 1. Gather tools and pre-calculate their weight
    local children = _S.Backpack:GetChildren()

    for _, tool in ipairs(children) do
        if tool:IsA("Tool") and InventoryManager.IsFruit(tool) then
            local fruitName = tool:GetAttribute("f")

            -- Get the Rarity String (e.g., "Legendary")
            -- Ensure Varz exists, otherwise default to Common
            local rarityName = Varz.SeedRarity[fruitName] or "Common"

            -- Get the Numeric Weight (e.g., 4)
            local weight = SeedRarities[rarityName] or 1

            table.insert(sortableList, {
                Tool = tool,
                Name = fruitName,
                Weight = weight
            })
        end
    end

    -- 2. Sort by Weight (Highest First), then Name (A-Z)
    table.sort(sortableList, function(a, b)
        if a.Weight == b.Weight then
            -- If rarity is the same, sort alphabetically
            return a.Name < b.Name
        end
        -- Otherwise, sort by Rarity (Highest to Lowest)
        return a.Weight > b.Weight
    end)

    -- 3. Extract just the tools to return
    local sortedTools = {}
    for _, entry in ipairs(sortableList) do
        table.insert(sortedTools, entry.Tool)
    end

    return sortedTools
end

-- #fruit
_FruitCollectorMachine.CollectFruitByNamesSortedRarityConfig = function(_fruitNames, config)
    -- Collects fruits. key/val table passed in
    local _amount = config.amount or 15
    local is_batch = config.batch_mode or false
    local submitFunction = config.submit_function or nil
    local whitelist_mut = config.whitelist_mutation or {}
    local blacklist_mut = config.blacklist_mutation or {}
    local variants = config.variants or {}
    local max_mutation_number = config.mut_count or 0

    -- This list will hold all fruits we find, along with their plant name for sorting
    local allValidFruits = {}
    local MAX_PER_COLLECTION = _amount or 15

    -- 1. GATHER ALL VALID FRUITS
    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end

        -- Get the name and check if it's in our filter
        local plantName = plantModel.Name
        if not plantName or not _fruitNames[plantName] then continue end

        local potentialFruits = {}
        local fruitsFolder = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if fruit == nil then
                continue
            end
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end


            if max_mutation_number > 0 then
                if not _FruitCollectorMachine.CountMutationOnFruit(fruit, max_mutation_number) then
                    continue
                end
            end

            if next(variants) ~= nil then
                local current_variant = _FruitCollectorMachine.GetFruitVariant(fruit)
                if not variants[current_variant] then
                    continue
                end
            end

            if not _FruitCollectorMachine.CheckMutationUsingLists(fruit, blacklist_mut, whitelist_mut) then
                continue
            end

            -- **KEY CHANGE**: Store the fruit object AND its plant name for sorting
            table.insert(allValidFruits, { FruitObject = fruit, PlantName = plantName })
        end
    end


    -- 2. SORT THE LIST BY RARITY
    table.sort(allValidFruits, function(entryA, entryB)
        -- Get the rarity name (e.g., "Rare") using the plant name
        -- Default to "Common" if not found in Varz.SeedRarity
        local rarityNameA = Varz.SeedRarity[entryA.PlantName] or "Common"
        local rarityNameB = Varz.SeedRarity[entryB.PlantName] or "Common"

        -- Get the numerical weight for that rarity
        -- Default to 1 (Common's weight) if not in our weights table
        local weightA = SeedRarities[rarityNameA] or 1
        local weightB = SeedRarities[rarityNameB] or 1

        -- Sort from highest weight to lowest (Prismatic -> Common)
        return weightA > weightB
    end)





    -- 3. CREATE FINAL LIST (respecting MAX_PER_COLLECTION)
    local fruitsToCollect = {}
    for i = 1, math.min(#allValidFruits, MAX_PER_COLLECTION) do
        -- We only need the actual object for the collection event
        table.insert(fruitsToCollect, allValidFruits[i].FruitObject)
    end



    -- 4. COLLECT THE (NOW SORTED AND LIMITED) FRUITS
    if #fruitsToCollect > 0 then
        local collectedfruits = 0

        if is_batch then
            -- ==========================================================
            -- START: MODIFIED BATCH LOGIC
            -- ==========================================================
            -- Send this batch to the server
            local BATCH_SIZE = 25

            -- Loop through the entire list in steps of BATCH_SIZE
            for i = 1, #fruitsToCollect, BATCH_SIZE do
                local batch = {}
                if Varz.backpack_full then
                    break
                end
                -- Define the end of this specific batch
                local endIndex = math.min(i + BATCH_SIZE - 1, #fruitsToCollect)

                -- Create the batch table
                for j = i, endIndex do
                    table.insert(batch, fruitsToCollect[j])
                end

                -- Send this batch to the server
                if #batch > 0 then
                    _S.collectEvent:FireServer(batch)
                    collectedfruits = collectedfruits + #batch
                    -- Note: No wait here for "quicky send"

                    if submitFunction then
                        submitFunction()
                        -- submit it right away
                    end
                end
                task.wait(0.1)
            end
            -- ==========================================================
            -- END: MODIFIED BATCH LOGIC
            -- ==========================================================
        else
            for _, fruitx in ipairs(fruitsToCollect) do
                if Varz.backpack_full then
                    break
                end

                _S.collectEvent:FireServer({ fruitx })
                collectedfruits = collectedfruits + 1
                task.wait(0.2)
                if submitFunction then
                    submitFunction()
                    -- submit it right away
                end
            end
        end

        if collectedfruits > 0 then
            return true
        end
    end

    return false
end

_FruitCollectorMachine.CollectFruitByNamesSortedRarity = function(_fruitNames, _amount, is_batch, submitFunction)
    -- Collects fruits. key/val table passed in

    -- This list will hold all fruits we find, along with their plant name for sorting
    local allValidFruits = {}
    local MAX_PER_COLLECTION = _amount or 15

    -- 1. GATHER ALL VALID FRUITS
    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end

        -- Get the name and check if it's in our filter
        local plantName = plantModel.Name
        if not plantName or not _fruitNames[plantName] then continue end

        local potentialFruits = {}
        local fruitsFolder = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            -- **KEY CHANGE**: Store the fruit object AND its plant name for sorting
            table.insert(allValidFruits, { FruitObject = fruit, PlantName = plantName })
        end
    end


    -- 2. SORT THE LIST BY RARITY
    table.sort(allValidFruits, function(entryA, entryB)
        -- Get the rarity name (e.g., "Rare") using the plant name
        -- Default to "Common" if not found in Varz.SeedRarity
        local rarityNameA = Varz.SeedRarity[entryA.PlantName] or "Common"
        local rarityNameB = Varz.SeedRarity[entryB.PlantName] or "Common"

        -- Get the numerical weight for that rarity
        -- Default to 1 (Common's weight) if not in our weights table
        local weightA = SeedRarities[rarityNameA] or 1
        local weightB = SeedRarities[rarityNameB] or 1

        -- Sort from highest weight to lowest (Prismatic -> Common)
        return weightA > weightB
    end)





    -- 3. CREATE FINAL LIST (respecting MAX_PER_COLLECTION)
    local fruitsToCollect = {}
    for i = 1, math.min(#allValidFruits, MAX_PER_COLLECTION) do
        -- We only need the actual object for the collection event
        table.insert(fruitsToCollect, allValidFruits[i].FruitObject)
    end



    -- 4. COLLECT THE (NOW SORTED AND LIMITED) FRUITS
    if #fruitsToCollect > 0 then
        local collectedfruits = 0

        if is_batch then
            -- ==========================================================
            -- START: MODIFIED BATCH LOGIC
            -- ==========================================================
            -- Send this batch to the server
            local BATCH_SIZE = 25

            -- Loop through the entire list in steps of BATCH_SIZE
            for i = 1, #fruitsToCollect, BATCH_SIZE do
                local batch = {}
                if Varz.IS_HATCHING or Varz.backpack_full then
                    break
                end
                -- Define the end of this specific batch
                local endIndex = math.min(i + BATCH_SIZE - 1, #fruitsToCollect)

                -- Create the batch table
                for j = i, endIndex do
                    table.insert(batch, fruitsToCollect[j])
                end

                -- Send this batch to the server
                if #batch > 0 then
                    _S.collectEvent:FireServer(batch)
                    collectedfruits = collectedfruits + #batch
                    -- Note: No wait here for "quicky send"

                    if submitFunction then
                        submitFunction()
                        -- submit it right away
                    end
                end
                task.wait(0.1)
            end
            -- ==========================================================
            -- END: MODIFIED BATCH LOGIC
            -- ==========================================================
        else
            for _, fruitx in ipairs(fruitsToCollect) do
                if Varz.IS_HATCHING or Varz.backpack_full then
                    break
                end

                _S.collectEvent:FireServer({ fruitx })
                collectedfruits = collectedfruits + 1
                task.wait(0.2)
                if submitFunction then
                    submitFunction()
                    -- submit it right away
                end
            end
        end

        if collectedfruits > 0 then
            return true
        end
    end

    return false
end


_FruitCollectorMachine.CollectFruitByNames = function(_fruitNames, _amount)
    -- Collects fruits. key/val table passed in
    local fruitsToCollect = {}
    local MAX_PER_COLLECTION = _amount or 15

    -- only leave 2 fruit for asen at max
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end
        if plantModel.Name and not _fruitNames[plantModel.Name] then continue end

        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if #fruitsToCollect >= MAX_PER_COLLECTION then
                break
            end

            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end
            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    -- local colleted = 0
    -- for _, fruit in ipairs(fruitsToCollect) do
    --     _S.collectEvent:FireServer({fruit})
    --     colleted = colleted+1
    --     task.wait()
    -- end

    -- if colleted > 0 then
    --     return true
    -- end

    if #fruitsToCollect > 0 then
        --warn("fruitsToCollect --- ")
        --_S.collectEvent:FireServer(fruitsToCollect)
        local collectedfruits = 0
        for _, fruitx in ipairs(fruitsToCollect) do
            if Varz.IS_HATCHING then
                break
            end
            _S.collectEvent:FireServer({ fruitx })
            collectedfruits = collectedfruits + 1
            task.wait(0.1)
        end

        if collectedfruits > 0 then
            return true
        end
    end

    --warn("NO fruits ")
    return false
end

-- returns a key/value if you pass in fruit type like Berry
_FruitCollectorMachine.GetPlantsByCategoryName = function(categoryName)
    if not Varz.PlantsCategoryData then
        return nil
    end
    local dir = {}
    local c = Varz.PlantsCategoryData[categoryName]
    if c then
        for index, value in ipairs(c) do
            dir[value] = true
        end
        return dir
    end
    return nil
end

-- return fruit category using fruit name
_FruitCollectorMachine.GetPlantsCategoryUsingFruitName = function(fruitName)
    if not Varz.PlantsCategoryData then
        return nil
    end
    local dir = {}

    for key, value in pairs(Varz.PlantsCategoryData) do
        -- print("Checking: " .. key .. ", Value:" , _S.HttpService:JSONEncode(value))
        -- avoid any category
        if _FruitCollectorMachine.avoid_category_names[key] then
            continue
        end
        for _, vx in ipairs(value) do
            if vx == fruitName then
                return key
            end
        end
    end

    return nil
end


_FruitCollectorMachine.CheckMutationUsingLists = function(fruit, blacklist, whitelist)
    -- Check blacklist first (always overrides)
    for name, selected in pairs(blacklist) do
        if selected and fruit:GetAttribute(name) then
            return false
        end
    end

    -- Check whitelist
    local whitelistExists = false
    for name, selected in pairs(whitelist) do
        whitelistExists = true
        if fruit:GetAttribute(name) then
            return true
        end
    end

    -- If whitelist exists but no match â†’ block
    if whitelistExists then
        return false
    end

    -- No whitelist or blacklist matched â†’ allow
    return true
end


_FruitCollectorMachine.CheckMutationWhiteBlackList = function(fruit)
    -- Check blacklist first (always overrides)
    for name, selected in pairs(FOtherSettings.mutation_blacklist) do
        if selected and fruit:GetAttribute(name) then
            return false
        end
    end

    -- Check whitelist
    local whitelistExists = false
    for name, selected in pairs(FOtherSettings.mutation_whitelist) do
        if selected then
            whitelistExists = true
            if fruit:GetAttribute(name) then
                return true
            end
        end
    end

    -- If whitelist exists but no match â†’ block
    if whitelistExists then
        return false
    end

    -- No whitelist or blacklist matched â†’ allow
    return true
end


_FruitCollectorMachine.GetRandomFruitsIgnoreMutation = function(requireMut)
    local fruitsToCollect = {}
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    local _HasMut = function(fruit)
        for key, value in pairs(requireMut) do
            if fruit:GetAttribute(key) then
                return true
            end
        end
        return false
    end

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            if _HasMut(fruit) then
                continue
            end


            -- local shouldCollect = _FruitCollectorMachine.CheckMutationWhiteBlackList(fruit)
            -- if not shouldCollect then
            --     continue
            -- end

            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    return fruitsToCollect
end



_FruitCollectorMachine.GetRandomFruitsWithMutation = function(requireMut)
    local fruitsToCollect = {}
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    local _HasMut = function(fruit)
        for key, value in pairs(requireMut) do
            if fruit:GetAttribute(key) then
                return true
            end
        end
        return false
    end

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            if not _HasMut(fruit) then
                continue
            end


            -- local shouldCollect = _FruitCollectorMachine.CheckMutationWhiteBlackList(fruit)
            -- if not shouldCollect then
            --     continue
            -- end

            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    return fruitsToCollect
end



_FruitCollectorMachine.GetFruitsUsingNameAndMutation = function(_fname, requireMut)
    local fruitsToCollect = {}
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    local _HasMut = function(fruit)
        if next(requireMut) == nil then
            return true
        end
        for key, value in pairs(requireMut) do
            if fruit:GetAttribute(key) then
                return true
            end
        end
        return false
    end

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            if _fname ~= fruit.Name then
                continue
            end

            if not _HasMut(fruit) then
                continue
            end


            -- local shouldCollect = _FruitCollectorMachine.CheckMutationWhiteBlackList(fruit)
            -- if not shouldCollect then
            --     continue
            -- end

            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    return fruitsToCollect
end


_FruitCollectorMachine.GetFruitsReadyForCollectionAny = function()
    local fruitsToCollect = {}
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            -- local shouldCollect = _FruitCollectorMachine.CheckMutationWhiteBlackList(fruit)
            -- if not shouldCollect then
            --     continue
            -- end

            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    return fruitsToCollect
end

_FruitCollectorMachine.GetFruitsReadyForCollection = function()
    local fruitsToCollect = {}
    local MAX_ASCENSION_TO_LEAVE = 2
    local ascensionFruitsFound = 0

    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local is_valid_plant = false
        local any_selected = _FruitCollectorMachine.IsAnyPlantsSelected()
        if any_selected then
            -- check what plant
            --warn("Check plant: " , plantModel.Name)
            is_valid_plant = FOtherSettings.collection_plants[plantModel.Name]
        else
            -- no plant is selected. so pick any
            is_valid_plant = true
        end

        if not is_valid_plant then
            continue
        end


        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end

        -- Process any fruits found
        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end

            local shouldCollect = _FruitCollectorMachine.CheckMutationWhiteBlackList(fruit)
            if not shouldCollect then
                continue
            end

            local isPreventAsen1 = IsPreventAscensionFruitRequirement(fruit)

            if not isPreventAsen1 then
                table.insert(fruitsToCollect, fruit)
            else
                ascensionFruitsFound = ascensionFruitsFound + 1
                if ascensionFruitsFound > MAX_ASCENSION_TO_LEAVE then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
    end

    return fruitsToCollect
end



-- Collect fruits with mutation
_FruitCollectorMachine.CollectFruitUsingNameAndMutations = function(_fname, _mut, _amount)
    local allFruitsToCollect = _FruitCollectorMachine.GetFruitsUsingNameAndMutation(_fname, _mut)
    if #allFruitsToCollect == 0 then
        return 0
    end

    local collected_am = 0

    for _, fruit in ipairs(allFruitsToCollect) do
        if collected_am >= _amount then
            break
        end

        if Varz.IS_HATCHING then
            break
        end
        _S.collectEvent:FireServer({ fruit })
        collected_am = collected_am + 1
        task.wait()
    end
    -- all collected
    return collected_am
end

-- Collect fruits with mutation
_FruitCollectorMachine.CollectFruitsRandomWithMutation = function(_amount, _mut)
    local allFruitsToCollect = _FruitCollectorMachine.GetRandomFruitsWithMutation(_mut)
    if #allFruitsToCollect == 0 then
        return 0
    end

    local collected_am = 0

    for _, fruit in ipairs(allFruitsToCollect) do
        if collected_am >= _amount then
            break
        end

        if Varz.IS_HATCHING then
            -- warn("HATCHING")
            break
        end
        _S.collectEvent:FireServer({ fruit })
        collected_am = collected_am + 1
        task.wait()
    end
    -- all collected
    return collected_am
end


-- Collect fruits
_FruitCollectorMachine.CollectFruitsRandomWithIgnoreMut = function(_amount, IgnoreMut)
    local allFruitsToCollect = _FruitCollectorMachine.GetRandomFruitsIgnoreMutation(IgnoreMut)
    if #allFruitsToCollect == 0 then
        return 0
    end

    local collected_am = 0

    for _, fruit in ipairs(allFruitsToCollect) do
        if collected_am >= _amount then
            break
        end

        if Varz.IS_HATCHING then
            -- warn("HATCHING")
            break
        end
        _S.collectEvent:FireServer({ fruit })
        collected_am = collected_am + 1
        task.wait()
    end
    -- all collected
    return collected_am
end

-- Collect fruits
_FruitCollectorMachine.CollectFruitsRandom = function(_amount)
    local allFruitsToCollect = _FruitCollectorMachine.GetFruitsReadyForCollectionAny()
    if #allFruitsToCollect == 0 then
        return 0
    end

    local collected_am = 0

    for _, fruit in ipairs(allFruitsToCollect) do
        if collected_am >= _amount then
            break
        end

        if Varz.IS_HATCHING then
            -- warn("HATCHING")
            break
        end
        _S.collectEvent:FireServer({ fruit })
        collected_am = collected_am + 1
        task.wait(0.1)
    end
    -- all collected
    return collected_am
end


-- Collect fruits
_FruitCollectorMachine.CollectFruitForSeedingSystem = function(_amount)
    local allFruitsToCollect = _FruitCollectorMachine.GetFruitsReadyForCollection()
    if #allFruitsToCollect == 0 then
        return false
    end

    local collected_am = 0

    for _, fruit in ipairs(allFruitsToCollect) do
        if collected_am >= _amount then
            --warn("Amoutn reached1")
            break
        end

        if Varz.IS_HATCHING then
            -- warn("HATCHING")
            break
        end
        --print("collect fruit ".. fruit.Name .. tostring(collected_am))
        --table.insert(fs_list,fruit)
        _S.collectEvent:FireServer({ fruit })
        collected_am = collected_am + 1
        task.wait()
    end
    -- all collected
    return true
end


----------------- END FRUIT Collect



---------------------------------------------------
----- FARM Stuff #farm
---------------------------------------------------

FarmManager.GetAllFarmPlantsNamesAndCount = function()
    local plants_by_category = {}
    local total_amount = 0

    -- Count plants by category + name
    for _, fruit in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        local category = _FruitCollectorMachine.GetPlantsCategoryUsingFruitName(fruit.Name) or "Uncategorised"

        if not plants_by_category[category] then
            plants_by_category[category] = {}
        end

        if not plants_by_category[category][fruit.Name] then
            plants_by_category[category][fruit.Name] = { amount = 0 }
        end

        plants_by_category[category][fruit.Name].amount = plants_by_category[category][fruit.Name].amount + 1
        total_amount = total_amount + 1
    end

    if total_amount < 800 then
        Varz.is_garden_full_seed = false
    end

    -- Build output text
    local _txt = ""
    for category, fruits in pairs(plants_by_category) do
        _txt = _txt .. "<b><font color='#00BFFF'>" .. category .. "</font></b>\n"

        -- Convert fruits to sortable array
        local fruits_array = {}
        for name, data in pairs(fruits) do
            table.insert(fruits_array, { name = name, amount = data.amount })
        end

        -- Sort descending by amount
        table.sort(fruits_array, function(a, b)
            return a.amount > b.amount
        end)

        for _, plant in ipairs(fruits_array) do
            _txt = _txt .. plant.name .. ":<font color='#FFA500'>" .. plant.amount .. "</font>\n"
        end

        _txt = _txt .. "\n"
    end

    local _newtext = "<b><font color='#00FF00'>Plants In Farm</font><font color='#FFFFFF'> x" ..
        total_amount .. "</font></b>\n\n" .. _txt

    if UI_LABELS.lbl_farm_plants_counts then
        UI_LABELS.lbl_farm_plants_counts:SetText(_newtext)
    end
end


FarmManager.DeleteObject = function(_ob)
    -- Remote
    pcall(function()
        _S.DeleteObject:FireServer(_ob)
    end)
end

FarmManager.GetObjectsUsingName = function(_name)
    local _ob = {}

    for _, item in ipairs(FarmManager.mObjects_Physical:GetChildren()) do
        if not item:IsA("Model") then
            continue
        end

        local OBJECT_TYPE = item:GetAttribute("OBJECT_TYPE")

        if not OBJECT_TYPE then
            continue
        end

        if item.Name == _name then
            table.insert(_ob, item)
            continue
        end


        if _name == OBJECT_TYPE then
            table.insert(_ob, item)
            continue
        end
    end

    return _ob
end




------------------- END FARM



-- [uuid] = {"passive" = name,"time" = 12}
Varz.cooldown_pets = {}
-- #petcooldown
_S.PetCooldownsUpdated.OnClientEvent:Connect(function(petId, cooldowns)
    if type(petId) ~= "string" or type(cooldowns) ~= "table" then
        --warn("âš ï¸ Invalid PetCooldownsUpdated payload")
        return
    end

    local _name = _Helper.PetDataLocal[petId]
    if not _name then
        -- get live pet data
        local pdata = _Helper.cache_recent_pet_data[petId]
        if not pdata then
            --warn("Got new data")
            pdata = GetPetDataByUUID(petId)
        end

        if pdata then
            local PetType = pdata.PetType
            if PetType then
                --warn("Applied name")
                _name = PetType
            else
                --warn("Fail to find pet " .. petId)
                return
            end
        end
    end

    -- Build table
    local spells = {}
    for _, data in ipairs(cooldowns) do
        local dxx = {
            Name = _name,
            Passive = tostring(data.Passive),
            Time = tonumber(data.Time) or 0
        }
        table.insert(spells, dxx)
    end

    -- Update or create entry
    Varz.cooldown_pets[petId] = spells
end)





-------------================================
------------ ShovelManager
-------------================================

ShovelManager.IsActive = false
ShovelManager.isLoaded = false

ShovelManager.UpdateStatus = function(_txt)
    if UI_LABELS.lbl_shovel_status then
        UI_LABELS.lbl_shovel_status:SetText(_txt)
    end
end


if not _G.shovelAnimState then
    _G.shovelAnimState = { frameIndex = 1, colorIndex = 1 }
end
ShovelManager.UpdateProgressInformation = function(_array)
    if not UI_LABELS.lbl_shovel_information then return end
    local maxKeep = FOtherSettings.shovel_keep_amount or 0

    -- Animated title frames (dots)
    local titleFrames = {
        "â›ï¸ Shovel Time!",
        "ðŸŒ± Digging Up Plants",
        "ðŸ€ Plant Extermination",
        "âš¡ Auto Shovelling",
        "ðŸ”¥ Clearing Fields",
        "ðŸ’¨ Rapid Dig Mode",
        "ðŸ€ Green Thumb Activated",
        "ðŸ’¥ Shovel Power!",
        "ðŸŒ¾ Harvest Cleanup",
        "ðŸ› ï¸ Working Hard"
    }
    -- Rainbow colours
    local rainbowColors = { "#ff0000", "#FFFFA2", "#FFF811", "#00ff00", "#FF68FF", "#FFFF00", "#FFC43A" }

    -- Get current animation state
    local frameIndex = _G.shovelAnimState.frameIndex
    local colorIndex = _G.shovelAnimState.colorIndex

    -- Animated title with rainbow colour
    local animatedTitle = string.format("<font color='%s'>%s</font>\n\n", rainbowColors[colorIndex],
        titleFrames[frameIndex])

    -- Update state for next call
    frameIndex = frameIndex + 1
    if frameIndex > #titleFrames then frameIndex = 1 end
    colorIndex = colorIndex + 1
    if colorIndex > #rainbowColors then colorIndex = 1 end
    _G.shovelAnimState.frameIndex = frameIndex
    _G.shovelAnimState.colorIndex = colorIndex

    -- Build plant lines
    local txtLines = {}
    for plantName, count in pairs(_array) do
        local nameColor = _Helper.StringToColor3(plantName) or "#ffffff"

        -- Determine status colour
        local statusColor
        if count < maxKeep then
            statusColor = "#ffff00" -- yellow
        elseif count == maxKeep then
            statusColor = "#00ff00" -- green
        else
            statusColor = "#ff0000" -- red
        end

        table.insert(txtLines, string.format(
            "<font color='%s'>%s:</font> <font color='%s'>%d / %d</font>",
            nameColor,
            plantName,
            statusColor,
            count,
            maxKeep
        ))
    end

    -- Combine title + plant lines
    local fullText = animatedTitle .. table.concat(txtLines, "\n")
    UI_LABELS.lbl_shovel_information:SetText(fullText)
end

ShovelManager.Plant = {

    IsCanShovelPlant = function(_fruit)
        -- Check to see if this fruit is ready for collection or is it still growing.
        if not _fruit then
            return false
        end

        local is_fav = _fruit:GetAttribute("Favorited")

        if is_fav == true then
            -- can't collect favourite fruits
            return false
        end

        local maxAge = _fruit:GetAttribute("MaxAge")

        local success, fweight = pcall(function()
            return tonumber(_fruit.Weight.Value)
        end)

        local fruit_weight = 0
        if success then
            fruit_weight = fweight
            --print("Weight:", fweight)
        else
            warn("Could not get weight:", weight) -- weight here is the error msg
            return false
        end
        local minWeight = tonumber(FOtherSettings.g_fruit_weight_min)
        local maxWeight = tonumber(FOtherSettings.g_fruit_weight_max)

        -- Check allowed weight it must be betwen min and max e.g. 1,100 and if fruit is 1 to 100 then is valid
        if fruit_weight > maxWeight or fruit_weight < minWeight then
            --warn("fruit weight out of range: " .. fruit_weight)
            return false
        end

        -- All checks passed. you may collect this fruit.
        return true
    end,

    GetMultiHarvestFruits = function(fruitsFolder)
        local fruits_list = {}
        local fruit_list = fruitsFolder:GetChildren()
        local has_fruits = false
        if fruitsFolder and #fruit_list > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruit_list) do
                -- if fav fruit found or weight not match then skip this
                if not ShovelManager.Plant.IsCanShovelPlant(fruitx) then
                    warn("Cant shovel this: " .. fruitx.Name)
                    fruits_list = {}
                    has_fruits = true
                    break
                end

                --warn("Added fruit: " .. fruitx.Name)
                table.insert(fruits_list, fruitx)
            end
        else

        end
        return fruits_list, has_fruits
    end,


    GetPlantsToDestroy = function()
        local delete_targets = {}
        for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
            if not plantModel:IsA("Model") then continue end
            if plantModel.Name and not FOtherSettings.shovel_plants_list[plantModel.Name] then continue end


            local fruitsFolder = plantModel:FindFirstChild("Fruits")

            if not fruitsFolder then
                table.insert(delete_targets, plantModel)
                --warn("No folder: " ..plantModel.Name)
                continue
            end

            local potentialFruits, has_fruits = ShovelManager.Plant.GetMultiHarvestFruits(fruitsFolder)
            if not has_fruits then
                table.insert(delete_targets, plantModel)
                -- warn("No fruits: " .. plantModel.Name)
                continue
            end
        end

        return delete_targets
    end,
    DeletePlant = function(_plantObject)
        local success, result = pcall(function()
            _S.Remove_Item:FireServer(_plantObject.PrimaryPart)
        end)

        if not success then
            warn("Failed to remove plant:", result)
        end

        return success
    end,

    GetAllAvailablePlants = function()
        local _data = {}
        for _, plant in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
            if plant:IsA("Model") then
                _data[plant.Name] = true -- store only unique names
            end
        end
        return _data
    end,
}


ShovelManager.UpdateCurrentPlantsInFarm = function()
    if not UI_Dropdown.ShovelDropDown then return end
    local plants = ShovelManager.Plant.GetAllAvailablePlants()

    if plants then
        UI_Dropdown.ShovelDropDown:SetValues(GetKeyMutListUsingDir(plants))
        UI_Dropdown.ShovelDropDown:SetValue(FOtherSettings.shovel_plants_list, true)
    end
end



------------ End ShovelManager
-------------================================








local petCache = {}


local function extractUUIDFromString(nameString)
    local uuid = string.match(nameString, "{(.-)}");
    return "{" .. uuid .. "}"
end


local function GetPetsCacheAsTable()
    local mpets = {}
    for uuid, petname in pairs(petCache) do
        table.insert(mpets, petname)
    end
    table.sort(mpets)
    return mpets
end







local function ConvertUUIDToPetNamesPairs(uuid_array)
    local pet_names = {}

    if not uuid_array then
        return pet_names
    end

    -- Loop through each UUID you want to convert
    for _, uuid in ipairs(uuid_array) do
        -- Find the full pet name associated with that UUID in the cache
        local foundName = petCache[uuid]

        if foundName then
            -- If the pet still exists, add its name to our list
            pet_names[foundName] = true;
        end
    end


    return pet_names -- Return the final list of names
end




local function GetMaxPetCapacity()
    -- Get the UI element that displays the pet count
    local titleLabel = _S.Players.LocalPlayer.PlayerGui.ActivePetUI.Frame.Main.Holder.Header.Title
    if not titleLabel then
        return 8
    end
    -- Get the text from the label (example "Active Pets: 0/8")
    local fullText = titleLabel.Text
    local maxPetsString = string.match(fullText, "/(%d+)")
    -- If a match was found, convert the captured string to a number and return it
    if maxPetsString then
        return tonumber(maxPetsString)
    end
    -- If no match was found, print a warning and return nil
    warn("Could not find the maximum pet count in the text: " .. fullText)
    return 8 -- default
end


























------------- MUTATION Machine
MutationMachineManager.TEXT_STATUS = ""
MutationMachineManager.UI = {
    GetText_LevelingTeam = function()
        local current_selected = #FOtherSettings.mut_support_team
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FFD700"><b>â­ Leveling Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,
    -- team that will be leveled
    GetText_TargetTeam = function()
        local current_selected = #FOtherSettings.mut_target_pets_uuid
        local max_allowed = 99

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#00BFFF"><b>ðŸ§ª Target Pets</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_TeamCooldown = function()
        local current_selected = #FOtherSettings.mut_mutation_machineteam
        local max_allowed = GetMaxPetCapacity()

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FFB700"><b>â³ Cooldown Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_TeamClaimPet = function()
        local current_selected = #FOtherSettings.mut_claimpet_team
        local max_allowed = GetMaxPetCapacity()

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#27F542"><b>âœ¨ Pet Claim Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_MutationList = function()
        local current_selected = 0
        for _, _ in pairs(FOtherSettings.mut_target_mutations) do
            current_selected = current_selected + 1
        end
        local get_lis = GetKeyMutListUsingDir(MutationMachineManager.AllMutationsList)
        local max_allowed = #get_lis
        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FF009F"><b>ðŸ§¬ Wanted Mutations</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    UpdateInformation = function()

    end,
    UpdateStats = function(_txt)
        if UI_LABELS.lbl_mutation_machine_status then
            UI_LABELS.lbl_mutation_machine_status:SetText(_txt)
        end
        MutationMachineManager.TEXT_STATUS = _txt
    end,

    UpdateTeamsDropdowns = function()
        if not UI_Dropdown.dropdown_support_team or not UI_Dropdown.dropdown_target_team or not UI_Dropdown.dropdown_mut_cd_team or not UI_Dropdown.dropdown_claimpet_team then
            return false
        end

        local cache_data = GetPetsCacheAsTable()


        UI_Dropdown.dropdown_support_team:SetValues(cache_data)
        UI_Dropdown.dropdown_target_team:SetValues(cache_data)
        UI_Dropdown.dropdown_mut_cd_team:SetValues(cache_data)
        UI_Dropdown.dropdown_claimpet_team:SetValues(cache_data)

        local surpassCallback = true
        UI_Dropdown.dropdown_support_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings.mut_support_team),
            surpassCallback)
        UI_Dropdown.dropdown_target_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings.mut_target_pets_uuid),
            surpassCallback)
        UI_Dropdown.dropdown_mut_cd_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings.mut_mutation_machineteam),
            surpassCallback)
        UI_Dropdown.dropdown_claimpet_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings.mut_claimpet_team),
            surpassCallback)
    end,


}


MutationMachineManager.SubmitHeldPet = function()
    local success, err = pcall(function()
        _S.MutationService:FireServer("SubmitHeldPet")
    end)

    if err then
        warn(err)
    end
    return success
end


MutationMachineManager.ClaimMutatedPet = function()
    local success, err = pcall(function()
        _S.MutationService:FireServer("ClaimMutatedPet")
    end)

    if err then
        warn(err)
    end
    return success
end

MutationMachineManager.StartMachine = function()
    local success, err = pcall(function()
        _S.MutationService:FireServer("StartMachine")
    end)

    if err then
        warn(err)
    end
    return success
end

MutationMachineManager.CancelMachine = function()
    local success, err = pcall(function()
        _S.MutationService:FireServer("CancelMachine")
    end)

    if err then
        warn(err)
    end
    return success
end


MutationMachineManager.InsertPetBackIntoTargetList = function(_uuid)
    if not _uuid or _uuid == "" then
        return false
    end
    for _, value in ipairs(FOtherSettings.mut_target_pets_uuid) do
        if value == _uuid then
            -- already in list
            return false
        end
    end

    table.insert(FOtherSettings.mut_target_pets_uuid, _uuid)
    SaveDataOther()
    return true
end

MutationMachineManager.IsAllowedTargetTeamPet = function(_uuid)
    local restrictedTeams = {
        FOtherSettings.mut_mutation_machineteam,
        FOtherSettings.mut_support_team,
        FOtherSettings.mut_claimpet_team
    }

    --warn("Check uuid: " .. _uuid)

    for _, team in ipairs(restrictedTeams) do
        for _, value in ipairs(team) do
            --print("Check ".. value .. " With ".. _uuid)
            if value == _uuid then
                return false
            end
        end
    end

    return true
end


MutationMachineManager.MakeLevelingTeam = function(pet_level_require_array)
    local pet_array          = {}
    local total_added        = 0
    local support_team_count = #FOtherSettings.mut_support_team
    local findpetforlevel    = pet_level_require_array
    local howmanypets_canadd = GetMaxPetCapacity() - support_team_count
    if howmanypets_canadd > 0 then
        -- add all support, since we can
        for _, t1 in ipairs(FOtherSettings.mut_support_team) do
            table.insert(pet_array, t1)
            total_added = total_added + 1
        end
        local max_petssp = GetMaxPetCapacity()
        for _, t2 in ipairs(findpetforlevel) do
            if total_added >= max_petssp then
                break
            end
            table.insert(pet_array, t2)
            total_added = total_added + 1
        end
    end
    return pet_array
end

MutationMachineManager.GetAvailablePetsForLeveling = function()
    -- check users selected pets and see if we can find any ready for leveling
    local tbl_pets = {}
    for _, _uuid in ipairs(FOtherSettings.mut_target_pets_uuid) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local UUID = _petData.UUID
        local PetData = _petData.PetData

        local PetType = _petData.PetType -- name of the name
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- local _txt = string.format("Pet %s has mutation: %s" ,PetType ,CurrentMutationOnPet)
        -- warn(_txt)

        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                --warn(_txt1)
            else
                if Level >= FOtherSettings.mut_required_level then
                    -- warn("Pet already pet level requirement.")
                else
                    table.insert(tbl_pets, _uuid)
                end
            end
        end
    end
    return tbl_pets
end



MutationMachineManager.GetHasPetsReachedMaxLevelMutationGoal = function(_array_uuids)
    -- Check if any of the pets in this list reached max level
    if not _array_uuids then return false end
    local anyreached_max = false
    for _, _uuid in ipairs(_array_uuids) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local UUID = _petData.UUID
        local PetData = _petData.PetData

        local PetType = _petData.PetType -- name of the name
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                if Level >= 100 then
                    -- send webhook if success max levels
                    local dxx = {
                        PetType = PetType,
                        MutationType = MutationType,
                        Name = Name,
                        Level = Level,
                    }
                    table.insert(MutationMachineManager.MaxLevelReachedWantedPets_webhook, dxx)
                    anyreached_max = true
                end
            end
        end
    end
    return anyreached_max
end

MutationMachineManager.GetPetsToMaxLevelMetMutationGoal = function()
    -- Get all the pets that require leveling to level 100
    local tbl_pets = {}
    for _, _uuid in ipairs(FOtherSettings.mut_target_pets_uuid) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local PetData = _petData.PetData
        local Level = PetData.Level
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                if Level < 100 then
                    -- pet is not level 100, add to the list
                    table.insert(tbl_pets, _uuid)
                end
            end
        end
    end
    return tbl_pets
end




MutationMachineManager.GetPetsReachedMutationLevelRequirement = function(_array_pets)
    -- any pets reached required level should be not be on the map anymore

    local tbl_pets = {}
    for _, _uuid in ipairs(_array_pets) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local PetData = _petData.PetData
        local Level = PetData.Level
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                continue
            end
        end

        if Level >= FOtherSettings.mut_required_level then
            -- this has reached the requirement
            table.insert(tbl_pets, _uuid)
        end
    end
    return tbl_pets
end



MutationMachineManager.GetPetsNotReadyForSubmit = function()
    -- check users selected pets and see if we can find any ready for leveling
    local tbl_pets = {}
    local tbl_names = {}
    for _, _uuid in ipairs(FOtherSettings.mut_target_pets_uuid) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local PetData = _petData.PetData
        local Level = PetData.Level
        local MutationType = PetData.MutationType
        local Name = PetData.Name
        local color_n = "#E62500"

        if Level >= FOtherSettings.mut_required_level then
            color_n = "#00D61A"
        end

        local _str = string.format("%s Lv.(<font color='%s'>%s</font>/%s)", Name, color_n, Level,
            FOtherSettings.mut_required_level)

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- local _txt = string.format("Pet %s has mutation: %s" ,PetType ,CurrentMutationOnPet)
        -- warn(_txt)

        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                --warn(_txt1)
            else
                if Level < FOtherSettings.mut_required_level then
                    table.insert(tbl_pets, _uuid)
                    table.insert(tbl_names, _str)
                end
            end
        end
    end
    return tbl_pets, tbl_names
end


MutationMachineManager.GetPetsReadyForSubmit = function()
    -- check users selected pets and see if we can find any ready for leveling
    local tbl_pets = {}
    for _, _uuid in ipairs(FOtherSettings.mut_target_pets_uuid) do
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            --warn("Error getting pet data:: -> ", _uuid)
            continue
        end
        local UUID = _petData.UUID
        local PetData = _petData.PetData

        local PetType = _petData.PetType -- name of the name
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
        -- local _txt = string.format("Pet %s has mutation: %s" ,PetType ,CurrentMutationOnPet)
        -- warn(_txt)

        -- check if this pet has already matched the required mutation
        if next(FOtherSettings.mut_target_mutations) ~= nil then
            if FOtherSettings.mut_target_mutations[CurrentMutationOnPet] then
                --local _txt1 = string.format("### Pet %s already has mutation: %s" ,PetType ,CurrentMutationOnPet)
                --warn(_txt1)
            else
                if Level >= FOtherSettings.mut_required_level then
                    table.insert(tbl_pets, _uuid)
                end
            end
        end
    end
    return tbl_pets
end




MutationMachineManager.Status = {
    STATE_LEVEL = "STATE_LEVEL",
    START_MUTATION = "START_MUTATION",
    SKIP = "SKIP",
    CLAIM_PET = "CLAIM_PET",
    SUBMIT_PET = "SUBMIT_PET",
    TURN_LEVEL = "levelteam",
    TURN_CD = "cooldownteam",
}


MutationMachineManager.SetNewTurn = function(_turn)
    FOtherSettings.mut_batch_process_turn = _turn
    SaveDataOther()
end

MutationMachineManager.GetCurrentTurn = function()
    local default = MutationMachineManager.Status.TURN_LEVEL
    local savedTurn = (FOtherSettings and FOtherSettings.mut_batch_process_turn) or default

    -- Validate savedTurn against allowed values
    local validTurns = {
        [MutationMachineManager.Status.TURN_LEVEL] = true,
        [MutationMachineManager.Status.TURN_CD] = true,
    }

    if not validTurns[savedTurn] then
        savedTurn = default
    end

    return savedTurn
end



MutationMachineManager.GetCurrentStatus = function()
    local prompt = _S.Workspace.NPCS.PetMutationMachine.Model.ProxPromptPart.PetMutationMachineProximityPrompt
    local current_status = MutationMachineManager.Status.SUBMIT_PET

    if prompt and prompt:IsA("ProximityPrompt") and prompt.ActionText then
        local txt = prompt.ActionText

        if string.find(txt, "Start Mutation", 1, true) then
            --warn("--->>> Start Crafting")
            current_status = MutationMachineManager.Status.START_MUTATION
        elseif string.find(txt, "Claim Pet", 1, true) then
            --warn("--->>> Claim Rewards")
            current_status = MutationMachineManager.Status.CLAIM_PET
        elseif string.find(txt, "Submit Pet", 1, true) then
            --warn("--->>> Submit Item")
            current_status = MutationMachineManager.Status.SUBMIT_PET
        elseif string.find(txt, "Skip", 1, true) then
            --warn("--->>> Skip Craft")
            current_status = MutationMachineManager.Status.SKIP
        end

        --print("ActionText:", txt)
    else
        --warn("No valid PetMutationMachineProximityPrompt found.")
    end

    return current_status
end





------ END mutation machine






-- #petmut
--=================== Pet Mutatuion
PetMutation.SentWebHookMaxLevelTrack = {}
PetMutation.SentWebHookMutationTrack = {}
PetMutation.SentWebHookMutationWeightTrack = {}
PetMutation.State = {
    idle = "idle",
    mutation = "mutation",
    baseweight = "baseweight",
    level = "level",
    max_level = "max_level",
}

PetMutation.mut_ui = {
    UpdateStats = function(_txt)
        if UI_LABELS.lbl_pet_mutation_status then
            UI_LABELS.lbl_pet_mutation_status:SetText(_txt)
        end
        MutationMachineManager.TEXT_STATUS = _txt
    end,

    GetText_TargetTeam = function()
        local current_selected = #FSettings.mut_system.targetteam
        local max_allowed = 99

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#00BFFF"><b>ðŸ§  Target Pets</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_MaxLevelTeam = function()
        local current_selected = #FSettings.mut_system.maxlevel_team
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#00FF3C"><b>âœ¨ Max Leveling Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_XpTeam = function()
        local current_selected = #FSettings.mut_system.xpteam
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FFD700"><b>ðŸŽ–ï¸ XP Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_FillerTeam = function()
        local current_selected = #FSettings.mut_system.filler_team
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FFD700"><b>ðŸ”· Filler Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,


    GetText_PetMutation = function()
        local current_selected = #FSettings.mut_system.mut_team
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FF00F1"><b>ðŸŽ Horseman Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    GetText_PetBaseWeightTeam = function()
        local current_selected = #FSettings.mut_system.baseweight_team
        local max_allowed = GetMaxPetCapacity() - 1

        local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

        local txt = string.format(
            '<font color="#FAFF3D"><b>ðŸ˜ Elephant Team</b></font> ' ..
            '<font color="#DDDDDD">[</font>' ..
            '<font color="%s"><b>%d</b></font>' ..
            '<font color="#FFFFFF">/</font>' ..
            '<font color="#DDDDDD"><b>%d</b></font>' ..
            '<font color="#DDDDDD">]</font>',
            ratio_colour,
            current_selected,
            max_allowed
        )

        return txt
    end,

    UpdateTeamsDropdowns = function()
        if not UI_Dropdown.dropdown_petmutation_maxlevelteam or not UI_Dropdown.dropdown_petmut_xpteam or not UI_Dropdown.dropdown_pettargetteam or not UI_Dropdown.dropdown_petmutationteam or not UI_Dropdown.dropdown_petbaseweightteam or not UI_Dropdown.dropdown_petfiller_team then
            return false
        end

        local cache_data = GetPetsCacheAsTable()

        UI_Dropdown.dropdown_petmutation_maxlevelteam:SetValues(cache_data)
        UI_Dropdown.dropdown_petmut_xpteam:SetValues(cache_data)
        UI_Dropdown.dropdown_pettargetteam:SetValues(cache_data)
        UI_Dropdown.dropdown_petmutationteam:SetValues(cache_data)
        UI_Dropdown.dropdown_petbaseweightteam:SetValues(cache_data)
        UI_Dropdown.dropdown_petfiller_team:SetValues(cache_data)

        local surpassCallback = true
        UI_Dropdown.dropdown_petmutation_maxlevelteam:SetValue(
            ConvertUUIDToPetNamesPairs(FSettings.mut_system.maxlevel_team),
            surpassCallback)
        UI_Dropdown.dropdown_petmut_xpteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.xpteam),
            surpassCallback)
        UI_Dropdown.dropdown_pettargetteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.targetteam),
            surpassCallback)
        UI_Dropdown.dropdown_petmutationteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.mut_team),
            surpassCallback)
        UI_Dropdown.dropdown_petbaseweightteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.baseweight_team),
            surpassCallback)

        UI_Dropdown.dropdown_petfiller_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.filler_team),
            surpassCallback)
    end,
}

PetMutation.mut = {
    is_running = false,

    IsAllowedPet = function(_uuid)
        local restrictedTeams = {
            FSettings.mut_system.xpteam,
            FSettings.mut_system.mut_team,
            FSettings.mut_system.maxlevel_team,
            FSettings.mut_system.baseweight_team,
            FSettings.mut_system.filler_team,
        }

        for _, team in ipairs(restrictedTeams) do
            for _, value in ipairs(team) do
                if value == _uuid then
                    return false
                end
            end
        end

        return true
    end,

    IsNotInTargetTeamPet = function(_uuid)
        local restrictedTeams = {
            FSettings.mut_system.targetteam
        }

        for _, team in ipairs(restrictedTeams) do
            for _, value in ipairs(team) do
                if value == _uuid then
                    return false
                end
            end
        end

        return true
    end,

    GetPetsNotReachedWantedMut = function(array_pets, _flag)
        -- scan the farm.
        local tbl_pets = {}
        local require_weight = tonumber(FSettings.mut_system.required_weight) or 2.10
        local require_weight_level = tonumber(FSettings.mut_system.lvl_baseweight) or 40
        local require_lvl = tonumber(FSettings.mut_system.level) or 40
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode

        for _, _uuid in ipairs(array_pets) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end
            local PetData = _petData.PetData
            local Level = PetData.Level
            local MutationType = PetData.MutationType or ""
            local BaseWeight = PetData.BaseWeight
            local has_mut = false
            local has_baseweight = false
            local real_weight = GetRealPetWeight(BaseWeight, 1)
            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""
            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                has_mut = true
            end

            if real_weight >= require_weight then
                has_baseweight = true
            end

            -- === check ===
            if _flag == "mut" then
                -- Fail if does not have mutation and less is less than required level for this pet.
                if not has_mut and Level < require_lvl then
                    table.insert(tbl_pets, _uuid)
                end
            elseif _flag == "weight" then
                -- This fails if the we have not reached base weight and level is less than required
                if not has_baseweight and Level < require_weight_level then
                    table.insert(tbl_pets, _uuid)
                end
            end
        end
        return tbl_pets
    end,

    SwapPetsMutation = function()

    end,

    HasPetsReachedRequiredMutations_OnFarm = function(array_pets, petsAdded, _flag)
        -- scan the farm.
        local tbl_pets = {}
        local tbl_names = {}
        local baseweight_max = tonumber(FSettings.mut_system.required_weight) or 2.10
        local required_lvl = tonumber(FSettings.mut_system.lvl_baseweight) or 40

        local maxlevel_mutation = FSettings.mut_system.level or 40

        for _, _uuid in ipairs(array_pets) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end

            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name

            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            local mx = {
                PetType = PetType,
                MutationType = MutationType,
                Name = Name,
                Level = Level,
                Weight = real_weight,
                IsWeight = false
            }

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or "N/A"
            local ranMutList = {}

            local has_reached_weight = false
            if real_weight >= baseweight_max then
                has_reached_weight = true
            end

            local wanted_mut = FSettings.mut_system.wanted

            for _mut, _ in pairs(wanted_mut) do
                table.insert(ranMutList, _mut)
            end

            local ranMut = table.concat(ranMutList, ", ")

            local color_n = "#E62500"

            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                color_n = "#00D61A"
            end
            local display_current_effect = CurrentMutationOnPet
            local required_effect = ranMut

            local display_name = string.format("%s (%s)", _Helper.ShortName(PetType), Name)

            -- we need to apply different display if we are in weight stage
            -- override
            if _flag == "weight" then
                if not has_reached_weight then
                    color_n = "#E62500"
                else
                    color_n = "#00D61A"
                end
                display_current_effect = string.format("%.2f KG", real_weight)
                required_effect = string.format("%.2f KG", baseweight_max)
            end

            local _str = string.format("%s Mut.(<font color='%s'>%s</font>/%s)", display_name, color_n,
                display_current_effect,
                required_effect)

            if petsAdded[_uuid] then
                _str = string.format("<font color='#00C745'>%s</font> Mut.(<font color='%s'>%s</font>/%s)", display_name,
                    color_n,
                    display_current_effect,
                    required_effect)
            end
            table.insert(tbl_names, _str)

            if not petsAdded[_uuid] then
                continue
            end

            if _flag == "mut" then
                if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                    table.insert(tbl_pets, _uuid)
                    if not PetMutation.SentWebHookMutationWeightTrack[_uuid] then
                        table.insert(MutationTableWebhook, mx)
                        PetMutation.SentWebHookMutationWeightTrack[_uuid] = true
                    end
                end
                continue
            end

            if _flag == "weight" then
                -- check if pet has reached maximum weight or check if pet is less than required level
                if real_weight >= baseweight_max then
                    -- this unit has successfully reached maximum baseweight
                    mx.IsWeight = true
                    table.insert(tbl_pets, _uuid)
                    if not PetMutation.SentWebHookMutationTrack[_uuid] then
                        table.insert(MutationTableWebhook, mx)
                        PetMutation.SentWebHookMutationTrack[_uuid] = true
                    end
                end
                continue
            end
        end
        return tbl_pets, tbl_names
    end,

    HasPetReachedMaxLevel = function(array_pets, petsAdded, is_turbo_maxed)
        -- scan the farm.
        local tbl_pets = {}
        local tbl_names = {}
        local is_base_weight_mode = FSettings.mut_system.is_baseweight_mode or false

        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams
        local turbo_minimum_level = tonumber(FSettings.mut_system.turbo_max_level) or 25
        local max_lvl = tonumber(FSettings.mut_system.custom_max_level) or 100
        local only_level_mode = FSettings.mut_system.only_level_mode

        for _, _uuid in ipairs(array_pets) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end

            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility

            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            local IsFavorite = PetData.IsFavorite
            local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            local mx = {
                PetType = PetType,
                MutationType = MutationType,
                Name = Name,
                Level = Level,
            }


            local color_n = "#E62500"

            if Level >= max_lvl then
                color_n = "#00D61A"
            end
            local require_lvlx = max_lvl
            local is_active = false

            local basew_display = ""
            if is_base_weight_mode then
                basew_display = string.format("<font color='#FF00FF'>[%.2f KG]</font>", real_weight)
            end

            local display_name = string.format("%s (%s)", _Helper.ShortName(PetType), Name)

            local _str = string.format("%s Lv.(<font color='%s'>%s</font>/%s) %s", display_name, color_n, Level,
                require_lvlx,
                basew_display)

            if petsAdded[_uuid] then
                _str = string.format("<font color='#00C745'>%s</font> Lv.(<font color='%s'>%s</font>/%s) %s",
                    display_name,
                    color_n,
                    Level, require_lvlx, basew_display)
                is_active = true
            end

            local md = {
                isActive = is_active,
                text = _str
            }

            table.insert(tbl_names, md)

            if not petsAdded[_uuid] then
                -- only check added units
                continue
            end

            if only_level_mode then
                if Level >= max_lvl then
                    table.insert(tbl_pets, _uuid)
                    if not PetMutation.SentWebHookMaxLevelTrack[_uuid] then
                        table.insert(MutationMachineManager.MaxLevelReachedWantedPets_webhook, mx)
                        PetMutation.SentWebHookMaxLevelTrack[_uuid] = true
                    end
                end
                continue
            end

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]


            if is_turbo_mode and not is_turbo_maxed and Level < max_lvl then
                if Level >= turbo_minimum_level then
                    is_turbo_maxed = true
                    table.insert(tbl_pets, _uuid)
                end
            else
                if Level >= max_lvl then
                    table.insert(tbl_pets, _uuid)
                    if not PetMutation.SentWebHookMaxLevelTrack[_uuid] then
                        table.insert(MutationMachineManager.MaxLevelReachedWantedPets_webhook, mx)
                        PetMutation.SentWebHookMaxLevelTrack[_uuid] = true
                    end
                end
            end
        end

        -- sort the table names it has md = { isActive = is_active,text = _str}
        local new_names_array = {}

        -- 1. add active
        for _, md in ipairs(tbl_names) do
            if md.isActive then
                table.insert(new_names_array, md.text)
            end
        end

        -- 2. add others
        for _, md in ipairs(tbl_names) do
            if not md.isActive then
                table.insert(new_names_array, md.text)
            end
        end


        return tbl_pets, new_names_array, is_turbo_maxed
    end,


    HasPetReachedRequiredLevel = function(array_pets, petsAdded, isMaxLevelPlaced)
        -- scan the farm.
        local tbl_pets = {}
        local tbl_names = {}
        local require_lvl = tonumber(FSettings.mut_system.level) or 40
        local bw_lvl = tonumber(FSettings.mut_system.lvl_baseweight) or 40
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode
        local required_weight = tonumber(FSettings.mut_system.required_weight) or 2.10


        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams
        local turbo_minimum_level = tonumber(FSettings.mut_system.turbo_max_level) or 25
        local was_trubo_mode_reached = false

        local mut_team_ls = FSettings.mut_system.mut_team or {}

        local bypassmut = false
        if is_weight_mode and #mut_team_ls == 0 then
            bypassmut = true
        end

        for _, _uuid in ipairs(array_pets) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end

            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility


            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            local IsFavorite = PetData.IsFavorite
            local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""
            local real_weight = GetRealPetWeight(BaseWeight, 1)


            local is_mut = false
            local has_reached_baseweight = false
            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""

            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                is_mut = true
            end

            -- bypass mut
            if bypassmut then
                is_mut = true
            end

            if real_weight >= required_weight then
                has_reached_baseweight = true
            end


            local color_n = "#E62500"
            local new_required_level = require_lvl

            if is_weight_mode and is_mut then
                new_required_level = bw_lvl
            end

            if Level >= new_required_level then
                color_n = "#00D61A"
            end

            local bw_display = ""
            if is_weight_mode then
                bw_display = string.format("<font color='#FF00FF'>[%.2f KG]</font>", real_weight)
            end

            local display_name = string.format("%s (%s)", _Helper.ShortName(PetType), Name)

            local _str = string.format("%s Lv.(<font color='%s'>%s</font>/%s) %s", display_name, color_n, Level,
                new_required_level, bw_display)
            if petsAdded[_uuid] then
                _str = string.format("<font color='#00C745'>%s</font> Lv.(<font color='%s'>%s</font>/%s) %s",
                    display_name,
                    color_n,
                    Level, new_required_level, bw_display)
            end

            table.insert(tbl_names, _str)

            -- only checking pets that are added on the field
            if not petsAdded[_uuid] then
                --warn("Pet not added")
                continue
            end


            if not is_mut then
                if Level >= require_lvl then
                    table.insert(tbl_pets, _uuid)
                    continue
                end
            end

            -- Base Weight level check
            if is_weight_mode and not has_reached_baseweight then
                -- Level matchs
                if Level >= bw_lvl then
                    table.insert(tbl_pets, _uuid)
                    continue
                end
            end

            -- IF mode where we switch teams based on level requirements
            if is_turbo_mode then
                -- warn("Turbo mode")
                if not isMaxLevelPlaced then
                    -- warn("MAx team is not placed")
                    -- if max level team is not placed.
                    if Level >= turbo_minimum_level then
                        table.insert(tbl_pets, _uuid)
                        was_trubo_mode_reached = true
                    end
                else
                    --warn("MAx team already placed")
                end
            end
        end

        return tbl_pets, tbl_names, was_trubo_mode_reached
    end,

    DoesPetNeedToBeCleaned = function(_uuid)
        local _petData = GetPetDataByUUID(_uuid)
        if not _petData then
            return true
        end
        local UUID = _petData.UUID
        local PetData = _petData.PetData

        local PetType = _petData.PetType -- name of the name
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight
        local MutationType = PetData.MutationType

        -- like k = IronSkin, c = Rainbow etc
        local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]

        if not CurrentMutationOnPet then
            --warn("Pet not have any mutations, so doont need to clean. " .. Name)
            return false
        end

        if not FSettings.mut_system.wanted[CurrentMutationOnPet] then
            return true
        end

        return false
    end,

    ApplyPetCleaningShard = function(model)
        -- Remote
        local PetShardService_RE = _S.GameEvents.PetShardService_RE -- RemoteEvent
        PetShardService_RE:FireServer("ApplyShard", model)
    end,

    CleanPet = function(array_pets)
        -- Cleans a pet if has none of required mutation.
        local wl = {}
        for _, uid in ipairs(array_pets) do
            wl[uid] = true
        end
        local active_pets = FarmManager.GetActivePetsParts()

        for _, part in ipairs(active_pets) do
            local UUID = part:GetAttribute("UUID")
            if wl[UUID] then
                -- check if this pet needs a clean
                if PetMutation.mut.DoesPetNeedToBeCleaned(UUID) then
                    --warn("This pet needs a clean")

                    local _tool = InventoryManager.GetCleansingPetShard()
                    if not _tool then
                        -- user has none of this
                        break
                    end

                    unequipTools()
                    task.wait(0.2)
                    if EquipToolOnChar(_tool) then
                        for _, Ins in ipairs(part:GetChildren()) do
                            if Ins:IsA("Model") then
                                PetMutation.mut.ApplyPetCleaningShard(Ins)
                                task.wait(1.2)
                                unequipTools()
                                break
                            end
                        end
                    end
                else
                    --warn("This pet is safe, dont neeed clean")
                end
            end
        end
    end,

    AddedTeamGetLevelChecks = function(array_uuids)
        local pets_ls = {}
        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams
        local turbo_minimum_level = tonumber(FSettings.mut_system.turbo_max_level) or 25

        local require_lvl = tonumber(FSettings.mut_system.level)
        local bw_lvl = tonumber(FSettings.mut_system.lvl_baseweight)
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode
        local required_weight = tonumber(FSettings.mut_system.required_weight) or 2.10

        for _, uuid in ipairs(array_uuids) do
            local _petData = GetPetDataByUUID(uuid)
            if not _petData then
                continue
            end

            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility


            local Name = PetData.Name
            local Level = PetData.Level
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
            local has_mut = false
            local has_base_weight = false
            local has_base_weight_required_level = false

            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                has_mut = true
            end

            if real_weight >= required_weight then
                has_base_weight = true
            end

            if Level >= bw_lvl then
                has_base_weight_required_level = true
            end

            if has_mut and not is_weight_mode then
                continue
            end

            if has_mut and has_base_weight then
                continue
            end

            if is_weight_mode then
                if has_base_weight_required_level then
                    continue
                end
            end



            if is_turbo_mode then
                if Level < turbo_minimum_level then
                    table.insert(pets_ls, uuid)
                end
            end
        end

        return pets_ls
    end,

    HasPetMetLevelRequirements = function(pet_data)

    end,

    FindTeamToUse = function(array_uuids)
        local pets_ls = {}
        local pets_under_level = {}
        local pets_over_level = {}

        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams
        local turbo_minimum_level = tonumber(FSettings.mut_system.turbo_max_level) or 25

        local require_lvl = tonumber(FSettings.mut_system.level)
        local bw_lvl = tonumber(FSettings.mut_system.lvl_baseweight)
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode
        local required_weight = tonumber(FSettings.mut_system.required_weight) or 2.10

        for _, uuid in ipairs(array_uuids) do
            local _petData = GetPetDataByUUID(uuid)
            if not _petData then
                continue
            end
            local PetData = _petData.PetData
            local PetType = _petData.PetType -- name of the name

            local Name = PetData.Name
            local Level = PetData.Level
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            -- like k = IronSkin, c = Rainbow etc
            --local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
            -- lets check.
            if Level < turbo_minimum_level then
                table.insert(pets_under_level, uuid)
            else
                table.insert(pets_over_level, uuid)
            end

            table.insert(pets_ls, uuid)
        end

        return pets_under_level, pets_over_level, pets_ls
    end,

    PetPetIntoATeam = function(team, pets)
        local howmanypets_canadd = GetMaxPetCapacity() - #team
        local total_added        = 0
        local added_pets         = {}
        local pet_array          = {}
        local is_single_mode     = FSettings.mut_system.single_unit_allowed
        local max_petssp         = GetMaxPetCapacity()
        local fill_team          = FSettings.mut_system.filler_team or {}
        local fill_team_count    = #fill_team

        -- This has all pets we added, used for filler team to make sure we don't add the same pet
        local all_added_checker  = {}

        if howmanypets_canadd > 0 then
            -- add all support
            for _, t1 in ipairs(team) do
                table.insert(pet_array, t1)
                all_added_checker[t1] = true
                total_added = total_added + 1
            end
            local add_count_x = 0
            for _, t2 in ipairs(pets) do
                if total_added >= max_petssp then
                    break
                end

                if is_single_mode then
                    if add_count_x == 1 then
                        break
                    end
                end

                table.insert(pet_array, t2)
                added_pets[t2] = true
                all_added_checker[t2] = true
                total_added = total_added + 1
                add_count_x = add_count_x + 1
            end
        end

        -- Fill any missing pets
        if #pet_array < max_petssp and fill_team_count > 0 then
            -- try to use filler team
            for _, uuid in ipairs(fill_team) do
                if all_added_checker[uuid] then
                    continue
                end
                if is_single_mode then break end
                local pd = GetPetDataByUUID(uuid)
                if not pd then continue end
                table.insert(pet_array, uuid)
                total_added = total_added + 1

                if total_added >= max_petssp then
                    break
                end
            end
        end

        return pet_array, added_pets
    end,

    AdvancedTeamMaker = function(pet_array, caller_maxlevel)
        local is_xpteam = false
        local is_maxlevel_team = false

        local normal_xp_team = _Helper.CloneArray(FSettings.mut_system.xpteam)
        local max_level_team = _Helper.CloneArray(FSettings.mut_system.maxlevel_team)
        local team_switch_mode = FSettings.mut_system.turbo_xp_teams
        local petstoplace = {}
        local added_pets = {}

        if team_switch_mode then
            -- we must find out what team we need to use for these pets
            local pets_under_mini, pets_over, allpets = PetMutation.mut.FindTeamToUse(pet_array)
            -- if we have any pets under minimum level then we must use xp team
            if #pets_under_mini > 0 then
                is_xpteam = true
                local pets, added = PetMutation.mut.PetPetIntoATeam(normal_xp_team, pets_under_mini)
                petstoplace = pets
                added_pets = added
            elseif #pets_over > 0 then
                is_maxlevel_team = true
                local pets, added = PetMutation.mut.PetPetIntoATeam(max_level_team, pets_over)
                petstoplace = pets
                added_pets = added
            end
        else
            local pets_under_mini, pets_over, allpets = PetMutation.mut.FindTeamToUse(pet_array)
            -- here we don't seprate based on level. just use any

            if caller_maxlevel then
                local pets, added = PetMutation.mut.PetPetIntoATeam(max_level_team, allpets)
                petstoplace = pets
                added_pets = added
                is_maxlevel_team = true
            else
                local pets, added = PetMutation.mut.PetPetIntoATeam(normal_xp_team, allpets)
                petstoplace = pets
                added_pets = added
                is_xpteam = true
            end
        end

        return petstoplace, added_pets, is_maxlevel_team
    end,


    SmartGenTeam_MaxLevel = function(pet_level_require_array, is_max_level_caller)
        local pet_array                 = {}
        local added_pets                = {}
        local is_turbo_mode             = FSettings.mut_system.turbo_xp_teams

        local max_petssp                = GetMaxPetCapacity()
        local is_max_level_team_placed  = false
        local is_require_max_level_team = false

        -- === Turbo mode
        if is_turbo_mode then
            -- if turbo mode is enabled we must check pet levels and only allow pets over the minimum level to use leveling team else use xp team
            -- check if we have any pets that actually require xp team
            local pets_require_xp_team = PetMutation.mut.AddedTeamGetLevelChecks(pet_level_require_array)
            warn("Turbo mode " .. #pets_require_xp_team)
            if #pets_require_xp_team > 0 then
                -- yes we have pets that can use xp team to boost
                local added_turbo_count = 0
                for _, t1 in ipairs(FSettings.mut_system.xpteam) do
                    table.insert(pet_array, t1)
                    added_turbo_count = added_turbo_count + 1
                end

                -- make sure we can add more pets
                if added_turbo_count < max_petssp then
                    for _, uuid in ipairs(pets_require_xp_team) do
                        table.insert(pet_array, uuid)
                        added_pets[uuid] = true
                        added_turbo_count = added_turbo_count + 1

                        if added_turbo_count >= max_petssp then
                            break
                        end

                        if FSettings.mut_system.single_unit_allowed then
                            -- in this mode we only allowed to add one unit
                            break
                        end
                    end
                end
            else
                warn("Not found any pets under minimum level")
                is_require_max_level_team = true
            end

            if #pet_array > 0 then
                -- we are done here, found all required teams.
                is_max_level_team_placed = true
                return pet_array, added_pets, is_max_level_team_placed
            end
        end

        -- warn("Using normal mode")

        local maxlevel_team = {}

        if is_max_level_caller then
            -- warn("MAxlevel called")
            maxlevel_team = _Helper.CloneArray(FSettings.mut_system.maxlevel_team)
            if #maxlevel_team == 0 then
                -- warn("missing max level team ")
                is_max_level_team_placed = false
                maxlevel_team = _Helper.CloneArray(FSettings.mut_system.xpteam)
            else
                is_max_level_team_placed = true
            end
        else
            maxlevel_team = _Helper.CloneArray(FSettings.mut_system.xpteam)
            if #maxlevel_team == 0 then
                is_max_level_team_placed = true
                maxlevel_team = _Helper.CloneArray(FSettings.mut_system.maxlevel_team)
            else
                is_max_level_team_placed = false
            end
        end

        if is_require_max_level_team then
            maxlevel_team = _Helper.CloneArray(FSettings.mut_system.maxlevel_team)
            if #maxlevel_team == 0 then
                is_max_level_team_placed = false
                maxlevel_team = _Helper.CloneArray(FSettings.mut_system.xpteam)
            else
                is_max_level_team_placed = true
            end
        end


        local howmanypets_canadd = GetMaxPetCapacity() - #maxlevel_team
        local total_added        = 0


        -- Normal mode
        if howmanypets_canadd > 0 then
            -- add all support, since we can
            for _, t1 in ipairs(maxlevel_team) do
                table.insert(pet_array, t1)
                total_added = total_added + 1
            end
            local add_count_x = 0
            for _, t2 in ipairs(pet_level_require_array) do
                if total_added >= max_petssp then
                    break
                end

                if FSettings.mut_system.single_unit_allowed then
                    if add_count_x == 1 then
                        break
                    end
                end

                table.insert(pet_array, t2)
                added_pets[t2] = true
                total_added = total_added + 1
                add_count_x = add_count_x + 1
            end
        end
        return pet_array, added_pets, is_max_level_team_placed
    end,
    GenTeam = function(support_team, pet_level_require_array)
        local pet_array          = {}
        local added_pets         = {}
        local total_added        = 0
        local support_team_count = #support_team
        local findpetforlevel    = pet_level_require_array
        local howmanypets_canadd = GetMaxPetCapacity() - support_team_count
        if howmanypets_canadd > 0 then
            -- add all support, since we can
            for _, t1 in ipairs(support_team) do
                table.insert(pet_array, t1)
                total_added = total_added + 1
            end
            local max_petssp = GetMaxPetCapacity()
            local add_count_x = 0
            for _, t2 in ipairs(findpetforlevel) do
                if total_added >= max_petssp then
                    break
                end

                if FSettings.mut_system.single_unit_allowed then
                    if add_count_x == 1 then
                        break
                    end
                end

                table.insert(pet_array, t2)
                added_pets[t2] = true
                total_added = total_added + 1
                add_count_x = add_count_x + 1
            end
        end
        return pet_array, added_pets
    end,

    GenTeamMutation = function(pet_level_require_array, team)
        local pet_array          = {}
        local pets_added         = {}
        local total_added        = 0
        local support_team_count = #team
        local findpetforlevel    = pet_level_require_array
        local howmanypets_canadd = GetMaxPetCapacity() - support_team_count
        if howmanypets_canadd > 0 then
            -- add all support, since we can
            for _, t1 in ipairs(team) do
                table.insert(pet_array, t1)
                total_added = total_added + 1
            end
            local max_petssp = GetMaxPetCapacity()
            local add_count_x = 0
            for _, t2 in ipairs(findpetforlevel) do
                if total_added >= max_petssp then
                    break
                end

                if FSettings.mut_system.single_unit_allowed then
                    if add_count_x == 1 then
                        break
                    end
                end

                table.insert(pet_array, t2)
                pets_added[t2] = true
                total_added = total_added + 1
                add_count_x = add_count_x + 1
            end
        end
        return pet_array, pets_added
    end,

    GetPetsNeedMutations = function()
        local tbl_pets = {}

        -- warn("Targets: " .. #FSettings.mut_system.targetteam)
        local baseweight_list = {}
        local mut_list = {}
        local baseweight_required = tonumber(FSettings.mut_system.required_weight) or 2.10
        local is_baseweight_mode = FSettings.mut_system.is_baseweight_mode
        local baseweight_level = tonumber(FSettings.mut_system.lvl_baseweight) or 40
        local mut_level = tonumber(FSettings.mut_system.level) or 40
        local wanted_mut_list = FSettings.mut_system.wanted
        local mut_team_list = FSettings.mut_system.mut_team or {}

        local bypass_mut = false
        if is_baseweight_mode and #mut_team_list == 0 then
            bypass_mut = true
        end

        for _, _uuid in ipairs(FSettings.mut_system.targetteam) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end

            if bypass_mut then continue end

            local UUID = _petData.UUID
            local PetData = _petData.PetData
            local PetType = _petData.PetType -- name of the pet
            local Level = PetData.Level
            local MutationType = PetData.MutationType or ""

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""

            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                continue
            end

            if Level < mut_level then
                continue
            end

            table.insert(mut_list, _uuid)
        end

        if #mut_list > 0 then
            return mut_list, "mut"
        end

        for _, _uuid in ipairs(FSettings.mut_system.targetteam) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end
            local UUID = _petData.UUID
            local PetData = _petData.PetData
            local PetType = _petData.PetType -- name of the pet
            local Name = PetData.Name
            local Level = PetData.Level
            local BaseWeight = PetData.BaseWeight

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            if real_weight >= baseweight_required then
                continue
            end


            if Level < baseweight_level then
                continue
            end

            table.insert(baseweight_list, _uuid)
        end



        if is_baseweight_mode then
            if #baseweight_list > 0 then
                return baseweight_list, "weight"
            end
        end


        return tbl_pets, "N/A"
    end,

    GetPetsNotReadyForMutations = function()
        local tbl_pets = {}
        local required_bw = tonumber(FSettings.mut_system.required_weight) or 2.10
        local level_require = tonumber(FSettings.mut_system.level)
        local bw_level = tonumber(FSettings.mut_system.lvl_baseweight)
        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams
        local turbo_minimum_level = tonumber(FSettings.mut_system.turbo_max_level) or 25
        local target_team = FSettings.mut_system.targetteam
        local is_baseweight_mode = FSettings.mut_system.is_baseweight_mode
        local mut_team_list = FSettings.mut_system.mut_team

        local bypassmut = false
        if is_baseweight_mode and #mut_team_list == 0 then
            bypassmut = true
        end

        for _, _uuid in ipairs(target_team) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end
            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility

            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            local IsFavorite = PetData.IsFavorite
            local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""
            local has_mut = false
            local has_base_weight = false
            local can_add = false

            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                has_mut = true
            end

            -- bypass check for mutation
            if bypassmut then
                has_mut = true
            end

            if real_weight >= required_bw then
                has_base_weight = true
            end

            -- Get rid of pets that have reached mutation
            if has_mut and not is_baseweight_mode then
                continue
            end

            if has_mut and has_base_weight and is_baseweight_mode then
                continue
            end

            -- Base Weight check. any pets not have required base weight should be marked as require level if level is less than required
            if is_baseweight_mode and has_mut then
                if real_weight < required_bw and Level < bw_level then
                    table.insert(tbl_pets, _uuid)
                    -- can_add = true
                    continue
                end
            end

            -- only store pets that do not have mutation and not pet level requirement
            if not has_mut and Level < level_require then
                table.insert(tbl_pets, _uuid)
                continue
            end
        end
        return tbl_pets
    end,


    GetPetsRequireMaxLevelX = function()
        local tbl_pets = {}
        local all_passed = true
        local require_lvl = tonumber(FSettings.mut_system.level)
        local bw_lvl = tonumber(FSettings.mut_system.lvl_baseweight)
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode
        local required_weight = tonumber(FSettings.mut_system.required_weight) or 2.10
        local max_lvl = tonumber(FSettings.mut_system.custom_max_level) or 100

        local is_turbo_maxed = false -- not used, keep as is

        for _, _uuid in ipairs(FSettings.mut_system.targetteam) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end
            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility

            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            local IsFavorite = PetData.IsFavorite
            local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""

            local has_mut = false
            local has_weight = false
            local is_maxed_level = false
            if FSettings.mut_system.wanted[CurrentMutationOnPet] then
                has_mut = true
            end

            if real_weight >= required_weight then
                has_weight = true
            end
            if Level >= max_lvl then
                is_maxed_level = true
            end

            if is_maxed_level then
                continue
            end

            if is_weight_mode then
                if has_weight and has_mut then
                    all_passed = false
                    continue
                end
            else
                if has_mut then
                    all_passed = false
                    continue
                end
            end

            if not has_mut then
                all_passed = false
            end

            if is_weight_mode and not has_weight then
                all_passed = false
            end

            table.insert(tbl_pets, _uuid)
        end

        if FSettings.mut_system.max_lvl_batch then
            if not all_passed then
                tbl_pets = {}
                return tbl_pets, is_turbo_maxed
            end
        end

        return tbl_pets, is_turbo_maxed
    end,

    GetPetsRequireMaxLevel = function()
        local tbl_pets = {}
        local all_passed = true -- For batch mode: assumes all pets will pass
        local require_lvl = tonumber(FSettings.mut_system.level)
        local bw_lvl = tonumber(FSettings.mut_system.lvl_baseweight)
        local is_weight_mode = FSettings.mut_system.is_baseweight_mode
        local required_weight = tonumber(FSettings.mut_system.required_weight) or 2.10
        local max_lvl = tonumber(FSettings.mut_system.custom_max_level) or 100
        local level_only_mode = FSettings.mut_system.only_level_mode

        local mut_team_ls = FSettings.mut_system.mut_team

        local bypassmut = false

        if is_weight_mode and #mut_team_ls == 0 then
            bypassmut = true
        end

        local is_turbo_maxed = false -- not used, keep as is

        for _, _uuid in ipairs(FSettings.mut_system.targetteam) do
            local _petData = GetPetDataByUUID(_uuid)
            if not _petData then
                continue
            end
            local UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            local PetAbility = _petData.PetAbility

            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            local IsFavorite = PetData.IsFavorite
            local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""

            local real_weight = GetRealPetWeight(BaseWeight, 1)

            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType] or ""



            -- 1. Ignore any pets that have already reached max_lvl
            if Level >= max_lvl then
                continue
            end

            -- Level only mode , exit here.
            if level_only_mode then
                table.insert(tbl_pets, _uuid)
                continue
            end

            -- 2. Check if the pet meets the criteria to be leveled up
            local has_wanted_mut = FSettings.mut_system.wanted[CurrentMutationOnPet] or false
            local meets_weight_req = real_weight >= required_weight

            local is_eligible = false

            -- must always check mutation first, its required.
            if has_wanted_mut then
                is_eligible = true
            end

            -- bypass mutation check
            if bypassmut then
                is_eligible = true
            end

            -- weight mode is optional enabled by user
            if is_weight_mode then
                -- In weight mode, must have mut AND meet weight
                if has_wanted_mut and meets_weight_req then
                    is_eligible = true
                else
                    is_eligible = false
                end
            end

            -- 3. Process eligibility
            if is_eligible then
                -- This pet is eligible to be leveled; add it to the list
                table.insert(tbl_pets, _uuid)
            else
                all_passed = false
            end
        end

        -- 4. Final check for batch mode
        if FSettings.mut_system.max_lvl_batch then
            -- If batch mode is on AND not all non-maxed pets were eligible...
            if not all_passed then
                -- ...fail the batch and return an empty list.
                tbl_pets = {}
                return tbl_pets, is_turbo_maxed
            end
        end

        return tbl_pets, is_turbo_maxed
    end,
}

PetMutation.Turns = {
    LEVEL = "level",
    MUTATE = "mutate",
}

PetMutation.UpdateTurn = function(turn)
    if turn == PetMutation.Turns.LEVEL or turn == PetMutation.Turns.MUTATE then
        FSettings.mut_system.state = turn
        SaveData()
    end
end

PetMutation.GetCurrentTurn = function()
    return FSettings.mut_system.state
end




--------- END pet mut








----------------------------------------------
------- Seed Placements
SeedManager.seedAnimState = { frameIndex = 1, colorIndex = 1 }
SeedManager.IsActive = false

SeedManager.Labels = {
    updateLocation = function(_txt)
        if UI_LABELS.lbl_seed_location then
            UI_LABELS.lbl_seed_location:SetText(_txt)
        end
    end,

    updateStats = function(_txt)
        if UI_LABELS.lbl_seed_status then
            UI_LABELS.lbl_seed_status:SetText(_txt)
        end
    end,

    updateInformation = function(_array)
        if not UI_LABELS.lbl_seed_information then
            return
        end

        local maxKeep = FOtherSettings.seed_keep_amount or 0

        -- Animated title frames (dots)
        local titleFrames = {
            "ðŸŒ± Planting Seeds",
            "ðŸŒ¿ Growing Dreams",
            "ðŸŒ¾ Sowing the Future",
            "ðŸŒ» Bloom Mode Active",
            "ðŸ€ Sprouting Life",
            "ðŸŒ¸ Nature's Touch",
            "ðŸŒ³ Seeding the Fields",
            "âœ¨ Auto-Planting",
            "ðŸª´ Green Thumb Engaged",
            "ðŸŒ¼ Growth in Progress"
        }
        -- Rainbow colours
        local rainbowColors = {
            "#FF4C4C", -- Bright Red
            "#FFA500", -- Orange
            "#FFD700", -- Gold
            "#32CD32", -- Lime Green
            "#1E90FF", -- Dodger Blue
            "#8A2BE2", -- Violet
            "#FF69B4"  -- Hot Pink
        }

        -- Get current animation state
        local frameIndex = SeedManager.seedAnimState.frameIndex
        local colorIndex = SeedManager.seedAnimState.colorIndex

        -- Animated title with rainbow colour
        local animatedTitle = string.format("<font color='%s'>%s</font>\n\n", rainbowColors[colorIndex],
            titleFrames[frameIndex])

        -- Update state for next call
        frameIndex = frameIndex + 1
        if frameIndex > #titleFrames then frameIndex = 1 end
        colorIndex = colorIndex + 1
        if colorIndex > #rainbowColors then colorIndex = 1 end
        SeedManager.seedAnimState.frameIndex = frameIndex
        SeedManager.seedAnimState.colorIndex = colorIndex

        -- Build plant lines
        local txtLines = {}
        for plantName, count in pairs(_array) do
            local nameColor = _Helper.StringToColor3(plantName) or "#ffffff"

            -- Determine status colour
            local statusColor
            if count < maxKeep then
                statusColor = "#ff0000" -- red
            elseif count == maxKeep then
                statusColor = "#00ff00" -- green
            else
                statusColor = "#ffff00" -- yellow
            end

            table.insert(txtLines, string.format(
                "<font color='%s'>%s:</font> <font color='%s'>%d / %d</font>",
                nameColor,
                plantName,
                statusColor,
                count,
                maxKeep
            ))
        end

        -- Combine title + plant lines
        local fullText = animatedTitle .. table.concat(txtLines, "\n")
        UI_LABELS.lbl_seed_information:SetText(fullText)
    end,

}
-- #seeds
SeedManager.Seeds = {
    -- Returns a table of seed names and quantities available in inventory
    GetSeedsCounts = function(seedList)
        local data = {}

        for seedName, _ in pairs(seedList) do
            local seed = InventoryManager.GetSeedUsingName(seedName)
            if not seed then
                print("Seed not found: ", seedName)
                continue
            end

            local count = InventoryManager.GetSeedCountQuantity(seed)
            if count <= 0 then
                print("Seed count 0: ", seedName)
                continue
            end

            data[seedName] = count
        end

        if next(data) == nil then
            return nil
        end

        return data
    end,

    -- Returns seeds that can still be placed based on max per type
    GetSeedsToPlaceFiltered = function()
        local availableSeeds = SeedManager.Seeds.GetSeedsCounts(FOtherSettings.seed_placement_list)
        if availableSeeds == nil then
            return nil
        end

        -- Count currently planted seeds
        local plantedCounts
        local success, result = pcall(function()
            return FarmManager.GetPlantCountBySeedNamesPairs(availableSeeds)
        end)
        plantedCounts = success and result or nil
        if not plantedCounts or next(plantedCounts) == nil then
            return nil
        end

        local maxKeep = FOtherSettings.seed_keep_amount
        local seedsToPlace = {}
        local planted = {}

        for seedName, plantedAmount in pairs(plantedCounts) do
            if plantedAmount < maxKeep then
                seedsToPlace[seedName] = maxKeep - plantedAmount
                --planted[seedName] = plantedAmount
            end
        end

        if next(seedsToPlace) == nil then
            return nil
        end

        return seedsToPlace, plantedCounts
    end,
}



----------END Seed system


------------------
------------------ TROWEL SYSTEM
------------------

_PlantsManager.UpdateTrowelProgress = function(_txt)
    if UI_LABELS.lbl_trowel_progress then
        UI_LABELS.lbl_trowel_progress:SetText(_txt)
    end
end

_PlantsManager.UpdateTrowelStatus = function(_txt)
    if UI_LABELS.lbl_trowel_stats then
        UI_LABELS.lbl_trowel_stats:SetText(_txt)
    end
end

_PlantsManager.UpdateTrowelCframe = function(_txt)
    if UI_LABELS.lbl_trowel_cframe then
        UI_LABELS.lbl_trowel_cframe:SetText(_txt)
    end
end

_PlantsManager.Vector3ToCFrame = function(v3)
    if not v3 then return nil end
    return CFrame.new(v3)
end

_PlantsManager.StringToVector3 = function(str)
    if not str then return nil end

    local x, y, z = str:match("([^,]+),([^,]+),([^,]+)")
    if not x or not y or not z then return nil end

    return Vector3.new(tonumber(x), tonumber(y), tonumber(z))
end

_PlantsManager.GetCurrentCFrameFromPlayer = function()
    local root = _S.Character and _S.Character:FindFirstChild("HumanoidRootPart")
    return root and root.CFrame or nil
end


_PlantsManager.GetCurrentCFrameFromPlayerString = function()
    local root = _S.Character and _S.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    return string.format("%f,%f,%f", pos.X, pos.Y, pos.Z)
end

_PlantsManager.IsWithinRangeOfFarm = function(centerPoint, newPosition)
    -- Create "flat" versions of the vectors by setting their Y components to 0
    local MAX_DISTANCE = 70.8 -- The radius from your farm's center
    local center_flat = Vector3.new(centerPoint.X, 0, centerPoint.Z)
    local position_flat = Vector3.new(newPosition.X, 0, newPosition.Z)

    -- Calculate the purely horizontal distance
    local distance = (centerPoint - newPosition).Magnitude

    -- Return true if the calculated distance exceeds the maximum allowed
    return distance > MAX_DISTANCE
end

_PlantsManager.GetPlantIfPlantWithinPosition3D = function(v3_current_pos, v3_target_pos)
    local distance = (v3_current_pos - v3_target_pos).Magnitude
    return distance < 1
end

_PlantsManager.GetPlantIfPlantWithinPositionXZ = function(v3_current_pos, v3_target_pos)
    -- Create new vectors with the Y-axis "flattened" to 0 for a 2D distance check
    local v3_current_flat = Vector3.new(v3_current_pos.X, 0, v3_current_pos.Z)
    local v3_target_flat = Vector3.new(v3_target_pos.X, 0, v3_target_pos.Z)
    local distance = (v3_current_flat - v3_target_flat).Magnitude
    return distance < 1.3
end

_PlantsManager.GetAllPlantsOnFarmForTrowel = function(position)
    local all_px = {}
    local filter = FOtherSettings.trowel_plants_list
    local useFilter = filter and next(filter) ~= nil -- true if table has entries

    for _, plant in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        -- only filter if list has entries
        if useFilter and not filter[plant.Name] then
            continue
        end

        if position then
            local pos = plant:GetPivot().Position
            --warn("Position: ", tostring(pos))
            if _PlantsManager.GetPlantIfPlantWithinPositionXZ(pos, position) then
                continue
            end
        end

        all_px[#all_px + 1] = plant
    end

    return all_px
end

_PlantsManager.FindTrowelTool = function()
    for _, _tool in ipairs(_S.Backpack:GetChildren()) do
        if not _tool:IsA("Tool") then continue end
        local b = _tool:GetAttribute("b")
        if not b then continue end

        if string.find(_tool.Name, "Trowel", 1, true) then
            -- found a Trowel tool
            return _tool
        end
    end

    -- not found trowel, player must be holding it
    for _, tool in ipairs(_S.Character:GetChildren()) do
        if not tool:IsA("Tool") then continue end
        local b = tool:GetAttribute("b")
        if not b then continue end

        if string.find(tool.Name, "Trowel", 1, true) then
            -- found a Trowel tool
            return tool
        end
    end


    return nil
end

_PlantsManager.PickUpPlantUsingTrowel = function(trowel, fruit)
    -- fire remote
    local success, failx = pcall(function()
        _S.TrowelRemote:InvokeServer("Pickup", trowel, fruit)
        task.wait(0.3)
    end)

    if failx then
        warn("PickUpPlantUsingTrowel: ", failx)
    end
    return success
end


_PlantsManager.PlacePlantUsingTrowel = function(trowel, fruit, v3Location)
    -- fire remote
    local success, failx = pcall(function()
        _S.TrowelRemote:InvokeServer("Place", trowel, fruit, _PlantsManager.Vector3ToCFrame(v3Location))
        task.wait(0.3)
    end)

    if failx then
        warn("PlacePlantUsingTrowel: ", failx)
    end
    return success
end


----------------------- END TROWEL SYSTEM



-- #hud

_Helper.NotifyButton = function()
    pcall(function()
        local playerGui = _S.PlayerGui
        local topbar = playerGui:WaitForChild("TopbarStandard")
        if not topbar then return end

        local rightHolder = topbar:FindFirstChild("Holders") and topbar.Holders:FindFirstChild("Right")
        if not rightHolder then return end

        local notifyBtn = rightHolder:FindFirstChild("EVENT NOTIFY")
        if not notifyBtn then return end

        -- âœ… Only disable this one button
        notifyBtn.Visible = not FSettings.disable_event_notify_button
    end)
end
task.spawn(function()
    task.wait()
    _Helper.NotifyButton()
end)


_Helper._originalTeleportSizes = {}
_Helper.Event_Point = nil

_Helper.FindEventPoint = function()
    if _Helper.Event_Point then
        return _Helper.Event_Point
    end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj.Name == "Event_Point" then
            _Helper.Event_Point = obj
            return obj
        end
    end
    return nil
end

_Helper.CreateEventTeleportButton = function(opts)
    local teleportUI = _S.PlayerGui:FindFirstChild("Teleport_UI")
    if not teleportUI then return end

    local frame = teleportUI:FindFirstChild("Frame")
    if not frame then return end

    local gardenBtn = frame:FindFirstChild("Garden")
    if not gardenBtn or not gardenBtn:IsA("ImageButton") then
        warn("Garden button missing")
        return
    end

    local eventBtn = gardenBtn:Clone()
    eventBtn.Name = "Event"

    -- update button text
    local textObj = eventBtn:FindFirstChildWhichIsA("TextLabel", true)
    if textObj then
        textObj.Text = "Event"
    end

    -- âœ… ORANGE-HUE BUTTON
    eventBtn.ImageColor3 = Color3.fromRGB(255, 140, 50)

    -- optional extra overrides
    if opts then
        if opts.RemoveBG then
            eventBtn.Image = ""
            eventBtn.ImageTransparency = 1
        end
        if opts.NewImage then
            eventBtn.Image = opts.NewImage
            eventBtn.ImageTransparency = 0
        end
        if opts.BGTransparency then
            eventBtn.ImageTransparency = opts.BGTransparency
        end
    end

    eventBtn.Parent = frame

    -- click callback
    if opts and opts.OnClick then
        eventBtn.MouseButton1Click:Connect(function()
            opts.OnClick(eventBtn)
        end)
    end

    return eventBtn
end

_Helper.ResizeTeleportButtons = function(makeSmall)
    local teleportUI = _S.PlayerGui:FindFirstChild("Teleport_UI")
    if not teleportUI then return end

    local frame = teleportUI:FindFirstChild("Frame")
    if not frame then return end
    local percent_d = 0.8

    for _, obj in ipairs(frame:GetDescendants()) do
        if obj:IsA("ImageButton") then
            if not _Helper._originalTeleportSizes[obj] then
                _Helper._originalTeleportSizes[obj] = obj.Size
            end

            local original = _Helper._originalTeleportSizes[obj]

            if makeSmall then
                obj.Size = UDim2.new(
                    original.X.Scale * percent_d,
                    original.X.Offset * percent_d,
                    original.Y.Scale * percent_d,
                    original.Y.Offset * percent_d
                )
            else
                obj.Size = original
            end
        end
    end
end

_Helper.CreateEventTeleportButton({
    OnClick = function(btn)
        local ev_point = _Helper.FindEventPoint()
        if ev_point then
            TeleportPlayerToCFrame(ev_point.CFrame)
        end
    end
})

_Helper.ResizeTeleportButtons(true)

-----======================================
--------- Craft Manager
-----======================================

CraftManager.Update_GearEventWorkbenchStatus = function(_txt)
    if UI_LABELS.lbl_craftinggear_stats then
        UI_LABELS.lbl_craftinggear_stats:SetText(_txt)
    else
        warn("null label Update_GearEventWorkbenchStatus")
    end
end

CraftManager.Update_GearEventWorkbenchTimers = function(_txt)
    if UI_LABELS.lbl_crafting_timeleft then
        UI_LABELS.lbl_crafting_timeleft:SetText(_txt)
    end
end

CraftManager.CraftStats = {
    SELECT_RECIPE = "SELECT_RECIPE",
    START_CRAFTING = "START_CRAFTING",
    SKIP_CRAFT = "SKIP_CRAFT",
    CLAIM_REWARDS = "CLAIM_REWARDS",
    SUBMIT_ITEM = "SUBMIT_ITEM"
}

CraftManager.GetProximityPromptUsingModel = function(_model)
    for _, modelWbC in ipairs(_model:GetChildren()) do
        local p = modelWbC:FindFirstChildWhichIsA("ProximityPrompt",
            true)
        if p then
            return p
        end
    end
    return nil
end



CraftManager.GetWorkbenchStateUsingName = function(benchName)
    local workb = CraftManager.GetWorkBenchModelUsingName(benchName)
    if not workb then return nil end
    local prompt = CraftManager.GetProximityPromptUsingModel(workb)
    if not prompt then
        --warn("prompt not found " .. benchName)
        return nil
    end

    local current_status = CraftManager.CraftStats.SELECT_RECIPE

    if prompt and prompt:IsA("ProximityPrompt") and prompt.ActionText then
        local txt = prompt.ActionText

        if string.find(txt, "Start Crafting", 1, true) then
            --warn("--->>> Start Crafting")
            current_status = CraftManager.CraftStats.START_CRAFTING
        elseif string.find(txt, "Select Recipe", 1, true) then
            --warn("--->>> Select Recipe")
            current_status = CraftManager.CraftStats.SELECT_RECIPE
        elseif string.find(txt, "Claim", 1, true) then
            --warn("--->>> Claim Rewards")
            current_status = CraftManager.CraftStats.CLAIM_REWARDS
        elseif string.find(txt, "Submit Item", 1, true) then
            --warn("--->>> Submit Item")
            current_status = CraftManager.CraftStats.SUBMIT_ITEM
        elseif string.find(txt, "Skip", 1, true) then
            --warn("--->>> Skip Craft")
            current_status = CraftManager.CraftStats.SKIP_CRAFT
        end

        --print("ActionText:", txt)
    else
        --warn("No valid CraftingProximityPrompt found.")
    end

    return current_status
end


-- CraftManager.GetGearEventWorkbenchUI = function()
--     local wb = CraftManager.Model_EventCraftingWorkBench
--     if not wb then return nil end

--     local uiData = {
--         RemainingText = nil,
--         TimerText = nil
--     }

--     -- Protect access with pcall
--     pcall(function()
--         for _, _mod in ipairs(wb:GetChildren()) do
--             local gui = _mod:FindFirstChildWhichIsA("BillboardGui", true) -- recursive
--             if not gui then
--                 continue
--             end

--             if gui.Name ~= "CraftingBillboardGui" then
--                 return nil
--             end

--             local label = gui:FindFirstChild("TextLabel")
--             local timer = gui:FindFirstChild("Timer")
--             if label and label:IsA("TextLabel") then
--                 uiData.RemainingText = label.Text
--             end
--             if timer and timer:IsA("TextLabel") then
--                 uiData.TimerText = timer.Text
--             end
--         end
--         -- warn("Success got texts")
--     end)

--     return uiData
-- end


-- Craft All
CraftManager.CancelWorkbenchUsingName = function(_name)
    local wb = CraftManager.GetWorkBenchModelUsingName(_name)
    if not wb then return nil end
    _S.CraftingGlobalObjectService:FireServer("Cancel", wb, _name, 1)
end

CraftManager.ClaimWorkbenchUsingName = function(_name)
    local wb = CraftManager.GetWorkBenchModelUsingName(_name)
    if not wb then return nil end
    _S.CraftingGlobalObjectService:FireServer("Claim", wb, _name, 1)
end

CraftManager.CreateRecipeWorkbenchUsingName = function(_name, receipeName)
    local wb = CraftManager.GetWorkBenchModelUsingName(_name)
    if not wb then return nil end
    _S.CraftingGlobalObjectService:FireServer("SetRecipe", wb, _name, receipeName)
end

CraftManager.SubmitRecipeWorkbenchUsingName = function(_name, number, _data)
    local wb = CraftManager.GetWorkBenchModelUsingName(_name)
    if not wb then return nil end
    _S.CraftingGlobalObjectService:FireServer("InputItem", wb, _name, number, _data)
end

CraftManager.StartCraftWorkbenchUsingName = function(_name)
    local wb = CraftManager.GetWorkBenchModelUsingName(_name)
    if not wb then return nil end
    _S.CraftingGlobalObjectService:FireServer("Craft", wb, _name)
end

-- Sprinkler #
-- PetEgg #
-- Harvest Tool #
-- Recall Wrench #
-- Holdable #
-- SprayBottle #
-- Seed #
-- Food #
-- PetBoost
-- Lightning Rod #
-- CosmeticCrate #


CraftManager.SetRecipeUsingName = function(benchName)
    local rlist = FSettings.allcraft.receipe_data[benchName]
    if not rlist then return false end
    for _name, val in pairs(rlist) do
        local dx = CraftManager.AllReceipeData[benchName]
        if not dx then continue end


        local inputs = dx[_name].inputs

        -- print("-----------------")
        -- warn("Craft item: " .. _name)
        -- _Helper.JsonPrint(inputs)


        local required_items = {}
        for _, _receipeItem in ipairs(inputs) do
            local itemName = _receipeItem.Name
            local itemType = _receipeItem.Type

            local _item_find = nil

            if itemType == "PetBoost" then
                _item_find = InventoryManager.GetPetBoostUsingName(itemName)
            elseif itemType == "Pet" then
                _item_find = InventoryManager.GetPetUsingNameForCraft(itemName)
            elseif itemType == "CosmeticCrate" then
                _item_find = InventoryManager.GetCosmeticCrateUsingName(itemName)
            elseif itemType == "SprayBottle" then
                _item_find = InventoryManager.GetSprayBottleUsingName(itemName)
            elseif itemType == "Sprinkler" then
                _item_find = InventoryManager.GetSprinklerUsingName(itemName)
            elseif itemType == "Harvest Tool" then
                _item_find = InventoryManager.GetHarvestTool()
            elseif itemType == "Recall Wrench" then
                _item_find = InventoryManager.GetRecallWrench()
            elseif itemType == "Lightning Rod" then
                _item_find = InventoryManager.GetLightningRod()
            elseif itemType == "PetEgg" then
                _item_find = InventoryManager.GetEggUsingName(itemName)
            elseif itemType == "Holdable" then
                _item_find = InventoryManager.GetHoldableUsingName(itemName)
            elseif itemType == "Seed" then
                _item_find = InventoryManager.GetSeedUsingName(itemName)
            elseif itemType == "Food" then
                _item_find = InventoryManager.GetFoodUsingName(itemName)
            elseif itemType == "Smith Hammer of Harvest" then
                _item_find = InventoryManager.GetSmithHammerofHarvest()
            else
                _item_find = InventoryManager.GetToolUsingNameNormalised(itemName)
            end

            -- add to list
            if not _item_find then
                required_items = {}
                CraftManager.Current_Recipe_MissingItemName = CraftManager.Current_Recipe_MissingItemName ..
                    " " .. itemName .. ","
                CraftManager.Current_Recipe_Name = CraftManager.Current_Recipe_Name .. " " .. _name .. ","
                --warn("dont have required items " .. itemName)

                --warn("Missing: ", CraftManager.Current_Recipe_MissingItemName)

                if itemType == "Holdable" then
                    -- maybe its seed

                    if _FruitCollectorMachine.HasPlantByName(itemName) then
                        -- find and collect
                        if FOtherSettings.craft_autofruit_workbench then
                            CraftManager.Update_GearEventWorkbenchStatus("ðŸ’ Trying to Collect fruits")
                            local ss, rr = pcall(function()
                                local newf = {}
                                newf[itemName] = true
                                _FruitCollectorMachine.CollectFruitByNamesSortedRarity(newf, 3)
                            end)

                            if not ss then
                                warn("Failed to collect fruit: " .. itemName .. " - ", rr)
                            end
                            task.wait(0.5)
                        end
                    else
                        -- plant new
                        if FOtherSettings.craft_autoplant_workbench then
                            CraftManager.Update_GearEventWorkbenchStatus("ðŸ’ Trying to plant seed ", itemName)
                            local ss, rr = pcall(function()
                                if not Varz.is_garden_full_seed then
                                    task.spawn(function()
                                        _FruitCollectorMachine.PlaceSeedSmart(itemName, 2)
                                    end)
                                end
                            end)
                            if not ss then
                                warn("Failed to plant: " .. itemName .. " - ", rr)
                            end
                            task.wait(0.5)
                        end
                    end
                end
                break
            end
            local _uuid = _item_find:GetAttribute("c")
            if itemType == "Pet" then
                local PET_UUID = _item_find:GetAttribute("PET_UUID")
                _uuid = PET_UUID
            end

            local mdata = {
                ItemName = itemName,
                ItemType = itemType,
                ItemData = {
                    UUID = _uuid
                }
            }

            table.insert(required_items, mdata)
        end

        if #required_items > 0 then
            --warn("We have items start craft")
            CraftManager.CreateRecipeWorkbenchUsingName(benchName, _name)
            task.wait(1.5)

            for index, xdb in ipairs(required_items) do
                local xItemType = xdb.ItemType
                local ItemName = xdb.ItemName

                local mdata = {
                    ItemType = xdb.ItemType,
                    ItemData = xdb.ItemData
                }
                if xItemType == "Pet" then
                    -- manual submit pets
                    Varz.IS_CRAFTING = true
                    task.wait(1.3)
                    local pettool = InventoryManager.GetPetUsingNameForCraft(ItemName)
                    if pettool then
                        unequipTools()
                        task.wait(0.1)
                        EquipToolOnChar(pettool)
                        task.wait(0.5)
                        CraftManager.SubmitRecipeWorkbenchUsingName(benchName, index, mdata)
                    end
                    Varz.IS_CRAFTING = false
                else
                    CraftManager.SubmitRecipeWorkbenchUsingName(benchName, index, mdata)
                end

                --print("submit " .. tostring(index) .. " - " .. _S.HttpService:JSONEncode(xdb))
                task.wait(0.5)
            end
            CraftManager.Current_Recipe_Name = _name
            --print("Current Recipe: " .. _name)

            return true
        end
    end

    return false
end

------------------ END CRAFT



--============ Tasks Threading
-- #claim
TaskManager.reclaim_running = false

TaskManager.ReclaimTask = function()
    TaskManager.reclaim_running = true

    local plants_required = FSettings.reclaim.plants
    local keep_amount = tonumber(FSettings.reclaim.keep_amount) or 0
    local ui = UPDATE_LABELS_FUNC.UpdateReclaimStatus

    while TaskManager.reclaim_running do
        ui("ðŸ”„ <font color='#00BFFF'>Starting Reclaimer...</font>")
        task.wait(1)

        local any_found = false

        if next(plants_required) == nil then
            ui("âš ï¸ <font color='#FFA500'>No plants found</font>")
            break
        end

        local _tool = InventoryManager.GetToolUsingName("Reclaimer")
        if not _tool then
            ui("âš ï¸ <font color='#FFA500'>No reclaimer tool found.</font>")
            break
        end
        unequipTools()
        task.wait(0.2)
        if not EquipToolOnChar(_tool) then
            ui("âš ï¸ <font color='#FFA500'>Failed to equip reclaimer tool.</font>")
            break
        end

        Varz.IS_SEEDING = true

        for PlantName, val in pairs(plants_required) do
            local all_plants_instance = FarmManager.GetAllPlantsObjectUsingName(PlantName)
            if #all_plants_instance == 0 then
                continue
            end
            any_found = true
            -- âœ… how many to reclaim
            local total = #all_plants_instance
            local to_reclaim = math.max(0, total - keep_amount)
            local total_claimed = 0

            if to_reclaim == 0 then
                ui("ðŸŸ¢ <font color='#32CD32'>Keep amount reached for " .. PlantName .. ". No reclaim needed.</font>")
                task.wait(0.5)
                continue
            end

            if not IsToolHeldNew(_tool) or Varz.IS_HATCHING then
                break
            end

            for _, _item in ipairs(all_plants_instance) do
                if not IsToolHeldNew(_tool) or Varz.IS_HATCHING then
                    break
                end
                total_claimed = total_claimed + 1
                ui(
                    "ðŸŒ± <font color='#FFD700'>Claiming " .. PlantName .. "</font> " ..
                    "<font color='#00FF00'>[" .. total_claimed .. "/" .. to_reclaim .. "]</font>"
                )

                InventoryManager.TryReclaim(_item)
                if total_claimed >= to_reclaim then
                    ui("âœ… <font color='#32CD32'>Finished reclaiming " .. PlantName .. "</font>")
                    break
                end

                task.wait(0.1)
            end
            task.wait(0.5)
        end

        Varz.IS_SEEDING = false

        if not any_found then
            ui("âš ï¸ <font color='#FFA500'>No plants to reclaim</font>")
            break
        end
        ui("âœ… <font color='#32CD32'>Finished reclaiming all</font>")
        break
    end
    Varz.IS_SEEDING = false
    TaskManager.reclaim_running = false
    Library:Notify("Reclaimer completed. ðŸŒ¿")
end


TaskManager.StartReclaimer = function()
    if TaskManager.reclaim_running then
        Library:Notify("Reclaimer already started.")
        return false
    end
    task.spawn(TaskManager.ReclaimTask)
    Library:Notify("Reclaimer started.")
    return true
end

TaskManager.StopReclaimer = function()
    TaskManager.reclaim_running = false
    Library:Notify("Reclaimer stopped.")
end




local Mutation_Data = {}
local Mutation_SubmitPet = {}
-- ================ EGG SYSTEM
-- #data
_G.EggDataStreamListener = _S.DataStream.OnClientEvent:Connect(function(action, profileName, data)
    if action ~= "UpdateData" or not profileName then return end

    local eggsData = {}

    for _, entry in ipairs(data) do
        local key = entry[1]
        local value = entry[2]

        -- Extract UUID
        -- local uuid = key:match("SavedObjects/({.-})")
        -- if uuid then
        --     -- Initialise if first time
        --     eggsData[uuid] = eggsData[uuid] or {}

        --     if key:find("/Data/Type") and value ~= nil then
        --         eggsData[uuid].Type = value
        --     elseif key:find("/Data/BaseWeight") and value ~= nil then
        --         eggsData[uuid].BaseWeight = value
        --     elseif key:find("/Data/CanHatch") and value ~= nil then
        --         eggsData[uuid].CanHatch = value
        --     end
        -- end

        -------------------------
        -------- Pet Hatch Data # not reliable, gifting also triggers
        -------------------------

        -- if key:match("ROOT/PlayerPetData/".._S.LocalPlayer.Name .."/PetInventory/Data/") then

        --     if type(value) == "table" then
        --         local uuidx = value.UUID
        --         local petType = value.PetType
        --         local PetData = value.PetData

        --         local name = PetData.Name         -- Default to nil
        --         local level = PetData.Level
        --         local BaseWeight = PetData.BaseWeight
        --         local HatchedFrom = PetData.HatchedFrom
        --        warn(string.format(
        --     		"[ðŸ£ HATCH] %s just hatched %s (%s, Level %s, Weight %.3f, From %s)",
        --     		profileName,
        --     		tostring(petType),
        --     		tostring(PetData.Name or "Unnamed"),
        --     		tostring(PetData.Level or "?"),
        --     		tonumber(PetData.BaseWeight or 0),
        --     		tostring(PetData.HatchedFrom or "Unknown")
        --     	))
        --     end
        -- end



        -- -----------------
        -- Mutation Machine pets
        -- -----------------
        if key:match("ROOT/PetsData/PetInventory/Data/") then
            -- SAFETY CHECK 1: Make sure 'value' is a table before trying to use it.
            if type(value) == "table" then
                --warn("Ciaim Pet? ")
                local uuidx = value.UUID
                local petType = value.PetType
                local mutationType = nil -- Default to nil
                local name = nil         -- Default to nil
                local level = 0

                -- SAFETY CHECK 2: Make sure the 'PetData' sub-table exists.
                if value.PetData and type(value.PetData) == "table" then
                    mutationType = value.PetData.MutationType
                    name = value.PetData.Name
                    level = value.PetData.Level
                end

                -- Only save if we found all the essential values
                if uuidx and petType and mutationType and name then
                    if level >= tonumber(FOtherSettings.mut_required_level) then
                        --warn("Cancel Mutation")
                        -- insert this uuid back into the hatching machine team
                        if MutationMachineManager.is_running then
                            MutationMachineManager.InsertPetBackIntoTargetList(uuidx)
                            task.wait(0.1)
                        end
                    else
                        Mutation_Data[uuidx] = {
                            PetType = petType,
                            MutationType = mutationType,
                            Name = name,
                            Level = level,
                        }
                    end
                end

                --_Helper.JsonPrint(Mutation_Data)
            end
        end

        -- Mutation SubmittedPet
        if key:match("ROOT/PetMutationMachine/SubmittedPet") then
            -- SAFETY CHECK 1: Make sure 'value' is a table before trying to use it.
            if type(value) == "table" then
                --warn("Pet Submit")
                local uuidx = value.UUID
                local petType = value.PetType
                local mutationType = nil -- Default to nil
                local name = nil         -- Default to nil

                if value.PetData and type(value.PetData) == "table" then
                    mutationType = value.PetData.MutationType
                    name = value.PetData.Name
                end

                -- Only save if we found all the essential values
                if uuidx and petType and mutationType and name then
                    Mutation_SubmitPet[uuidx] = {
                        PetType = petType,
                        MutationType = mutationType,
                        Name = name
                    }
                end

                _Helper.JsonPrint(Mutation_SubmitPet)
            end
        end
    end



    -- Print collected eggs
    --for uuid, info in pairs(eggsData) do
    -- if not info.CanHatch then
    --     --warn("egg not ready " .. uuid)
    --     continue
    -- end
    -- add to found pets
    --local p_w = GetRealPetWeight(info.BaseWeight);
    --Varz.found_pet_data[uuid] = { petname = info.Type, weight = p_w }
    -- print(string.format(
    --     "UUID: %s | Type: %s | BaseWeight: %.2f | CanHatch: %s",
    --     uuid,
    --     tostring(info.Type or "N/A"),
    --     tonumber(info.BaseWeight) or 0,
    --     tostring(info.CanHatch)
    -- ))
    --end
end)



_Helper.GetAllCosmeticCrateModels = function()
    local fobjects = {}
    local objectsonfarm = FarmManager.mObjects_Physical:GetChildren();

    for _, obj in ipairs(objectsonfarm) do
        if obj:IsA("Model") and obj:GetAttribute("TimeToOpen") == 0 and obj.Name == "CosmeticCrate" then
            table.insert(fobjects, obj)
        end
    end

    return fobjects;
end

local function GetAllReadyEggsModels()
    local ready_to_hatch_eggs = {}
    local eggs_on_farm_array = FarmManager.mObjects_Physical:GetChildren();

    for _, obj in ipairs(eggs_on_farm_array) do
        -- Check if the object is a valid, ready-to-hatch egg model
        if obj:IsA("Model") and obj:GetAttribute("TimeToHatch") == 0 and obj.Name == "PetEgg" then
            --obj:GetAttribute("EggName")
            table.insert(ready_to_hatch_eggs, obj)
        end
    end

    return ready_to_hatch_eggs;
end

local function GetEggUuids()
    local array_egg_models = GetAllReadyEggsModels()
    if not array_egg_models then
        return nil
    end

    local e_uuids = {}

    for _, obj in ipairs(array_egg_models) do
        -- Check if the object is a valid, ready-to-hatch egg model
        if obj:IsA("Model") and obj:GetAttribute("TimeToHatch") == 0 and obj.Name == "PetEgg" then
            -- obj:GetAttribute("EggName")
            local uuid = obj:GetAttribute("OBJECT_UUID")
            table.insert(e_uuids, uuid)
        end
    end

    if #e_uuids == 0 then
        return nil
    end

    return e_uuids
end




_Helper.UpdateCrateUi = function(_model)
    if not _model or not _model:IsA("Model") then return end
    local uuid = _model:GetAttribute("OBJECT_UUID")
    if not uuid then return end
    local cinfo = Varz.found_crate_data[uuid]
    if not cinfo or not uuid then
        --warn("dont have pet ui info for this.")
        return
    end
    local maxDistance = 120

    -- Find existing BillboardGui
    local billboard = _model:FindFirstChild("CrBillboardGui")

    if FSettings.is_egg_esp == false then
        if billboard then
            billboard:Destroy()
            billboard = nil
            return
        end
        return
    end

    -- if billboard then
    --     billboard:Destroy();
    --     billboard = nil
    -- end

    if not billboard then
        -- Create new BillboardGui
        billboard = Instance.new("BillboardGui")
        billboard.Name = "CrBillboardGui"
        billboard.Adornee = _model:FindFirstChild("CosmeticCrate") or _model.PrimaryPart
        billboard.Size = UDim2.new(0, 150, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = maxDistance -- <-- added max view distance
        billboard.Parent = _model

        -- Create TextLabel
        local label = Instance.new("TextLabel")
        label.Name = "EggLabel"
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.RichText = true
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextStrokeTransparency = 0
        label.Font = Enum.Font.SourceSansBold
        label.TextScaled = false
        label.TextSize = 19
        label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0) -- black outline

        label.Parent = billboard
    else
        -- Update max distance if needed
        billboard.MaxDistance = maxDistance
    end

    -- Update the label text
    local label = billboard:FindFirstChild("EggLabel")
    if label then
        local eggName = ""
        local weight = ""
        if cinfo then
            eggName = cinfo.name
            weight = cinfo.reward
        end
        label.RichText = true
        label.Text = string.format(
            " <font color='#FF6F00'>%s</font> <font color='#FFFFFF'>â€¢</font> <font color='#AAFF00'>%s</font>",
            eggName, weight
        )
    end
end

local function addOrUpdateEggUI(eggModel)
    if not eggModel or not eggModel:IsA("Model") then return end

    local uuid = eggModel:GetAttribute("OBJECT_UUID")
    if not uuid then return end
    local petinfo = Varz.found_pet_data[uuid]
    if not petinfo or not uuid then
        --warn("dont have pet ui info for this.")
        return
    end

    local maxDistance = 120

    -- Find existing BillboardGui
    local billboard = eggModel:FindFirstChild("EggBillboardGui")

    if FSettings.is_egg_esp == false then
        if billboard then
            billboard:Destroy()
            billboard = nil
            return
        end
        return
    end

    -- if billboard then
    --     billboard:Destroy();
    --     billboard = nil
    -- end

    if not billboard then
        -- Create new BillboardGui
        billboard = Instance.new("BillboardGui")
        billboard.Name = "EggBillboardGui"
        billboard.Adornee = eggModel:FindFirstChild("HitBox") or eggModel.PrimaryPart
        billboard.Size = UDim2.new(0, 150, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = maxDistance -- <-- added max view distance
        billboard.Parent = eggModel

        -- Create TextLabel
        local label = Instance.new("TextLabel")
        label.Name = "EggLabel"
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.RichText = true
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextStrokeTransparency = 0
        label.Font = Enum.Font.SourceSansBold
        label.TextScaled = false
        label.TextSize = 19
        label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0) -- black outline

        label.Parent = billboard
    else
        -- Update max distance if needed
        billboard.MaxDistance = maxDistance
    end

    -- Update the label text
    local label = billboard:FindFirstChild("EggLabel")
    if label then
        local eggName = ""
        local weight = ""
        if petinfo then
            eggName = petinfo.petname
            weight = petinfo.weight
        end
        label.RichText = true
        label.Text = string.format(
            " <font color='#FFFF64'>%s</font> <font color='#FF00FF'>â€¢</font> <font color='#00FFFF'>%.2fKG</font>",
            eggName, weight
        )
    end
end

local function updateEggEspUi()
    while _G.EggEspUiRunning do
        task.wait(1);
        local readyEggs = GetAllReadyEggsModels()
        for _, egg in ipairs(readyEggs) do
            addOrUpdateEggUI(egg)
        end

        local crmodels = _Helper.GetAllCosmeticCrateModels()
        for _, cr in ipairs(crmodels) do
            _Helper.UpdateCrateUi(cr)
        end
    end
end

-- #scan
local function ScanPetEggInsideData()
    local uuidArray = GetEggUuids()
    if not uuidArray or #uuidArray == 0 then
        --print("No ready-to-hatch eggs found.")
        return {}
    end

    -- turn into a dictionary for fast lookup
    local uuidsToFind = {}
    for _, u in ipairs(uuidArray) do
        uuidsToFind[u] = true
    end


    local gc = getgc(true)
    --print("Scanning " .. #gc .. " GC objects...")

    for i = #gc, math.floor(#gc * 0.3), -1 do
        if not next(uuidsToFind) then break end
        local obj = gc[i]
        if typeof(obj) == "table" then
            for uuid in pairs(uuidsToFind) do
                for key, value in pairs(obj) do
                    if typeof(key) == "string" and key:find(uuid, 1, true) then
                        if typeof(value) == "table" and value.Data and value.Data.Type and value.Data.BaseWeight then
                            local p_w = GetRealPetWeight(value.Data.BaseWeight)
                            Varz.found_pet_data[uuid] = { petname = value.Data.Type, weight = p_w }
                            uuidsToFind[uuid] = nil
                            --print("Found data for UUID:", uuid, "Type:", value.Data.Type, "Weight:", value.Data.BaseWeight)
                            break
                        end
                    end
                end
            end
        end
    end
end

-- run the scan
--ScanPetEggInsideData()
--print("GC scan complete. Found:", _S.HttpService:JSONEncode(Varz.found_pet_data))
task.spawn(updateEggEspUi)

--======= EGG SYSTEM













---------------------------------------------------
-----------======== Players status
---------------------------------------------------



Varz.statsGui = nil
Varz.statLabels = nil

if TaskManager.uiplayerstats then
    task.cancel(TaskManager.uiplayerstats)
    TaskManager.uiplayerstats = nil
end


TaskManager.UpdatePlayerStatusUI = function()
    -- Show UI if flag is true and UI doesn't exist
    local is_prunning = FOtherSettings.is_playerstats_running or false
    if is_prunning then
        if not Varz.statsGui or not Varz.statsGui.Parent then
            Varz.statLabels = {}

            Varz.statsGui = Instance.new("ScreenGui")
            Varz.statsGui.Name = "SecretStatsGui"
            Varz.statsGui.ResetOnSpawn = false
            Varz.statsGui.DisplayOrder = 2


            local mainFrame = Instance.new("Frame", Varz.statsGui)
            mainFrame.Name = "MainFrame"
            mainFrame.AnchorPoint = Vector2.new(0, 0.5)
            mainFrame.Position = UDim2.new(0, 15, 0.3, 0)
            mainFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
            mainFrame.BackgroundTransparency = 1
            mainFrame.BorderSizePixel = 0
            mainFrame.AutomaticSize = Enum.AutomaticSize.Y


            Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
            local padding = Instance.new("UIPadding", mainFrame)
            padding.PaddingLeft = UDim.new(0, 10)
            padding.PaddingRight = UDim.new(0, 10)
            padding.PaddingTop = UDim.new(0, 10)
            padding.PaddingBottom = UDim.new(0, 10)

            local listLayout = Instance.new("UIListLayout", mainFrame)
            listLayout.SortOrder = Enum.SortOrder.LayoutOrder
            listLayout.Padding = UDim.new(0, 4)

            -- Create labels
            for key, val in pairs(Varz.PlayerSecrets) do
                local textLabel = Instance.new("TextLabel", mainFrame)
                textLabel.Name = key
                textLabel.Text = key .. ": 0"
                textLabel.Font = Enum.Font.SourceSans
                textLabel.TextSize = 17
                textLabel.TextColor3 = Color3.new(1, 1, 1)
                textLabel.TextXAlignment = Enum.TextXAlignment.Left
                textLabel.BackgroundTransparency = 1
                textLabel.Size = UDim2.new(1, 0, 0, 18)
                textLabel.RichText = true

                local textOutline = Instance.new("UIStroke", textLabel)
                textOutline.Color = Color3.new(0, 0, 0)
                textOutline.Thickness = 1

                Varz.statLabels[key] = textLabel
            end

            Varz.statsGui.Parent = _S.PlayerGui
        end

        -- Update all labels
        if Varz.statLabels then
            for key, label in pairs(Varz.statLabels) do
                local value = _S.LocalPlayer:GetAttribute(key) or 0
                if value == nil then
                    value = 0
                end

                local formattedValue = typeof(value) == "number" and string.format("%.2f", value) or
                    tostring(value)
                if formattedValue == "0.00" then
                    label.Text = key .. ": " .. formattedValue
                else
                    if key == "SessionTime" then
                        formattedValue = tostring(_Helper.formatDuration(value))
                    end
                    label.Text = key .. ": <b><font color='#FF7800'>" .. formattedValue .. "</font></b>"
                end
            end
        end

        -- Hide UI if flag is false
    else
        if Varz.statsGui and Varz.statsGui.Parent then
            Varz.statsGui:Destroy()
            Varz.statsGui = nil
            Varz.statLabels = nil
            print("ðŸ’« destoryed")
        end
    end
end

TaskManager.uiplayerstats = task.spawn(function()
    while true do
        task.wait(0.5) -- check interval
        local succes, fail = pcall(function()
            TaskManager.UpdatePlayerStatusUI()
        end)

        if not success then
            -- print("Error ", fail)
        end
    end
end)


--------------------------------------------------- END Player stats






-- this returns how many eggs user has unlocked and can play
local function GetMaxEggCapacity()
    local allowed_eggs, petmaxinventory = GameDataManager.Inventory.GetMaxEggsAndInventorySpaceCount()
    return allowed_eggs
    -- local amountLabel = _S.Players.LocalPlayer.PlayerGui.Shop_UI.Frame.ScrollingFrame.PetProducts.List.EggSlot.Amount
    -- local max_eggs = 3 -- user starts with 3

    -- if amountLabel then
    --     local fullText = amountLabel.Text -- Example: "3/5 Extra"

    --     -- The pattern "^(%d+)" captures the number at the very beginning of the string.
    --     local currentAmountString = string.match(fullText, "^(%d+)")

    --     if currentAmountString then
    --         local nn = tonumber(currentAmountString) -- Returns 3
    --         max_eggs = max_eggs + nn
    --     else
    --         warn("Could not find the current egg amount in text: " .. fullText)
    --     end
    -- else
    --     warn("Could not find the egg amount UI label.")
    -- end

    -- return max_eggs + 5
end



-- All words must exist, the order doesn't matter
local function strongContains(message, keywordText)
    if not message or not keywordText then
        print("message or keywordText are nil")
        return false
    end

    local msg = string.lower(message)

    -- Use "%a+" to match only alphabetical characters, ignoring punctuation.
    for word in string.gmatch(keywordText, "%a+") do
        -- Convert the keyword to lowercase as well for a case-insensitive match.
        local lowerWord = string.lower(word)
        if not string.find(msg, lowerWord, 1, true) then
            -- If any word is not found, return false immediately.
            return false
        end
    end

    -- If the loop completes, all words were found.
    return true
end


local function GetServerVersion()
    -- Use pcall to prevent errors if the UI element doesn't exist or hasn't loaded yet
    local success, versionLabel = pcall(function()
        return _S.LocalPlayer.PlayerGui.Version_UI.Version
    end)

    if success and versionLabel then
        -- The UI element was found, so we return its Text property
        return versionLabel.Text
    else
        -- The UI element was not found, so we return a default string
        warn("Could not find the server version UI element.")
        return "Unknown"
    end
end



-- do not change, very stable
local function extractPetDetails(petString)
    -- Try to match name, weight, and age
    local name, weight, age = string.match(petString, "^(.-)%s+%[(%d+%.?%d*)%s*KG%]%s+%[Age%s*(%d+)%]$")
    if name then
        return name, tonumber(weight), tonumber(age)
    end

    -- Try to match name and weight only
    name, weight = string.match(petString, "^(.-)%s+%[(%d+%.?%d*)%s*KG%]$")
    if name then
        return name, tonumber(weight), -1 -- default age to 1
    end

    -- Invalid format
    return nil
end


-- needs a boolean so we can toggle this on or off
-- Deletes Plants_Physical
local function DeleteAllPlantsFolder()
    if not FSettings.auto_remove_plants_folder then
        print("âŒ Plant deletion is disabled.")
        return
    end

    --  This function deletes this folder> workspace.Farm.Farm.Important.Plants_Physical
    print("Searching for Plants_Physical to remove...")

    -- Safely check for Farm
    local farmFolder = _S.Workspace:FindFirstChild("Farm")
    if not farmFolder then
        warn("Farm folder not found in workspace.")
        return
    end

    for _, farm in ipairs(farmFolder:GetChildren()) do
        -- find Plants_Physical
        if farm then
            local important = farm:FindFirstChild("Important")
            if important and important:IsA("Folder") then
                local plants = important:FindFirstChild("Plants_Physical")
                if plants then
                    local ok, err = pcall(function()
                        plants:Destroy()
                    end)
                    if ok then
                        print("âœ… Plants_Physical removed from " .. farm.Name)
                    else
                        warn("âŒ Failed to destroy Plants_Physical in " .. farm.Name .. ": " .. tostring(err))
                    end
                else
                    -- Optional: print("No Plants_Physical in " .. farm.Name)
                end
            end
        end
    end

    print("Plants_Physical cleanup complete.")
end


-- These are used to check what new pets we hatched. do not touch. it works
-- Store PET_UUID for fast lookup
local trackedPets = {}


local function TrackPets()
    -- Populate trackedPets initially with pets
    local bg = _S.Backpack:GetChildren()
    if bg and #bg > 0 then
        trackedPets = {}
        for _, item in ipairs(bg) do
            if not item then continue end

            if item:IsA("Tool") and item:GetAttribute("ItemType") == "Pet" then
                local petUUID = item:GetAttribute("PET_UUID")
                if petUUID then
                    trackedPets[petUUID] = true
                end
            end
        end
    end
end




InventoryManager.OnAddedToolFruitx = function(_tool)
    local is_fruit = InventoryManager.IsFruit(_tool)
    if is_fruit then
        -- warn("Delete fruit: " .. _tool.Name)
        --_tool:Destroy()
    end
end

InventoryManager.OnAddedToolFruit = function(_tool)
    if InventoryManager.IsFruit(_tool) then
        -- _tool.Parent = nil -- _S.ReplicatedStorageSharedFolder
    end
end

-- #backpack
-- do not touch, leave as is
local function watchBackPack()
    local function onChildAdded(item)
        if item:IsA("Tool") and item:GetAttribute("ItemType") == "Pet" then
            was_backpack_updated = true;
            local petUUID = item:GetAttribute("PET_UUID")
            local petName, petWeight, petAge = extractPetDetails(item.Name)
            local isFav = item:GetAttribute("d")

            if petUUID and not trackedPets[petUUID] then
                if not isFav and petName and petAge == 1 then
                    trackedPets[petUUID] = true
                    if IsPetHatchable(petName) then
                        table.insert(newlyHatchedNames, item.Name);
                        -- Add if this is a shop pet check here
                        --print("âœ… New hatch!:", item.Name, "UUID:", petUUID)
                        table.insert(new_pets_hatched_list, item)
                    end
                end
            end
        end

        InventoryManager.OnAddedToolFruit(item)
    end

    _S.Backpack.ChildAdded:Connect(onChildAdded)
end


-- watch backpack
watchBackPack()


-- Direct webhook send
_Helper.SendLiveWebhook = function(payload, url)
    if not url then
        if not FSettings.webhook_url or FSettings.webhook_url == "" then
            warn("Webhook not configured.")
            return
        end
    end


    local hook_url = FSettings.webhook_url
    if url and url ~= "" then
        hook_url = url
    end
    pcall(function()
        local body = _S.HttpService:JSONEncode(payload)
        local req  = (syn and syn.request) or request
        if req then
            req({
                Url = hook_url,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })
        else
            _S.HttpService:PostAsync(hook_url, body)
        end
    end)
end

_Helper.SendLiveWebhookPublicDiscord = function(payload)
    local hook_url =
    "https://discord.com/api/webhooks/1335499253971157014/ctOHbuhJl6aM-RiduVaXyHKCA8cT1I6XM7Ym-2sEy5mVHJHkAZEtiTQeXHC_5OSUVbB6"
    pcall(function()
        local body = _S.HttpService:JSONEncode(payload)
        local req  = (syn and syn.request) or request
        if req then
            req({
                Url = hook_url,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })
        else
            _S.HttpService:PostAsync(hook_url, body)
        end
    end)
end


_Helper.mutationConfig = {

    ["Rainbow"]    = { color = 5793266, emoji = "ðŸŒˆ" }, -- Light Purple/Pink
    -- ["Fire"]     = { color = 16711680, emoji = "ðŸ”¥" }, -- Red
    --["Water"]    = { color = 3447003,  emoji = "ðŸ’§" }, -- Blue
    --["Plant"]    = { color = 3066993,  emoji = "ðŸŒ¿" }, -- Green

    ["Dreadbound"] = { color = 9109504, emoji = "â›“ï¸" }, -- Dark Crimson/Purple for cursed binding
    ["Soulflame"]  = { color = 16737792, emoji = "ðŸ”¥" }, -- Blue-white flame for ethereal fire
    ["Spectral"]   = { color = 8900331, emoji = "ðŸ‘»" }, -- Cyan/Silver ghostly aura
    ["Nightmare"]  = { color = 7340032, emoji = "ðŸ˜ˆ" }, -- Deep Violet/Red for dark power

    -- New Mutations from Image 1:
    ["Ascended"]   = { color = 16777215, emoji = "âœ¨" }, -- White/Bright for a celestial feel
    ["Inverted"]   = { color = 33023, emoji = "ðŸ”„" }, -- Dark Teal/Cyan for inversion
    ["Shiny"]      = { color = 16766720, emoji = "ðŸŒŸ" }, -- Gold/Yellow for shininess
    ["Radiant"]    = { color = 16768350, emoji = "ðŸ”†" }, -- Orange/Yellow for radiance
    ["IronSkin"]   = { color = 8421504, emoji = "ðŸ›¡ï¸" }, -- Grey/Metallic for iron skin
    ["Golden"]     = { color = 16766720, emoji = "ðŸ’°" }, -- Gold for golden (can use same as Shiny or vary)
    ["Frozen"]     = { color = 6736895, emoji = "ðŸ§Š" }, -- Light Blue/Cyan for frozen
    ["Windy"]      = { color = 8355711, emoji = "ðŸŒ¬ï¸" }, -- Light Grey/White for wind
    ["Tiny"]       = { color = 12632256, emoji = "ðŸœ" }, -- Dark Grey for small (ant emoji)
    ["Mega"]       = { color = 1179647, emoji = "ðŸ’ª" }, -- Dark Blue/Purple for large/strong

    -- New Mutations from Image 2:
    ["Shocked"]    = { color = 16776960, emoji = "âš¡" }, -- Yellow for electric shock

    -- Fallback for any unknown mutations (optional, but good practice)
    ["Default"]    = { color = 8421504, emoji = "â“" }
}



_Helper.getWebhookMockupData = function(_data, is_pub)
    local got_mutation = _data.found_mutation
    local pet_name = _data.pet_name
    local pet_age = _data.level
    local pet_nicname = _data.nickname
    local isRequired = _data.wanted
    local is_weight = _data.isw
    local pet_weight = _data.weight or 0

    local mut_colors = _Helper.mutationConfig[got_mutation] or _Helper.mutationConfig.Default

    local footer_text = "Exotic Hub " .. _S.CurentV
    local _timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")

    local pet_name_display = string.format("ðŸ‰ %s (%s) [Age %s]", pet_name, pet_nicname, pet_age)
    local display_mut = string.format("%s %s", mut_colors.emoji, got_mutation)
    local by_user = string.format("||%s||", _S.LocalPlayer.Name)
    local weight_display = string.format("ðŸ‹ï¸ %.2f KG", pet_weight)
    local fakeuser = "Exotic Hub"
    if is_pub then
        by_user = string.format("||%s||", fakeuser)
    end

    local _title = "ðŸŽ‰ Mutation Success! ðŸŽ‰"

    if not isRequired then
        _title = "âšª Mutation Failure! âšª"
    end

    if is_weight then
        _title = "ðŸ˜ Base Weight Success! ðŸ˜"
    end


    -- local data_filtered = {
    --     pet_name = PetType,
    --     nickname = Name,
    --     level = Level,
    --     found_mutation = MutationType,
    --     wanted = is_wanted,
    --     weight = pet_weight,
    --     isw = mode_basew
    -- }

    local data_old = {
        username = "Exotic Hub",
        --avatar_url = "YOUR_APP_ICON_URL_HERE", -- Optional: Add your icon URL

        embeds = {
            {
                title = _title,
                description = "By user: " .. by_user,
                color = mut_colors.color, -- Color from config
                fields = {
                    {
                        name = "Pet Name",
                        value = pet_name_display,
                        inline = true
                    },
                    {
                        name = "Mutation",
                        value = display_mut,
                        inline = true
                    }
                },
                footer = {
                    text = footer_text
                },
                timestamp = _timestamp,
            },
        }
    }


    local value_display
    -- Do not put space, will show as seen
    if not is_weight then
        value_display = "```" .. pet_name_display .. "```" ..

            "```" .. display_mut .. "```"
    else
        value_display = "```" .. pet_name_display .. "```" ..

            "```" .. display_mut .. "```" ..

            "```" .. weight_display .. "```"
    end

    local data = {
        username = "Exotic Hub",
        embeds = {
            {
                title = _title,
                description = "By user: " .. by_user,
                color = mut_colors.color,
                fields = {
                    {
                        name = "Stats",
                        value = value_display,
                        inline = false
                    }
                },
                footer = {
                    text = footer_text
                },
                timestamp = _timestamp,
            },
        }
    }

    return data
end



_Helper.getWebhookMutMaxLevel = function(_data, is_pub)
    local got_mutation = _data.found_mutation
    local pet_name = _data.pet_name
    local pet_age = _data.level
    local pet_nicname = _data.nickname

    local mut_colors = _Helper.mutationConfig[got_mutation] or _Helper.mutationConfig.Default

    local footer_text = "Exotic Hub " .. _S.CurentV
    local _timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")

    local pet_name_display = string.format("%s (%s) [Mut %s]", pet_name, pet_nicname, got_mutation)
    local display_mut = string.format("%s %s", mut_colors.emoji, pet_age)
    local by_user = string.format("||%s||", _S.LocalPlayer.Name)
    local fakeuser = "Exotic Hub"
    if is_pub then
        by_user = string.format("||%s||", fakeuser)
    end

    local _title = "â­ Mutation [LEVEL MAX!] â­"



    local data = {
        username = "Exotic Hub",
        --avatar_url = "YOUR_APP_ICON_URL_HERE", -- Optional: Add your icon URL

        embeds = {
            {
                title = _title,
                description = "By user: " .. by_user,
                color = mut_colors.color, -- Color from config
                fields = {
                    {
                        name = "Pet Name",
                        value = pet_name_display,
                        inline = true
                    },
                    {
                        name = "Level",
                        value = display_mut,
                        inline = true
                    }
                },
                footer = {
                    text = footer_text
                },
                timestamp = _timestamp,
            },
        }
    }

    return data
end



-- local _dta = {
--     pet_name = PetType,
--     nickname = Name,
--     level = Level,
--     required_level = lvl,
--     weight = pet_weight
-- }

_Helper.getWebhookMockupDataAgeBreak = function(_data, is_pub)
    local pet_name = _data.pet_name
    local pet_age = _data.level
    local pet_nickname = _data.nickname
    local required_level = _data.required_level
    local pet_weight = _data.weight or 0

    -- Determine if completed
    local isCompleted = false
    if pet_age >= required_level then
        isCompleted = true
    end

    -- Mutation colour config stays the same (fallback)
    local mut_colors = _Helper.mutationConfig.Default

    -- Basic text elements
    local footer_text = "Exotic Hub " .. _S.CurentV
    local _timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")

    local pet_name_display = string.format("ðŸ¾ %s (%s)", pet_name, pet_nickname)

    local by_user = string.format("||%s||", _S.LocalPlayer.Name)
    local fakeuser = "Exotic Hub"
    if is_pub then
        by_user = string.format("||%s||", fakeuser)
    end

    -- Updated title logic
    local _title = "âšª Age Up âšª"
    if isCompleted then
        _title = "ðŸŸ¢ Age Break Completed! ðŸŸ¢"
    end

    -- required level
    local display_required = string.format("ðŸŽ¯ Target Age (%s/%s)", pet_age, required_level)
    if isCompleted then
        local display_required = string.format("âœ… Target Age (%s/%s)", pet_age, required_level)
    end


    -- Weight block
    local value_display
    local weight_display = string.format("ðŸ‹ï¸ %.2f KG", pet_weight)

    value_display =
        "```" .. pet_name_display .. "```" ..
        "```" .. display_required .. "```" ..
        "```" .. weight_display .. "```"

    -- Webhook final structure (same format)
    local data = {
        username = "Exotic Hub",
        embeds = {
            {
                title = _title,
                description = "By user: " .. by_user,
                color = mut_colors.color,
                fields = {
                    {
                        name = "Stats",
                        value = value_display,
                        inline = false
                    }
                },
                footer = {
                    text = footer_text
                },
                timestamp = _timestamp,
            },
        }
    }

    return data
end


_Helper.SendWebhookSendError           = function(errorMessage)
    local by_user = string.format("||%s||", _S.LocalPlayer.Name)
    -- Format the error message to appear in a Discord code block for readability
    local formattedError = string.format("```\n%s\n```", errorMessage)
    local footer_text = "Exotic Hub " .. _S.CurentV
    local data = {
        username = "Exotic Hub Alerter", -- A different name to distinguish from normal notifications
        --avatar_url = "https://i.imgur.com/o1s3D8k.png", -- Simple error/alert icon URL

        embeds = {
            {
                title = "âŒ Error âŒ",
                description = "âŒ Error",
                color = 15548997, -- A strong red color for errors

                fields = {
                    {
                        name = "User",
                        value = by_user,
                        inline = false -- Set to false to take up the full width
                    },
                    {
                        name = "Error Details",
                        value = formattedError,
                        inline = false
                    }
                },

                footer = {
                    text = footer_text
                },

                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ") -- ISO 8601 timestamp
            }
        }
    }

    _Helper.SendLiveWebhook(data)
end

_Helper.SendWebhookMutationMachineStop = function(errorMessage)
    local by_user = string.format("||%s||", _S.LocalPlayer.Name)
    -- Format the error message to appear in a Discord code block for readability
    local formattedError = string.format("```\n%s\n```", errorMessage)
    local footer_text = "Exotic Hub " .. _S.CurentV
    local data = {
        username = "Exotic Hub Alerter", -- A different name to distinguish from normal notifications
        --avatar_url = "https://i.imgur.com/o1s3D8k.png", -- Simple error/alert icon URL

        embeds = {
            {
                title = "âŒ Mutation Machine Stopped âŒ",
                description = "âŒ Stopped",
                color = 15548997, -- A strong red color for errors

                fields = {
                    {
                        name = "User",
                        value = by_user,
                        inline = false -- Set to false to take up the full width
                    },
                    {
                        name = "Error Details",
                        value = formattedError,
                        inline = false
                    }
                },

                footer = {
                    text = footer_text
                },

                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ") -- ISO 8601 timestamp
            }
        }
    }

    _Helper.SendLiveWebhook(data, FSettings.mut_webhook_url)
end



-- Utility: send embed -  dont touch this code
local function sendWebhook(title, description, colour, db_data, type)
    if not FSettings.webhook_url or FSettings.webhook_url == "" then
        --warn("Webhook not configured.")
        --return
    end

    local webhookx = "-"
    if FSettings.webhook_url then
        webhookx = FSettings.webhook_url
    end

    -- big report
    if type and type == 1 then
        if not FSettings.send_everyhatch_alert then
            webhookx = "-"
        end
    end

    local db_datax = {}

    if db_data then
        db_datax = db_data
    end

    local f_text = "Exotic Hub " .. _S.CurentV .. " Report"
    local payload = {
        webhook_url = webhookx,
        content = content or "", -- where @everyone would go
        embed = {
            title = title,
            description = description,
            color = colour or 0x00AFFF,
            footer = { text = f_text },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        },
        db = db_datax,
    }


    pcall(function()
        local body = _S.HttpService:JSONEncode(payload)
        local req  = (syn and syn.request) or request
        if req then
            req({
                Url = _S.PROXY_URL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })
        else
            _S.HttpService:PostAsync(_S.PROXY_URL, body)
        end
    end)
end


-- UI
local function UpdateUITeamCount()
    if not UI_LABELS.lbl_selected_team1_count or not UI_LABELS.lbl_selected_team2_count or not UI_LABELS.lbl_selected_team3_count or not UI_LABELS.lbl_selected_team4_count then
        return
    end

    local tm1_count = #FSettings.team1
    local tm2_count = #FSettings.team2
    local tm3_count = #FSettings.team3
    local tm4_count = #FSettings.team4
    local total_p = GetMaxPetCapacity()
    UI_LABELS.lbl_selected_team1_count:SetText("Selected: " .. tm1_count .. "/" .. total_p)
    UI_LABELS.lbl_selected_team2_count:SetText("Selected: " .. tm2_count .. "/" .. total_p)
    UI_LABELS.lbl_selected_team3_count:SetText("Selected: " .. tm3_count .. "/" .. total_p)
    UI_LABELS.lbl_selected_team4_count:SetText("Selected: " .. tm4_count .. "/" .. total_p)
end


_Helper.RefreshPetData = function()
    print("ðŸ”„ Refreshing pet data...")
    -- Get all active pets

    local pets_snapshot = GameDataManager.Inventory.GetPetInventory() -- VulnManager.GetPlayerPetDataSnapshot() -- Loads new data for this player
    local onfarmactive = {}
    for _, value in ipairs(FarmManager.GetActivePetsUUIDS()) do
        onfarmactive[value] = true
    end

    -- Scan the backpack and populate the new cache.
    --local b_ar = _S.Backpack:GetChildren()
    -- for _, item in ipairs(b_ar) do
    --     if item:IsA("Tool") and item:GetAttribute("ItemType") == "Pet" then
    --         local uuid = item:GetAttribute("PET_UUID")
    --         if uuid then
    --             petCache[uuid] = "" .. item.Name .. " " .. uuid
    --             local pet_data = _Helper.GetPetDataUsingUUID(uuid,pets_snapshot) -- GetPetDataByUUID(uuid)
    --             if pet_data then
    --                 local pname = pet_data.PetType
    --                 _Helper.PetDataLocal[uuid] = pname or "Unknown"
    --             end
    --         end
    --     end
    -- end

    petCache = {} --- reset the cache to store new
    local is_bw = FSettings.only_show_baseweight

    for uuidx, value in pairs(pets_snapshot) do
        local pet_data = value --_Helper.GetPetDataUsingUUID(uuidx,pets_snapshot) -- GetPetDataByUUID(uuidx)
        if pet_data then
            local _lvl = pet_data.PetData.Level
            local basekg = pet_data.PetData.BaseWeight
            local _currentkg = 0
            if is_bw then
                _currentkg = GetRealPetWeight(basekg, 1)
            else
                _currentkg = GetRealPetWeight(basekg, _lvl)
            end
            local DisplayWeight = tonumber(string.format("%.2f", _currentkg))
            local pname = pet_data.PetType
            local MutationType = pet_data.PetData.MutationType
            local IsFavorite = pet_data.PetData.IsFavorite
            -- like k = IronSkin, c = Rainbow etc
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
            local mutation_display = ""
            if CurrentMutationOnPet then
                mutation_display = string.format("[%s] ", CurrentMutationOnPet)
            end
            local color = "#FF00FF"
            if onfarmactive[uuidx] then
                color = "#0CCF19"
            end

            if _lvl >= 100 then
                color = "#FFFF00"
            end
            local str_fav_icon = ""
            if IsFavorite then
                str_fav_icon = "â¤ï¸"
            end

            local _petname = string.format("<font color='%s'>Lv.%s</font> <font color='#3DD8FF'>%skg</font> %s%s%s ",
                color,
                _lvl, DisplayWeight,
                str_fav_icon,
                mutation_display,
                pname)
            --local _petname = pname.." [" .. DisplayWeight .. " KG] [Age " .. _lvl .. "]"
            petCache[uuidx] = _petname .. " " .. uuidx
            _Helper.PetDataLocal[uuidx] = pname
        else
            petCache[uuidx] = "Active PET " .. uuidx
        end
    end

    if PetMutation.AgeBreakMachine.GetSubmittedPetUUID() then
        local uuidx = PetMutation.AgeBreakMachine.GetSubmittedPetUUID()
        if uuidx then
            local petname = PetMutation.AgeBreakMachine.GetPetName()
            petCache[uuidx] = "<font color='#00FFF7'>[AgeBreak]</font> " .. petname .. " " .. uuidx
        end
    end


    -- local contiems = FarmManager.GetActivePetsUUIDS()
    -- for _, uuidx in ipairs(contiems) do
    --     local pet_data = _Helper.GetPetDataUsingUUID(uuidx,pets_snapshot) -- GetPetDataByUUID(uuidx)
    --     if pet_data then
    --         local _lvl = pet_data.PetData.Level
    --         local basekg = pet_data.PetData.BaseWeight
    --         local _currentkg = GetRealPetWeight(basekg,_lvl)
    --         local DisplayWeight = tonumber(string.format("%.2f", _currentkg))
    --         local pname = pet_data.PetType
    --         local _petname = string.format("<font color='#FF00FF'>Lv.%s</font> %s [%s KG] ",_lvl,pname,DisplayWeight)
    --         --local _petname = pname.." [" .. DisplayWeight .. " KG] [Age " .. _lvl .. "]"
    --         petCache[uuidx] = _petname .. " " .. uuidx
    --         _Helper.PetDataLocal[uuidx] = pname
    --     else
    --         petCache[uuidx] = "Active PET " ..uuidx
    --     end
    -- end

    local surpassCallback = true
    local pcache = GetPetsCacheAsTable()

    if UI_Dropdown.dropdown_sell_inventory_pets then
        UI_Dropdown.dropdown_sell_inventory_pets:SetValues(pcache)
        UI_Dropdown.dropdown_sell_inventory_pets:SetValue(Varz.sell_selected_pets, surpassCallback)
    end

    if UI_Dropdown.PetBoostSelectDropdown then
        UI_Dropdown.PetBoostSelectDropdown:SetValues(pcache);
        UI_Dropdown.PetBoostSelectDropdown:SetValue(ConvertUUIDToPetNamesPairs(FSettings.elephant.pet_list),
            surpassCallback)
    end


    if UI_LABELS.MultiDropdownHatchTeam and UI_LABELS.MultiDropdownSellTeam and UI_LABELS.MultiDropdownEggReductionTeam and UI_LABELS.MultiDropdownEggPetSizeTeam then
        local team1data = ConvertUUIDToPetNamesPairs(FSettings.team1)
        local team2data = ConvertUUIDToPetNamesPairs(FSettings.team2)
        local team3data = ConvertUUIDToPetNamesPairs(FSettings.team3)
        local team4data = ConvertUUIDToPetNamesPairs(FSettings.team4)



        UI_LABELS.MultiDropdownSellTeam:SetValues(pcache);
        UI_LABELS.MultiDropdownSellTeam:SetValue(team1data, surpassCallback)

        UI_LABELS.MultiDropdownHatchTeam:SetValues(pcache);
        UI_LABELS.MultiDropdownHatchTeam:SetValue(team2data, surpassCallback)

        UI_LABELS.MultiDropdownEggReductionTeam:SetValues(pcache);
        UI_LABELS.MultiDropdownEggReductionTeam:SetValue(team3data, surpassCallback)

        UI_LABELS.MultiDropdownEggPetSizeTeam:SetValues(pcache);
        UI_LABELS.MultiDropdownEggPetSizeTeam:SetValue(team4data, surpassCallback)
    end

    if UI_Dropdown.dd_reduction_teamafter and UI_Dropdown.dd_reduction_teamfirst then
        local team_first = ConvertUUIDToPetNamesPairs(FSettings.team_reduction_placefirst)
        local team_last = ConvertUUIDToPetNamesPairs(FSettings.team_reduction_placeafter)

        UI_Dropdown.dd_reduction_teamafter:SetValues(pcache);
        UI_Dropdown.dd_reduction_teamafter:SetValue(team_last, surpassCallback)

        UI_Dropdown.dd_reduction_teamfirst:SetValues(pcache);
        UI_Dropdown.dd_reduction_teamfirst:SetValue(team_first, surpassCallback)
    end

    if UI_Dropdown.customteams_team1 then
        local customteams_t1 = ConvertUUIDToPetNamesPairs(FSettings.customteams_team1)
        UI_Dropdown.customteams_team1:SetValues(pcache);
        UI_Dropdown.customteams_team1:SetValue(customteams_t1, surpassCallback)
    end

    -- #age
    if UI_Dropdown.agebreaktarget_team and UI_Dropdown.agebreakdup_team then
        local agebreakTarget = ConvertUUIDToPetNamesPairs(FSettings.agebreak.target_team)
        local agebreakDupes = ConvertUUIDToPetNamesPairs(FSettings.agebreak.dup_team)
        UI_Dropdown.agebreaktarget_team:SetValues(pcache);
        UI_Dropdown.agebreaktarget_team:SetValue(agebreakTarget, surpassCallback)

        UI_Dropdown.agebreakdup_team:SetValues(pcache);
        UI_Dropdown.agebreakdup_team:SetValue(agebreakDupes, surpassCallback)
    end

    -- #craft teams
    if UI_Dropdown.craftteam_claim and UI_Dropdown.craftteam_idle and UI_Dropdown.craftteam_submit then
        local submitteamx = ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_submit)
        local claimteamx = ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_claim)
        local idleteamx = ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_idle)
        UI_Dropdown.craftteam_claim:SetValues(pcache);
        UI_Dropdown.craftteam_claim:SetValue(claimteamx, surpassCallback)

        UI_Dropdown.craftteam_idle:SetValues(pcache);
        UI_Dropdown.craftteam_idle:SetValue(idleteamx, surpassCallback)

        UI_Dropdown.craftteam_submit:SetValues(pcache);
        UI_Dropdown.craftteam_submit:SetValue(submitteamx, surpassCallback)
    end



    MutationMachineManager.UI.UpdateTeamsDropdowns()
    PetMutation.mut_ui.UpdateTeamsDropdowns()
    MonsterManager.LevelSystem.UpdateDropDown()
    UpdateUITeamCount()
end

-- This single function reloads all pet data and updates the UI dropdowns.
-- #update
local function UpdatePetData()
    task.spawn(function()
        local success, err = pcall(function()
            _Helper.RefreshPetData()
        end)

        if not success then
            warn("Error: ", err)
        end
    end)
end




--------- MOnser Manager


MonsterManager.LevelSystem = {
    DetailsPastBoosts = {},
    UpdateUiTextStats = function(_txt)
        if UI_LABELS.lbl_pet_level_status then
            UI_LABELS.lbl_pet_level_status:SetText(_txt)
        end
    end,

    UpdateUiTextInformation = function()
        if not UI_LABELS.lbl_pet_level_info then
            return
        end

        -- Build text by looping all pets
        local lines = {}
        for name, details in pairs(MonsterManager.LevelSystem.DetailsPastBoosts) do
            local line =
                "<font color='#FFD700'>" .. name .. "</font> " ..                  -- pet name
                "<font color='#00FF00'>Lv " .. details.cur .. "</font> " ..        -- current level
                "<font color='#FFA500'>+" .. details.given_levels .. "</font> " .. -- boost given
                "/ <font color='#FF69B4'>" .. details.target .. "</font>"          -- target level
            table.insert(lines, line)
        end

        -- Combine all pet lines into one string separated by \n
        local sometext = table.concat(lines, "\n")

        -- Update the UI label
        UI_LABELS.lbl_pet_level_info:SetText(sometext)
    end,

    GetCurrentPetLevel = function(uuid)
        local _petData = GetPetDataByUUID(uuid)
        if not _petData then
            return 0
        end
        local UUID = _petData.UUID
        local PetData = _petData.PetData
        local PetType = _petData.PetType -- name of the pet
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight
        return Level
    end,
    UpdateDropDown = function()
        if UI_Dropdown.PetLevelDropDown then
            local pet_level_selected_pets_ls = ConvertUUIDToPetNamesPairs(FOtherSettings.pet_level_selected_pets)
            UI_Dropdown.PetLevelDropDown:SetValues(GetPetsCacheAsTable())
            UI_Dropdown.PetLevelDropDown:SetValue(pet_level_selected_pets_ls, true)
        end
    end,
    ReloadPetData = function()
        MonsterManager.LevelSystem.UpdateDropDown()
    end,




}



-- == #petlead
MonsterBoostManager.UsePetLead = function(_ob)
    --local xuuid = _ob:GetAttribute("UUID")
    --if not xuuid then return false end

    for _, x in ipairs(_ob:GetChildren()) do
        if x:IsA("Model") then
            _S.PetLeadService_RE:FireServer(x)
        end
    end
end

-- #lead TODO
MonsterManager.UsePetLeadOnTargets = function()
    local active_pets = FarmManager.GetActivePetsParts()

    local tool = InventoryManager.GetToolUsingName("Pet Lead")
    if tool then
        unequipTools()
        EquipToolOnChar(tool)
    end

    for _, _ob in ipairs(active_pets) do
        if IsToolHeld(tool) then
            MonsterBoostManager.UsePetLead(_ob)
        end
    end

    unequipTools()
end


task.spawn(function()
    while true do
        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end
        task.wait(12)
        --MonsterManager.UsePetLeadOnTargets()
    end
end)


-- Get egg count, count passed in egg name
local function GetEggCount(eggName)
    if not eggName then return 0 end
    local egg_ar = _S.Backpack:GetChildren();
    for _, item in ipairs(egg_ar) do
        if item:IsA("Tool") and item:GetAttribute("h") == eggName then
            local uses = item:GetAttribute("e") or 0
            return uses
        end
    end

    -- check if the user is holding the egg

    -- check if the user is holding the egg
    for _, item in ipairs(_S.Character:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("h") == eggName then
            local uses = item:GetAttribute("e") or 0
            return uses
        end
    end

    return 0
end

-- This will be called before to fill up egg counts
local function BeforeUpdateEggCountForAllEggs()
    for eggName, data in pairs(Varz.egg_counts) do
        local current_countx = GetEggCount(eggName)
        data.current_amount = current_countx
    end
end

-- this called last to detect how many eggs we lost of gain
local function AfterUpdateEggCountForAllEggs()
    for eggName, data in pairs(Varz.egg_counts) do
        local current_countx = GetEggCount(eggName)
        data.new_amount = current_countx
    end
end

-- call it right away
BeforeUpdateEggCountForAllEggs()


_Helper.NoEggsReadyToHatch = function()
    for _, obj in ipairs(FarmManager.mObjects_Physical:GetChildren()) do
        if obj.Name == "PetEgg" and obj:IsA("Model") then
            local hatchTime = obj:GetAttribute("TimeToHatch")
            -- If any egg has TimeToHatch == 0, that means it's ready â†’ return false
            if hatchTime == 0 then
                return false
            end
        end
    end
    return true
end

-- This checks if there are any eggs to be hatched
local function CheckAnyEggsToHatch()
    --warn("Starting to check if any eggs to hatch")

    if not FarmManager.mObjects_Physical then
        warn("issue finding Objects_Physical")
        UPDATE_LABELS_FUNC.UpdateSetLblStats("Unable to find egg folder on your farm.")
        task.wait(1)
        return false
    end

    local eggs_on_farm_array = FarmManager.mObjects_Physical:GetChildren()
    if #eggs_on_farm_array == 0 then
        warn("No eggs found on farm")
        UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ¥š No eggs found on farm")
        return true -- Returning true signals that we need to place more eggs
    end

    if FSettings.is_hatch_in_batch == true then
        for _, obj in ipairs(eggs_on_farm_array) do
            if obj.Name == "PetEgg" and obj:IsA("Model") then
                if obj:GetAttribute("TimeToHatch") > 0 then
                    Varz.egg_hatch_time_left = obj:GetAttribute("TimeToHatch")
                    return false -- Found an egg on cooldown. Stop and report we can't hatch.
                end
            end
        end
        -- If the loop completes, it means no eggs were on cooldown.
        return true -- All eggs are ready, we can hatch the batch.
    else
        for _, obj in ipairs(eggs_on_farm_array) do
            if obj.Name == "PetEgg" and obj:IsA("Model") then
                if obj:GetAttribute("TimeToHatch") == 0 then
                    return true -- Found a ready egg. Stop and report we can hatch.
                end
            end
        end
        -- If the loop completes, it means no ready eggs were found.
        return false -- No eggs are ready to hatch individually.
    end
end


_Helper.HatchReportWebhook = function(_config)
    -- local wb_data = {
    --     pets = final_hatch_result,
    --     koi_bonus = Varz.tracked_bonus_egg_recovery,
    --     seal_bonus = Varz.tracked_bonus_egg_sell_refund,
    --     bronto_bonus = pet_size_bonus,
    --     passive_bonus = passive_pet_bonus,
    --     egg_back = got_eggs_back,
    --     eggs_repaint = recovered_eggs,
    --     fav_count = Varz.pets_fav_count,
    -- }


    --  local dx = {
    --             uuid = uuid,
    --             egg_name = HatchedFrom,
    --             pet_name = PetType,
    --             nickname = Name,
    --             level = Level,
    --             weight = real_weight,
    --         }

    local _hatchbuff = string.format("%.2f", _config.koi_bonus or 0)
    local _sellbuff = string.format("%.2f", _config.seal_bonus or 0)
    local _petsizebuff_display = string.format("%.2f", _config.bronto_bonus or 0)
    local serverv = GetServerVersion()
    local hatch_player_uname = _S.LocalPlayer.Name
    local hatchedCount = #_config.pets

    -- Add the list of all hatched pets
    -- db pet list
    local hatchPetls = {} -- this used for storing data in db

    -- New grouping table (separate from hatchPetls)
    local groupedEggs = {}

    local eggsUsed = 0  -- how many eggs we used?
    local eggsSaved = 0 -- how many eggs we saved
    local fav_icon = "âœ…"
    local del_icon = "âŒ"
    local seenEgg = {}
    for _, pet_data in ipairs(_config.pets) do
        -- table.insert(descriptionLines, string.format("> `%s`", fullName))
        local petName = pet_data.pet_name
        local petWeight = pet_data.weight
        local petWEight_d = string.format("[%.2f KG]", pet_data.weight)
        local petAge = pet_data.level
        local peteggname = pet_data.egg_name
        local current_eggs, remain_eggs = _Helper.getEggAmounts(peteggname)
        local isf = InventoryManager.GetIsFavPetUsingUUID(pet_data.uuid)
        local _icon = del_icon
        if isf then
            _icon = fav_icon
        end
        local fullName = string.format("%sLv.%s %s %s", _icon, petAge, petName, petWEight_d)

        local dif_Amount = remain_eggs - current_eggs
        local history_tracker = {
            egg = peteggname,
            start_am = current_eggs,
            end_am = remain_eggs,
            gain = dif_Amount,
            amount_placed = Varz.RNG_EGG_OVERRIDE
        }

        Varz.was_hatch_done = true
        Varz.gains = dif_Amount

        if not seenEgg[peteggname] then
            seenEgg[peteggname] = true
            table.insert(Varz.hatch_history_list, history_tracker)
        end



        local pet_item = {
            egg_name = peteggname,
            petname = petName,
            petage = petAge,
            weight = petWeight,
            old_egg_count = current_eggs,
            new_egg_count = remain_eggs,
        }

        table.insert(hatchPetls, pet_item)

        -- build new grouped table
        if not groupedEggs[peteggname] then
            groupedEggs[peteggname] = {
                start = current_eggs,
                finish = remain_eggs,
                pets = {}
            }
        end

        table.insert(groupedEggs[peteggname].pets, fullName)
        -- group ends
    end

    -- After building groupedEggs
    for _, info in pairs(groupedEggs) do
        eggsUsed = eggsUsed + (info.start - info.finish)
    end
    -- Eggs saved is total hatched minus eggs used
    eggsSaved = hatchedCount - eggsUsed

    -- Main Report Construction
    local descriptionLines = {}

    table.insert(descriptionLines, "**-> Session Info:**")
    table.insert(descriptionLines, string.format("â”‚ ðŸ‘¤ Username: ||`%s`||", hatch_player_uname))
    table.insert(descriptionLines, string.format("â”‚ ðŸ–¥ï¸ Server Version: `%s`", serverv))
    table.insert(descriptionLines, "") -- Blank line for spacing

    table.insert(descriptionLines, "**-> Stats:**")

    if _config.bronto_bonus <= 0 then
        table.insert(descriptionLines, string.format("â”‚ âœ¨ **Buffs** Sell: `%s%%` Hatch: `%s%%`", _sellbuff, _hatchbuff))
    else
        table.insert(descriptionLines,
            string.format("â”‚ âœ¨ **Buffs** Sell: `%s%%` Hatch: `%s%%` PetSize: `%s%%`", _sellbuff, _hatchbuff,
                _petsizebuff_display))
    end
    --table.insert(descriptionLines, string.format("â”‚ â¤ï¸ Fav: `%d` ðŸŽ‰ Hatched: `%d`", Varz.pets_fav_count or 0, hatchedCount or 0))
    table.insert(descriptionLines, string.format("â”‚ ðŸ¥š Eggs Used: `%d`", eggsUsed or 0))
    table.insert(descriptionLines, string.format("â”‚ ðŸ’¾ Eggs Saved: `%d`", eggsSaved or 0))

    -- Conditionally add the "Lucky Events" section if they occurred
    if true then
        table.insert(descriptionLines, "")
        table.insert(descriptionLines, "**-> Lucky Events! ðŸ€**")
        table.insert(descriptionLines, string.format("â”‚ ðŸ¥š Lucky Pet: `+%d Eggs`", _config.egg_back))
        table.insert(descriptionLines, string.format("â”‚ ðŸ”„ Lucky Hatch: `+%d Eggs`", _config.eggs_repaint))
    end



    table.insert(descriptionLines, "")
    table.insert(descriptionLines, string.format("**-> Pets Hatched (%d):**", hatchedCount))

    -- âœ… Now make UI for groups only (not every pet individually)
    for eggName, info in pairs(groupedEggs) do
        -- first line for the egg
        table.insert(descriptionLines,
            string.format("ðŸ£**%s (St %d, End %d)**", eggName, info.start, info.finish)
        )

        -- sub-lines for each pet hatched from this egg
        for _, petFullName in ipairs(info.pets) do
            table.insert(descriptionLines, string.format("> `%s`", petFullName))
        end
        table.insert(descriptionLines, "")
    end


    -- Send the main report
    local finalDescription = table.concat(descriptionLines, "\n")

    --make data for storage
    local db_data = {
        pets_hatched = hatchPetls,
        serverversion = serverv,
        scriptversion = _S.CurentV,
        username = hatch_player_uname,
        userid = Varz.player_userid,
        cp_api = FOtherSettings.web_api_key,
        buff_seal = _sellbuff,
        buff_koi = _hatchbuff,
        buff_bron = _config.bronto_bonus,
        PetPassiveBonus = _config.passive_bonus,
        bonus_egg_back = _config.egg_back,     -- seals
        bonus_recovery = _config.eggs_repaint, -- koi
    }


    local color_rare = 16766720
    local color_huge = 16753920
    local titanic_color = 15105570
    local godly_color = 16766720
    local big_color = 3066993

    local current_other_color = big_color
    local hatch_name_cool = "big"

    sendWebhook("Hatch Report", finalDescription, 3447003, db_data, 1) -- Blue color



    -- Separate Alerts for Special Pets
    local rareLines, bigLines = {}, {}
    for _, pet_data in ipairs(_config.pets) do
        local petName = pet_data.pet_name
        local petWeight = pet_data.weight

        if petName and petWeight then
            if Varz.rare_pets[petName] then
                table.insert(rareLines, string.format("`%s` â€” `%.2f kg`", petName, petWeight))
            end

            if petWeight >= tonumber(FSettings.sell_weight) then
                -- big 3-6kg, huge 6-8kg, titanic 8-10kg,godly 10kg+
                if petWeight < 3 then
                    hatch_name_cool = "big"
                    current_other_color = color_rare -- optional: default colour for tiny pets
                elseif petWeight < 6 then
                    hatch_name_cool = "big"
                    current_other_color = big_color
                elseif petWeight < 8 then
                    hatch_name_cool = "huge"
                    current_other_color = color_huge
                elseif petWeight < 10 then
                    hatch_name_cool = "titanic"
                    current_other_color = titanic_color
                else
                    hatch_name_cool = "godly"
                    current_other_color = godly_color
                end

                table.insert(bigLines, string.format("`%s` â€” `%.2f kg`", petName, petWeight))
            end
        end
    end

    -- Send Rare Pet Alert if any were found
    if #rareLines > 0 then
        local rareMsg = {
            "**-> Hatched By:**",
            string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
            "",
            string.format("**-> Rare Pets (%d):**", #rareLines),
            table.concat(rareLines, "\n")
        }

        sendWebhook("ðŸŽ¯ Rare Pet Alert", table.concat(rareMsg, "\n"), color_rare) -- color
    end

    local _txt = {
        ["big"] = "ðŸ’ª **Big Pet Alert!**",
        ["huge"] = "ðŸ‹ï¸ **Huge Pet Alert!**",
        ["titanic"] = "ðŸ”¥ **Titanic Pet Alert!**",
        ["godly"] = "â­ **Godly Pet Alert!**"
    }

    local header_txt = _txt[hatch_name_cool]
    if not header_txt then
        header_txt = _txt["big"]
    end

    -- Send Big Pet Alert if any were found
    if #bigLines > 0 then
        local bigMsg = {
            "**-> Hatched By:**",
            string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
            "",
            string.format("**-> Big Pets (%d):**", #bigLines),
            table.concat(bigLines, "\n")
        }
        sendWebhook(header_txt, table.concat(bigMsg, "\n"), current_other_color) -- color
    end

    task.wait(0.3)
end


-- sends webhook report
local function HatchReport()
    local newPetNames = newlyHatchedNames
    if #newPetNames == 0 then return end

    local _hatchbuff = string.format("%.2f", Varz.tracked_bonus_egg_recovery or 0)
    local _sellbuff = string.format("%.2f", Varz.tracked_bonus_egg_sell_refund or 0)
    local _petsizebuff_display = string.format("%.2f", pet_size_bonus or 0)
    local serverv = GetServerVersion()
    local hatch_player_uname = _S.LocalPlayer.Name
    local hatchedCount = #newPetNames

    -- Add the list of all hatched pets
    -- db pet list
    local hatchPetls = {} -- this used for storing data in db

    -- New grouping table (separate from hatchPetls)
    local groupedEggs = {}

    local eggsUsed = 0  -- how many eggs we used?
    local eggsSaved = 0 -- how many eggs we saved
    for _, fullName in ipairs(newPetNames) do
        -- table.insert(descriptionLines, string.format("> `%s`", fullName))

        local petName, petWeight, petAge = extractPetDetails(fullName)
        local peteggname = getEggNameByPetName(petName)
        local current_eggs, remain_eggs = _Helper.getEggAmounts(peteggname)

        local pet_item = {
            egg_name = peteggname,
            petname = petName,
            petage = petAge,
            weight = petWeight,
            old_egg_count = current_eggs,
            new_egg_count = remain_eggs,
        }

        table.insert(hatchPetls, pet_item);


        -- build new grouped table
        if not groupedEggs[peteggname] then
            groupedEggs[peteggname] = {
                start = current_eggs,
                finish = remain_eggs,
                pets = {}
            }
        end

        table.insert(groupedEggs[peteggname].pets, fullName)
        -- group ends
    end

    -- After building groupedEggs
    for _, info in pairs(groupedEggs) do
        eggsUsed = eggsUsed + (info.start - info.finish)
    end
    -- Eggs saved is total hatched minus eggs used
    eggsSaved = hatchedCount - eggsUsed

    -- Main Report Construction
    local descriptionLines = {}

    table.insert(descriptionLines, "**-> Session Info:**")
    table.insert(descriptionLines, string.format("â”‚ ðŸ‘¤ Username: ||`%s`||", hatch_player_uname))
    table.insert(descriptionLines, string.format("â”‚ ðŸ–¥ï¸ Server Version: `%s`", serverv))
    table.insert(descriptionLines, "") -- Blank line for spacing

    table.insert(descriptionLines, "**-> Stats:**")

    if pet_size_bonus <= 0 then
        table.insert(descriptionLines, string.format("â”‚ âœ¨ **Buffs** Sell: `%s%%` Hatch: `%s%%`", _sellbuff, _hatchbuff))
    else
        table.insert(descriptionLines,
            string.format("â”‚ âœ¨ **Buffs** Sell: `%s%%` Hatch: `%s%%` PetSize: `%s%%`", _sellbuff, _hatchbuff,
                _petsizebuff_display))
    end
    table.insert(descriptionLines,
        string.format("â”‚ â¤ï¸ Fav: `%d` ðŸŽ‰ Hatched: `%d`", Varz.pets_fav_count or 0, hatchedCount or 0))
    table.insert(descriptionLines, string.format("â”‚ ðŸ¥š Eggs Used: `%d`", eggsUsed or 0))
    table.insert(descriptionLines, string.format("â”‚ ðŸ’¾ Eggs Saved: `%d`", eggsSaved or 0))

    -- Conditionally add the "Lucky Events" section if they occurred
    if true then
        table.insert(descriptionLines, "")
        table.insert(descriptionLines, "**-> Lucky Events! ðŸ€**")
        table.insert(descriptionLines, string.format("â”‚ ðŸ¥š Lucky Pet: `+%d Eggs`", got_eggs_back))
        table.insert(descriptionLines, string.format("â”‚ ðŸ”„ Lucky Hatch: `+%d Eggs`", recovered_eggs))
    end



    table.insert(descriptionLines, "")
    table.insert(descriptionLines, string.format("**-> Pets Hatched (%d):**", hatchedCount))

    -- âœ… Now make UI for groups only (not every pet individually)
    for eggName, info in pairs(groupedEggs) do
        -- first line for the egg
        table.insert(descriptionLines,
            string.format("ðŸ£**%s (St %d, End %d)**", eggName, info.start, info.finish)
        )

        -- sub-lines for each pet hatched from this egg
        for _, petFullName in ipairs(info.pets) do
            table.insert(descriptionLines, string.format("> `%s`", petFullName))
        end
        table.insert(descriptionLines, "")
    end


    -- Send the main report
    local finalDescription = table.concat(descriptionLines, "\n")

    --make data for storage
    local db_data = {
        pets_hatched = hatchPetls,
        serverversion = serverv,
        scriptversion = _S.CurentV,
        username = hatch_player_uname,
        userid = Varz.player_userid,
        cp_api = FOtherSettings.web_api_key,
        buff_seal = _sellbuff,
        buff_koi = _hatchbuff,
        buff_bron = pet_size_bonus,
        PetPassiveBonus = passive_pet_bonus,
        bonus_egg_back = got_eggs_back,  -- seals
        bonus_recovery = recovered_eggs, -- koi
    }


    local color_rare = 16766720
    local color_huge = 16753920
    local titanic_color = 15105570
    local godly_color = 16766720
    local big_color = 3066993

    local current_other_color = big_color
    local hatch_name_cool = "big"

    sendWebhook("Hatch Report", finalDescription, 3447003, db_data, 1) -- Blue color


    -- Separate Alerts for Special Pets
    local rareLines, bigLines = {}, {}
    for _, fullName in ipairs(newPetNames) do
        local petName, petWeight = extractPetDetails(fullName)
        if petName and petWeight then
            if Varz.rare_pets[petName] then
                table.insert(rareLines, string.format("`%s` â€” `%.2f kg`", petName, petWeight))
            end

            if petWeight >= tonumber(FSettings.sell_weight) then
                -- big 3-6kg, huge 6-8kg, titanic 8-10kg,godly 10kg+
                if petWeight < 3 then
                    hatch_name_cool = "big"
                    current_other_color = color_rare -- optional: default colour for tiny pets
                elseif petWeight < 6 then
                    hatch_name_cool = "big"
                    current_other_color = big_color
                elseif petWeight < 8 then
                    hatch_name_cool = "huge"
                    current_other_color = color_huge
                elseif petWeight < 10 then
                    hatch_name_cool = "titanic"
                    current_other_color = titanic_color
                else
                    hatch_name_cool = "godly"
                    current_other_color = godly_color
                end

                table.insert(bigLines, string.format("`%s` â€” `%.2f kg`", petName, petWeight))
            end
        end
    end

    -- Send Rare Pet Alert if any were found
    if #rareLines > 0 then
        local rareMsg = {
            "**-> Hatched By:**",
            string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
            "",
            string.format("**-> Rare Pets (%d):**", #rareLines),
            table.concat(rareLines, "\n")
        }

        sendWebhook("ðŸŽ¯ Rare Pet Alert", table.concat(rareMsg, "\n"), color_rare) -- color
    end

    local _txt = {
        ["big"] = "ðŸ’ª **Big Pet Alert!**",
        ["huge"] = "ðŸ‹ï¸ **Huge Pet Alert!**",
        ["titanic"] = "ðŸ”¥ **Titanic Pet Alert!**",
        ["godly"] = "â­ **Godly Pet Alert!**"
    }

    local header_txt = _txt[hatch_name_cool]
    if not header_txt then
        header_txt = _txt["big"]
    end

    -- Send Big Pet Alert if any were found
    if #bigLines > 0 then
        local bigMsg = {
            "**-> Hatched By:**",
            string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
            "",
            string.format("**-> Big Pets (%d):**", #bigLines),
            table.concat(bigLines, "\n")
        }
        sendWebhook(header_txt, table.concat(bigMsg, "\n"), current_other_color) -- color
    end

    task.wait(0.3)
end



local function SendInfoNoEggs()
    local bigMsg = {
        "âŒ **Out of Eggs!** âŒ",
        "",
        string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
        "",
        "âŒ **You have no eggs left.**",
        "",
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    }
    sendWebhook("âŒ No Eggs Alert", table.concat(bigMsg, "\n"), 15105570) -- Red colour
end

local function SendInfoFailedTeamPlace()
    local bigMsg = {
        "âŒ **Failed to place a team!** âŒ",
        "",
        string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
        "",
        "âŒ **Team failed to be place.**",
        "",
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    }
    sendWebhook("âŒ Team Placement Alert", table.concat(bigMsg, "\n"), 15105570) -- Red colour
end

local function SendErrorMessage(errorMsg)
    errorMsg = errorMsg or "Some Error"

    local bigMsg = {
        "âŒ Error âŒ",
        "",
        string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
        "",
        "âŒ " .. errorMsg,
        "",
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    }

    if sendWebhook then
        sendWebhook("âŒ " .. errorMsg, table.concat(bigMsg, "\n"), 15105570) -- Red colour
    else
        warn("webhook not found..")
    end
end


local function SendErrorSuccess(msg)
    msg = msg or "Operation completed successfully"

    local bigMsg = {
        "âœ… Success âœ…",
        "",
        string.format("â”‚ Username: ||`%s`||", _S.LocalPlayer.Name),
        "",
        "âœ… " .. msg,
        "",
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    }

    if sendWebhook then
        sendWebhook("âœ… " .. msg, table.concat(bigMsg, "\n"), 65280) -- Green colour
    else
        warn("âš ï¸ Webhook not found. Message:\n" .. table.concat(bigMsg, "\n"))
    end
end



-- These two functions are the same, they just format the webhook
local function send_10min_report()
    local descriptionLines = {
        "**ðŸ“Š 10-Minute Stats Update**", "",
        string.format("â”‚ ðŸ£ Hatched in this 10-min block: `%d`", FSettings.eggs_hatched_in_10_min_session),
        string.format("â”‚ ðŸ•’ Hatched in this hourly block: `%d`", FSettings.eggs_hatched_in_hourly_session),
        string.format("â”‚ ðŸ“ˆ Total Hatched (All Time): `%d`", FSettings.pets_hatched_total), "",
        string.format("â”‚ ðŸ‘¤ Username: ||`%s`||", _S.LocalPlayer.Name),
    }
    sendWebhook("Timed Report (10 Min)", table.concat(descriptionLines, "\n"), 16776960) -- Yellow Color
end

local function send_hourly_report()
    local descriptionLines = {
        "**â° Hourly Stats Summary**", "",
        string.format("â”‚ ðŸ£ Hatched this hour: `%d`", FSettings.eggs_hatched_in_hourly_session),
        string.format("â”‚ ðŸ“ˆ Total Hatched (All Time): `%d`", FSettings.pets_hatched_total), "",
        string.format("â”‚ ðŸ‘¤ Username: ||`%s`||", _S.LocalPlayer.Name),
    }
    sendWebhook("Timed Report (Hourly)", table.concat(descriptionLines, "\n"), 5763719) -- Dark Green Color
end



-- This function runs ONCE on script load to check if reports are due
local function CheckAndSendTimedReports()
    print("ðŸ“ˆ Checking if timed reports are due...")
    local current_time = os.time()
    local did_update = false

    -- Initialize timestamps on the very first run
    if FSettings.last_10min_report_time == 0 then FSettings.last_10min_report_time = current_time end
    if FSettings.last_hourly_report_time == 0 then FSettings.last_hourly_report_time = current_time end

    -- Check if 10 minutes have passed since the last saved time
    if (current_time - FSettings.last_10min_report_time) >= 600 then
        print("10-minute report is due. Sending...")
        send_10min_report()
        FSettings.eggs_hatched_in_10_min_session = 0
        FSettings.last_10min_report_time = current_time
        did_update = true
    end

    -- Check if 1 hour has passed since the last saved time
    if (current_time - FSettings.last_hourly_report_time) >= 3600 then
        print("Hourly report is due. Sending...")
        send_hourly_report()
        FSettings.eggs_hatched_in_hourly_session = 0
        FSettings.last_hourly_report_time = current_time
        did_update = true
    end

    -- If we sent a report, save the new timestamps and reset counters
    if did_update then
        SaveData()
    end
end



local function findEggTool(eggName)
    if not eggName then return nil end
    -- 1. Check if the character is already holding the correct tool.
    local humanoid = _S.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- A character can only hold one tool at a time.
        local equippedTool = _S.Character:FindFirstChildOfClass("Tool")

        -- Check if a tool is equipped AND if it's the right egg.
        if equippedTool and equippedTool:GetAttribute("h") == eggName then
            return equippedTool -- Found it! No need to search further.
        end
    end

    -- 2. If not equipped, search the player's backpack.
    for _, tool in ipairs(_S.Backpack:GetChildren()) do
        if tool:IsA("Tool") and tool:GetAttribute("h") == eggName then
            return tool -- Found it in the backpack.
        end
    end

    -- 3. If we've checked everywhere and found nothing, return nil.
    return nil
end




local function FindEggLostGainDiff()
    local total_diff = 0

    for eggName, data in pairs(Varz.egg_counts) do
        local diff = data.new_amount - data.current_amount
        if diff > 0 then
            total_diff = total_diff + diff
        end
    end

    return total_diff
end


InventoryManager.GetEggToolForHatching = function()
    local enabledEggs = {}
    for eggName, data in pairs(FSettings.eggs_to_place_array) do
        if data.enabled then
            table.insert(enabledEggs, { name = eggName, order = data.order })
        end
    end


    -- Sort by order
    table.sort(enabledEggs, function(a, b)
        return a.order > b.order
    end)

    -- Loop through sorted enabled eggs
    for _, egg in ipairs(enabledEggs) do
        local foundTool = InventoryManager.GetEggUsingNameNew(egg.name)
        if foundTool then
            return foundTool
        else
            warn(egg.name .. " Egg not found.")
        end
    end

    return nil
end


local function findEggToPlaceBasedOnPriority()
    -- Collect enabled eggs with their order
    local enabledEggs = {}
    for eggName, data in pairs(FSettings.eggs_to_place_array) do
        if data.enabled then
            table.insert(enabledEggs, { name = eggName, order = data.order })
        end
    end

    -- Sort by order
    table.sort(enabledEggs, function(a, b)
        return a.order > b.order
    end)

    -- Loop through sorted enabled eggs
    for _, egg in ipairs(enabledEggs) do
        local foundTool = findEggTool(egg.name)
        if foundTool then
            return foundTool
        else
            warn(egg.name .. " not found, moving to next")
        end
    end

    -- No eggs found
    return nil
end




-- local function GetCountEggsOnFarm()
--     local f_count = 0
--     -- crates are also placed in this location, filter eggs only
--     local array_ob = FarmManager.mObjects_Physical:GetChildren()
--     for _, value in ipairs(array_ob) do
--         if value and value:IsA("Model") and value.Name == "PetEgg" then
--             f_count = f_count + 1
--         end
--     end
--     task.wait(0.3);
--     return f_count
-- end

local function GetCountEggsOnFarm()
    local success, result = pcall(function()
        local f_count = 0

        local array_ob = FarmManager.mObjects_Physical:GetChildren()
        if not array_ob or #array_ob == 0 then
            return 0
        end

        -- Count only valid egg models
        for _, value in ipairs(array_ob) do
            if value and value:IsA("Model") and value.Name == "PetEgg" then
                f_count = f_count + 1
            end
        end

        task.wait()
        return f_count
    end)

    -- Return count if successful, otherwise 0
    return success and result or 0
end







----------------------- Feeding System

MonsterFeeder.UpdateLblStatsText = function(_txt)
    if UI_LABELS.lbl_pet_system_live then
        UI_LABELS.lbl_pet_system_live:SetText(_txt)
    end
end

MonsterFeeder.FeedFruit = function(pet_uuid)
    --print("feed: " .. pet_uuid)
    _S.ActivePetService:FireServer("Feed", pet_uuid)
end

MonsterFeeder.IsPetHungry = function(_name, current_hunger)
    if not _name then return false end

    local petinfo = MonsterManager.GetPetDataUsingName(_name)
    if not petinfo then
        print("pet info not found.. " .. _name)
        return false
    end

    local max_hunger = petinfo.hunger
    if max_hunger > 0 then
        local percent_full = (current_hunger / max_hunger) * 100
        if percent_full < 70 then
            return true
        end
        return false
        -- warn("Hunger: " .. _name .. " is " .. math.floor(percent_full) .. "% full.")
    end
    -- warn("max hunger: " .. max_hunger)

    -- This is the corrected logic. It now returns 'true' when the pet IS hungry.
    return current_hunger < max_hunger
end


MonsterFeeder.FeedPetsFood = function(_foodName, amount)
    local dx = FarmManager.GetActivePetsUUIDS()
    if not dx then
        return
    end
    local isIgnorelevelmax = true
    local isForceFeed = true
    local current_am = 0

    local didfeed = false
    for _, pet_uuid in ipairs(dx) do
        local _petData = GetPetDataByUUID(pet_uuid)
        if not _petData then
            continue
        end
        task.wait(0.3)

        local UUID = _petData.UUID
        local PetData = _petData.PetData
        local PetType = _petData.PetType -- name of the pet
        local PetAbility = _petData.PetAbility

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight


        if not isIgnorelevelmax and tonumber(Level) >= 100 then
            continue
        end

        if current_am >= amount then
            break
        end

        -- feeds it
        if MonsterFeeder.IsPetHungry(PetType, Hunger) or isForceFeed then
            -- feed this pet
            -- must hold a Food
            local food = _FruitCollectorMachine.GetFoodForFeedUsingName(_foodName)
            task.wait(0.3)

            if not food then
                -- don't have this food
                break
            end

            if food then
                unequipTools()
                task.wait(0.3)
                EquipToolOnChar(food)
                task.wait(0.5)
                MonsterFeeder.FeedFruit(pet_uuid)
                task.wait(0.3)
                unequipTools()
                didfeed = true
                current_am = current_am + 1
            else
                task.wait(2)
                break
            end
        end
    end


    return didfeed
end

MonsterFeeder.FeedHungryPets = function(force_feed, ignore_max_level)
    local dx = FarmManager.GetActivePetsUUIDS()
    if not dx then
        return
    end
    local isIgnorelevelmax = false
    local isForceFeed = false
    if ignore_max_level and ignore_max_level == true then
        isIgnorelevelmax = true
    end

    if force_feed and force_feed == true then
        isForceFeed = true
    end

    MonsterFeeder.UpdateLblStatsText("ðŸŽ About to feed pets. ")
    local didfeed = false
    for _, pet_uuid in ipairs(dx) do
        local _petData = GetPetDataByUUID(pet_uuid)
        if not _petData then
            continue
        end
        task.wait(0.3)

        local UUID = _petData.UUID
        local PetData = _petData.PetData
        local PetType = _petData.PetType -- name of the pet
        local PetAbility = _petData.PetAbility

        -- Can we feed this type of pet
        if FOtherSettings.feeding_list_pets[PetType] then
            --warn("Unable to feed ".. PetType.. " is added to filter list.")
            continue
        end

        local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
        local IsFavorite = PetData.IsFavorite
        local Boosts = PetData.Boosts
        local Name = PetData.Name
        local LevelProgress = PetData.LevelProgress
        local EggName = PetData.EggName
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight


        --warn("Pet "..Level..": Hunger: ".. Hunger .." || " .. Name .. " " .. PetType)

        if not isIgnorelevelmax and tonumber(Level) >= 100 then
            --warn("Ignored max level: " .. Name .. " " .. PetType)
            continue
        end

        if Varz.IS_COOKING or Varz.IS_HATCHING or Varz.IS_MUTATION_RUNNING then
            break
        end

        local toolShovel = InventoryManager.GetShovel()
        -- is user holding any tool
        if IsToolHeldNew(toolShovel) then
            MonsterFeeder.UpdateLblStatsText(
                "âš ï¸ You are holding a tool <font color='#ff00ff'>[Shovel]</font>, waiting for you to unequip it...")
            task.wait(math.random(3, 5))
            break
        end

        -- feeds it
        if MonsterFeeder.IsPetHungry(PetType, Hunger) or isForceFeed then
            -- feed this pet
            -- must hold a fruit
            local fruit
            local food
            if not FOtherSettings.feed_food_insteadoffruits then
                fruit = _FruitCollectorMachine.GetRandomFruitForFeed()
            end

            if FOtherSettings.feed_food_insteadoffruits then
                food = _FruitCollectorMachine.GetRandomFoodWithExcluded()
                if not food then
                    --warn("FOood not found")
                end
                --warn("got food")
            end

            task.wait(0.3)
            if FOtherSettings.feed_food_insteadoffruits == false then
                if not fruit then
                    --  try to collect some fruits
                    local _success, _error = pcall(function()
                        local fruits_amount = 8 -- collect fruits max
                        _FruitCollectorMachine.CollectFruitForSeedingSystem(fruits_amount)
                    end)

                    -- wait for collection
                    task.wait(1.5)
                    -- check again
                    fruit = _FruitCollectorMachine.GetRandomFruitForFeed()
                    task.wait(0.2)
                end
                --warn("false feed_food_insteadoffruits")
            end



            if fruit and not FOtherSettings.feed_food_insteadoffruits then
                unequipTools()
                EquipToolOnChar(fruit)
                task.wait(0.5)
                MonsterFeeder.UpdateLblStatsText("âœ… Fed " .. PetType)
                MonsterFeeder.FeedFruit(pet_uuid)
                task.wait(0.3)
                unequipTools()
                didfeed = true
                --print("Feed succed for pet: " .. PetType )
            elseif food and FOtherSettings.feed_food_insteadoffruits then
                unequipTools()
                EquipToolOnChar(food)
                task.wait(0.5)
                MonsterFeeder.UpdateLblStatsText("âœ… Fed " .. PetType)
                MonsterFeeder.FeedFruit(pet_uuid)
                task.wait(0.3)
                unequipTools()
                didfeed = true
            else
                MonsterFeeder.UpdateLblStatsText("âŒ No fruit to feed.")
                task.wait(3)
                break
            end
        end
    end


    if not didfeed then
        MonsterFeeder.UpdateLblStatsText("âŒ Nothing to feed.")
        task.wait(1)
    end
end

--------------------- Feeding



---------------------------------------------------
-------------- Event Fall Market Event
---------------------------------------------------
FallEventManager.UpdateStatsText = function(_txt)
    if UI_LABELS.lbl_fallevent_stats then
        UI_LABELS.lbl_fallevent_stats:SetText(_txt)
    end
end


FallEventManager.UpdateStatsRequiredText = function(_txt)
    if UI_LABELS.lbl_fallevent_required_fruits then
        UI_LABELS.lbl_fallevent_required_fruits:SetText(_txt)
    end
end

FallEventManager.UpdateStatsProgressText = function(_txt)
    if UI_LABELS.lbl_fallevent_progress then
        UI_LABELS.lbl_fallevent_progress:SetText(_txt)
    end
end

FallEventManager.UpdateStatsFallBloomText = function(_txt)
    if UI_LABELS.lbl_fallevent_fall_bloom then
        UI_LABELS.lbl_fallevent_fall_bloom:SetText(_txt)
    end
end

FallEventManager.UpdateRequiredFruitsInfoText = function(_txt)
    if UI_LABELS.lbl_fallevent_fruit_ls then
        UI_LABELS.lbl_fallevent_fruit_ls:SetText(_txt)
    end
end


FallEventManager.cache = {}

FallEventManager.findInWorkspace = function(name, objectType)
    local target = string.lower(name)

    for _, d in ipairs(_S.Workspace:GetDescendants()) do
        if string.lower(d.Name) == target and d:IsA(objectType) then
            return d
        end
    end

    return nil
end

FallEventManager.findInWorkspaceMulti = function(name, objectType)
    local target = string.lower(name)

    local m = {}

    for _, d in ipairs(_S.Workspace:GetDescendants()) do
        if string.lower(d.Name) == target and d:IsA(objectType) then
            table.insert(m, d)
        end
    end

    return m
end


FallEventManager.findInWorkspaceOrInteraction = function(name, objectType)
    local obj = _S.Workspace:FindFirstChild(name)
    if obj and (not objectType or obj:IsA(objectType)) then
        return obj
    end

    local interaction = _S.Workspace:FindFirstChild("Interaction")
    if interaction then
        for _, descendant in ipairs(interaction:GetDescendants()) do
            if descendant.Name == name and (not objectType or descendant:IsA(objectType)) then
                return descendant
            end
        end
    end

    return nil
end



FallEventManager.SubmitFruits = function()
    -- Remote
    pcall(function()
        Varz.StopEnhancer(8)
    end)
    _Helper.SafeFruitsProccess()
    task.wait(0.4)
    pcall(function()
        task.spawn(function()
            _S.GameEvents.ChristmasEvent.Christmas_SubmitAll:FireServer(_S.LocalPlayer)
        end)
    end)
end




FallEventManager.ClaimRewardsOrReset = function(minRewards)
    local minRewards = 1

    -- Safe claim logic
    pcall(function()
        local gui = _S.PlayerGui:FindFirstChild("ChipmunkRewards_UI")
        if not gui then return end

        local holder = gui.Frame.Main.Holder
        local claimBtnVisible = holder.CLAIM_BUTTON.Visible

        local sign = _S.Workspace.ChipmunkEvent
            .NutsPlatform
            .ChipmunkRewardSign

        if not sign then return end

        local label = sign.Root.SurfaceGui.TextLabel
        if not label then return end

        local text = label.Text -- e.g. "28 Unclaimed Rewards"

        -- Extract the number from the text
        local num = tonumber(string.match(text, "(%d+)")) or 0

        local claimEvent = _S.ReplicatedStorage.GameEvents:FindFirstChild("ClaimChipmunkRewards")
        if not claimEvent then return end

        local function claimRewards()
            claimEvent:FireServer()
        end

        -- Only claim if above threshold
        if num >= minRewards then
            claimRewards()
        end

        if claimBtnVisible then
            claimRewards()
        end
    end)

    -- Safe reset logic
    pcall(function()
        local gui = _S.PlayerGui:FindFirstChild("ChipmunkRewards_UI")
        if not gui then return end

        local restartVisible = gui.Frame.Main.Holder.RestartFrame.Visible
        if restartVisible then
            local restartEvent = _S.ReplicatedStorage.GameEvents:FindFirstChild("RestartChipmunkTrack")
            if restartEvent then
                restartEvent:FireServer()
            end
        end
    end)
end




FallEventManager.GetLookingForTrait = function()
    local success, trait = pcall(function()
        local eventfolder = FallEventManager.cache["SafariEvent"] or nil
        if not eventfolder then return nil end
        local label = eventfolder:FindFirstChild("Safari platform"):FindFirstChild("NPC"):FindFirstChild("Safari Joyce")
            .Head.BubblePart.SafariTraitBillboard.BG.TraitTextLabel
        local text = label.ContentText or ""
        local traitName = text:match("looking for (.+) Plants")
        return traitName
    end)

    if true then
        return "Christmas Mutations"
    end

    if success and trait then
        return trait
    else
        warn("Error", trait)
        return nil
    end
end


FallEventManager.EventFolderExists = function()
    local success, res = pcall(function()
        --  local model = FallEventManager.findInWorkspaceOrInteraction("SafariEvent", "Folder")
        local model = nil
        local modelx = FallEventManager.findInWorkspaceMulti("Model1", "Model")
        for _, mod in ipairs(modelx) do
            if mod:FindFirstChild("StockCounter") then
                model = mod
                break
            end
        end

        return model
    end)
    if success then
        return res
    end
    return nil
end

FallEventManager.GetProgressPercentx = function()
    -- no progress.
    if true then return nil end

    local success, percent = pcall(function()
        -- local label = _S.Workspace.Interaction.UpdateItems.WitchesBrewEvent.WitchesBrewCauldron.CauldronProgressUI
        local ev = FallEventManager.EventFolderExists() or nil
        if not ev then
            return nil
        end

        -- workspace.Interaction.UpdateItems.SafariEvent["Safari platform"].Platform.SafariRewardSign:GetChildren()[3]
        -- .BillboardGui.RewardProgress

        -- // progress
        local label = ev.Part.ProgressBar.Frame.ProgressBG.TextLabel

        --local label = ev.CauldronProgressUI.ProgressBillboard.Progress
        if not label then return nil end

        local text = (label.ContentText or ""):gsub(",", "."):match("^%s*(.-)%s*$")

        -- Match explicit percentage only (e.g. "1%", "12.5%", "33.56%")
        local value_str = text:match("([%d%.]+)%s*%%")
        if not value_str then
            return nil
        end

        local value = tonumber(value_str)
        if not value then
            return nil
        end

        -- clamp range 0â€“100
        if value < 0 then value = 0 end
        if value > 100 then value = 100 end

        return value
    end)

    if success and percent then
        return percent
    else
        return nil
    end
end

FallEventManager.GetProgressPercent = function()
    local success, result = pcall(function()
        local ev = FallEventManager.EventFolderExists()
        if not ev then
            return nil
        end

        local label = ev.Part.ProgressBar.Frame.ProgressBG.TextLabel
        if not label then return nil end

        local text = (label.ContentText or ""):match("^%s*(.-)%s*$")

        ----------------------------------------------------------------
        -- NEW FORMAT ONLY: "12/454"
        ----------------------------------------------------------------
        local cur, total = text:match("^(%d+)%s*/%s*(%d+)$")

        if cur and total then
            local pro = string.format("%s/%s", cur, total)
            return pro
        end

        return nil
    end)

    return success and result or nil
end


FallEventManager.GetCooldown = function()
    -- this event has no cooldown
    if true then return nil end

    local success, seconds = pcall(function()
        local ev = FallEventManager.findInWorkspaceOrInteraction("WitchesBrewCauldron", "Model")
        if not ev then
            return nil
        end

        local label = ev.CauldronProgressUI.ProgressBillboard.Progress
        if not label then
            return nil
        end

        local text = (label.ContentText or ""):match("^%s*(.-)%s*$") -- trim spaces

        -- Match "Brew Timer: mm:ss"
        local minutes, secs = text:match("^Brew Timer:%s*(%d+):(%d+)$")
        if minutes and secs then
            return tonumber(minutes) * 60 + tonumber(secs)
        end

        -- Match "Brew Timer: seconds"
        local secs_only = text:match("^Brew Timer:%s*(%d+)$")
        if secs_only then
            return tonumber(secs_only)
        end

        return nil
    end)

    if success and seconds then
        return seconds
    else
        return nil
    end
end



FallEventManager.GetFallBlooms = function()
    -- event has no blooms
    if true then return nil end

    local success, result = pcall(function()
        local label = _S.Workspace["Fall Festival"]
            .FallPlatform.FallBloomsContributedSign.Part.SurfaceGui.Root.Quantity

        local text = label.ContentText or "" -- e.g., "123"
        local current = tonumber(text)
        if current then
            return current
        end
        return nil
    end)

    if success and result then
        return result
    else
        return nil
    end
end



---------------------------------------------------
-------------- END Event Fall
---------------------------------------------------




--- ============= Crafing event #craft #event #smith

-- #tradeevent
EventsManager.TraderEvent = {
    cache = {},
    cache_current_count = 0,
    UpdateUITradeEventStatus = function(_txt)
        if UI_LABELS.lbl_tradeevent_status then
            UI_LABELS.lbl_tradeevent_status:SetText(_txt)
        end
    end,
    GetEventPlatform = function()
        local evName = "PortalPlatform"


        EventsManager.TraderEvent.cache_current_count = EventsManager.TraderEvent.cache_current_count + 1
        if EventsManager.TraderEvent.cache_current_count > 50 then
            EventsManager.TraderEvent.cache = {}
        end

        local cache = EventsManager.TraderEvent.cache

        -- If cached, validate it still exists and is a Model
        local cached = cache[evName]
        if cached then
            return cached
        else
            cache[evName] = nil
        end

        -- Fresh lookup
        local platform = FallEventManager.findInWorkspaceMulti(evName, "Model")
        local real_platform = nil
        for _, plat in ipairs(platform) do
            if plat:FindFirstChild("Model") then
                real_platform = plat
                break
            end
        end
        if real_platform then
            cache[evName] = real_platform
            return real_platform
        end

        return nil
    end,
    GetRequiredFruit = function()
        local count = 0
        local success, result = pcall(function()
            local PortalPlatform = EventsManager.TraderEvent.GetEventPlatform()
            -- if not PortalPlatform then return nil, count end

            local _model = PortalPlatform:FindFirstChild("Model")

            if not _model then
                return nil, count
            end
            local frame = _model:FindFirstChild("2"):FindFirstChild("Frame")
            -- frame has two Part(s). both have TraderEventUI but only one will have InfoFrame.RequireFrame.ItemName.Text
            -- PortalPlatform.Model["2"].Frame.Part.TraderEventUI.InfoFrame.RequireFrame.ItemName.Text


            for _, ob in ipairs(frame:GetChildren()) do
                local TraderEventUI = ob:FindFirstChild("TraderEventUI"):FindFirstChild("InfoFrame")
                if not TraderEventUI then
                    continue
                end

                if TraderEventUI.Visible == false then
                    return nil, count
                end

                local fruitName = TraderEventUI.RequireFrame.ItemName.Text
                local fruitAmount = TraderEventUI.RequireFrame.ImageLabel.Amount.Text

                -- keep only digits
                local cleaned = tostring(fruitAmount):gsub("%D", "") or 0
                count = tonumber(cleaned) or 0
                return tostring(fruitName), count
            end
        end)

        if not success then
            warn("Error:", result)
            return nil, count
        end

        return result, count
    end,

    SubmitRequirements = function()
        pcall(function()
            _S.GameEvents.TraderEvent.Trader_SubmitFruitRE:FireServer()
        end)
    end
}


EventsManager.Furnace = {
    cache = {},
    UpdateUIStatus = function(_txt)
        if UI_LABELS.lbl_smithman_status then
            UI_LABELS.lbl_smithman_status:SetText(_txt)
        end
    end,

    SubmitGearHeld = function()
        pcall(function()
            _S.GameEvents.SmithingEvent.Smithing_SubmitGearRE:FireServer()
        end)
    end,

    SubmitEggHeld = function()
        pcall(function()
            _S.GameEvents.SmithingEvent.Smithing_SubmitPetRE:FireServer()
        end)
    end,

    SubmitFruitHeld = function()
        pcall(function()
            _S.GameEvents.SmithingEvent.Smithing_SubmitFruitRE:FireServer()
        end)
    end,

    EquipEggToSubmit = function()
        local ueggs = FSettings.craftevent.egg_list
        for eggName, _ in pairs(ueggs) do
            local tool = InventoryManager.GetEggUsingName(eggName)
            if tool then
                unequipTools()
                if not EquipToolOnChar(tool) then
                    continue
                end
                task.wait(0.1)
                return true
            end
        end
        return false
    end,
    EquipGearToSubmit = function()
        local ugear = FSettings.craftevent.gear_list
        for gearName, _ in pairs(ugear) do
            local tool = InventoryManager.GetToolUsingName(gearName)
            if tool then
                unequipTools()
                if not EquipToolOnChar(tool) then
                    continue
                end
                task.wait(0.1)
                return true
            end
        end
        return false
    end,

    EquipFruitToSubmit = function()
        local ulist = FSettings.craftevent.fruit_list

        local is_random = false
        if next(ulist) == nil then
            is_random = true
        end

        if is_random then
            local tool = InventoryManager.GetFruitRandom()
            if tool then
                unequipTools()
                if not EquipToolOnChar(tool) then
                    return false
                end
                task.wait(0.1)
                return true
            else
                if InventoryManager.IsToolHeldAny() then
                    unequipTools()
                    task.wait(0.1)
                end
                _FruitCollectorMachine.CollectFruitsRandom(30)
                task.wait(0.5)
            end
            return false
        end

        for itemName, _ in pairs(ulist) do
            local tool = InventoryManager.GetFruitUsingName(itemName)
            if tool then
                unequipTools()
                if not EquipToolOnChar(tool) then
                    continue
                end
                task.wait(0.1)
                return true
            end
        end

        -- collect and fruits using names
        if InventoryManager.IsToolHeldAny() then
            unequipTools()
            task.wait(0.1)
        end
        _FruitCollectorMachine.CollectFruitByNamesSortedRarity(ulist, 30)
        task.wait(0.3)
        return false
    end,
    FindEventModel = function()
        local ev_name = "Furnace"
        local ev_type = "Model"
        if EventsManager.Furnace.cache[ev_name] then
            return EventsManager.Furnace.cache[ev_name]
        end
        local dx = FallEventManager.findInWorkspace(ev_name, ev_type)
        if dx then
            EventsManager.Furnace.cache[ev_name] = dx
        end
        return dx
    end,



}

-- End craft event





---- Jungle Event

EventsManager.JungleUI = {
    UpdateStatsText = function(_txt)
        if UI_LABELS.lbl_jungle_stats then
            UI_LABELS.lbl_jungle_stats:SetText(_txt)
        end
    end,

    UpdateInformationText = function(_txt)
        if UI_LABELS.lbl_jungle_information then
            UI_LABELS.lbl_jungle_information:SetText(_txt)
        end
    end
}

EventsManager.JungleShops = {
    BuyStage1Seeds = function()
        local shop_index = 5
        local success, result = pcall(function()
            for key, value in pairs(FOtherSettings.jungle_seed_stages1) do
                if value then
                    for i = 1, 10 do
                        _S.BuyEventShopStock:FireServer(key, shop_index)
                    end
                end
            end
            return true
        end)

        if success then
            return true
        else
            return false
        end
    end,
    BuyStage2Seeds = function()
        local shop_index = 6
        local _test = {
            ["Evo Beetroot II"] = true,
            ["Evo Blueberry II"] = true,
            ["Evo Pumpkin II"] = true,
            ["Evo Mushroom II"] = true,
        }
        local success, result = pcall(function()
            for key, value in pairs(_test) do
                if value then
                    for i = 1, 10 do
                        _S.BuyEventShopStock:FireServer(key, shop_index)
                    end
                end
            end
            return true
        end)

        if success then
            return true
        else
            return false
        end
    end,

}

EventsManager.JungleActions = {
    SubmitHeld = function()
        local succ, res = pcall(function()
            --_S.TieredPlants:FireServer("Held")
        end)
    end,

    SubmitAll = function()
        local succ, res = pcall(function()
            -- _S.TieredPlants:FireServer("All")
        end)
    end


}

---- end Jungle Event















--------------------------------------------------
---------- Quest activity
--------------------------------------------------


EventQuestsManager.UpdateStatsText = function(_txt)
    if UI_LABELS.lbl_questline_status then
        UI_LABELS.lbl_questline_status:SetText(_txt)
    end
end

EventQuestsManager.UpdateStatsInfo = function(_txt)
    if UI_LABELS.lbl_questline_info then
        UI_LABELS.lbl_questline_info:SetText(_txt)
    end
end

EventQuestsManager.DoReroll = function()
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("FallMarketEvent"):WaitForChild(
        "Activities"):WaitForChild("RerollQuests"):FireServer()
end

EventQuestsManager.ClaimRewards = function()
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("FallMarketEvent"):WaitForChild(
        "ClaimFallEnergyRewards"):FireServer()
end

EventQuestsManager.CanClaimRewards = function()
    local succ, result = pcall(function()
        return _S.Workspace.Interaction.UpdateItems.RewardSign.RewardTimeBillboard.BillboardGui.Timer.Text ==
            "You have rewards to claim!"
    end)
    return succ and result or false
end

EventQuestsManager.RerollCost = function()
    local succ, result = pcall(function()
        return _S.PlayerGui.FallQuests_UI.Frame.Main.Holder.Header.RerollQuestsButton.TextLabel.Text
    end)
    return succ and result or false
end


EventQuestsManager.GetAvailableActivites = function()
    local data = {}
    local success, results = pcall(function()
        ---local ui = _S.LocalPlayer.PlayerGui.FallQuests_UI.Frame.Main.Holder.Tasks.List
        local ui = _S.LocalPlayer.PlayerGui.DeadTreeQuests_UI.Frame.Main.Holder.Content.Tasks.List
        if ui then
            for _, item in ipairs(ui:GetChildren()) do
                if item and item.Name ~= "Segment" then continue end
                local m_data = {}
                local checkbox = item.CHECKMARK_ICON.Visible
                if checkbox then
                    -- already done
                    continue
                end
                local taskName = item.TASK_NAME.ContentText
                if taskName == "Collect 15M Cash" then
                    -- invalid task.
                    continue
                end

                -- 0/1, 0/25 etc
                local Progress = item.Progress.ProgressBar.PROGRESS.ContentText
                local current, required, percentage = _Helper.GetProgressLeft(Progress)

                if Progress == "Completed!" then
                    continue
                end
                -- if percentage >= 100 then
                --     -- complete
                --     continue
                -- end


                -- Tools
                if taskName == "Use 1 Maple Leaf Charm" then
                    m_data["Tool"] = { name = "Maple Leaf Charm", use_current = current, use_max = required }

                    -- Harvest
                elseif taskName == "Harvest 5 Pumpkins" then
                    m_data["Harvest"] = { name = "Pumpkin", use_current = current, use_max = required }
                elseif taskName == "Harvest 2 Jack O Lanterns" then
                    m_data["Harvest"] = { name = "Jack O Lantern", use_current = current, use_max = required }
                elseif taskName == "Harvest 1 Banesberry" then
                    m_data["Harvest"] = { name = "Banesberry", use_current = current, use_max = required }
                elseif taskName == "Harvest 10 Corn" then
                    m_data["Harvest"] = { name = "Corn", use_current = current, use_max = required }

                    -- Plant
                elseif taskName == "Plant 10 Bloodred Mushroom Seeds" then
                    m_data["Seed"] = { name = "Bloodred Mushroom", use_current = current, use_max = required }

                    -- Watering Can
                elseif taskName == "Water 30 plants" then
                    m_data["WATERCAN"] = { name = "Watering Can", use_current = current, use_max = required }

                    -- Harvest Mutation
                elseif taskName == "Harvest 10 Spooky mutations" then
                    m_data["HarvestMutation"] = { name = "Spooky", use_current = current, use_max = required }
                elseif taskName == "Harvest 10 Vamp mutations" then
                    m_data["HarvestMutation"] = { name = "Vamp", use_current = current, use_max = required }
                elseif taskName == "Harvest 5 Moonlit mutations" then
                    m_data["HarvestMutation"] = { name = "Moonlit", use_current = current, use_max = required }

                    -- Seed Packs
                elseif taskName == "Open 3 Halloween Gear Boxes" then
                    m_data["SeedPack"] = { name = "Halloween Gear Box", use_current = current, use_max = required }

                    -- Food / Soup
                elseif taskName == "Eat 3 Suspicious Soups" then
                    m_data["FeedFood"] = { name = "Suspicious Soup", use_current = current, use_max = required }

                    -- Travel
                elseif taskName == "Travel 250 times on Witchesâ€™ Broom" then
                    m_data["Travel"] = { name = "Witches Broom", use_current = current, use_max = required }

                    -- Open Crates
                elseif taskName == "Open 1 Pumpkin Crate" then
                    m_data["Crate"] = { name = "Pumpkin Crate", use_current = current, use_max = required }
                elseif taskName == "Open 1 Spooky Crate" then
                    m_data["Crate"] = { name = "Spooky Crate", use_current = current, use_max = required }

                    -- Feed any pet
                elseif taskName == "Feed any pet 15 times" then
                    m_data["Feed"] = { name = "FeedAnyPet", use_current = current, use_max = required }

                    -- Hatch Egg
                elseif taskName == "Hatch 1 Spooky Egg" then
                    m_data["HatchEgg"] = { name = "Spooky Egg", use_current = current, use_max = required }

                    -- Grow Pet to Age
                elseif taskName == "Grow Pumpkin Rat to age 7" then
                    m_data["GrowPetToAge"] = { name = "Pumpkin Rat", use_current = current, use_max = required }
                elseif taskName == "Grow Bat to age 7" then
                    m_data["GrowPetToAge"] = { name = "Bat", use_current = current, use_max = required }

                    -- Sell
                elseif taskName == "Sell any plant 40 times" then
                    m_data["SellAnyPlant"] = { name = "AnyPlant", use_current = current, use_max = required }
                elseif taskName == "Sell 10 Pumpkins" then
                    m_data["SellPlant"] = { name = "Pumpkin", use_current = current, use_max = required }
                elseif taskName == "Sell 25 Corn" then
                    m_data["SellPlant"] = { name = "Corn", use_current = current, use_max = required }
                elseif taskName == "Sell 5 Bloodred Mushrooms" then
                    m_data["SellPlant"] = { name = "Bloodred Mushroom", use_current = current, use_max = required }
                elseif taskName == "Sell 1 Jack O Lantern" then
                    m_data["SellPlant"] = { name = "Jack O Lantern", use_current = current, use_max = required }

                    -- Earn / Spend Currency
                elseif taskName == "Earn 500,000 Sheckles" then
                    m_data["EarnCurrency"] = { name = "Sheckles", use_current = current, use_max = required }
                elseif taskName == "Spend 50 CandyCorn" then
                    m_data["SpendCurrency"] = { name = "CandyCorn", use_current = current, use_max = required }
                elseif taskName == "Spend 500,000 Sheckles" then
                    m_data["SpendCurrency"] = { name = "Sheckles", use_current = current, use_max = required }
                else
                    --warn("Unknown task: " .. tostring(taskName))
                end

                if next(m_data) ~= nil then
                    table.insert(data, m_data)
                end

                --_Helper.JsonPrint(data)

                --warn("Task: "..taskName .. " Pro: "..current.."/"..required .. " complete")
                --warn("p:" .. Progress)
            end
        end
    end)

    if success then
        return data
    else
        warn("Error: ", results)
    end

    return nil
end












----------------------------------------------
----------- VulnManager
----------------------------------------------

VulnManager.AllBigDataKeys = {}

VulnManager.ReloadDataService = function()
    Varz.BigData = _S.DataService:GetData()
    VulnManager.AllBigDataKeys = {}
    if #VulnManager.AllBigDataKeys == 0 then
        for key, value in pairs(Varz.BigData) do
            table.insert(VulnManager.AllBigDataKeys, key)
        end
    end
end

VulnManager.ReloadDataService()




VulnManager.data_key = {}
VulnManager.HatchDataWebhook = {}
VulnManager.DataSaveSlots = {}

VulnManager.GetBigDataUsingKey = function(_key)
    return Varz.BigData[_key]
end

Varz.InventoryDataBind = VulnManager.GetBigDataUsingKey("InventoryData")
VulnManager.DataSaveSlots = VulnManager.GetBigDataUsingKey("SaveSlots")

GameDataManager.GetTotalEggsOnFarm = function()
    local count = 0
    local SaveSlots = VulnManager.DataSaveSlots
    for key, value in pairs(SaveSlots["AllSlots"]) do
        --warn("Key: " .. key)
        local SavedObjects = value.SavedObjects
        for uuid, sb in pairs(SavedObjects) do
            local ObjectType = sb.ObjectType
            local ob_data = sb.Data

            if ObjectType == "PetEgg" then
                local PetName = ob_data.Type
                local TimeToHatch = ob_data.TimeToHatch
                local CanOpen = ob_data.CanOpen
                local CanHatch = ob_data.CanHatch
                local BaseWeight = ob_data.BaseWeight
                local EggName = ob_data.EggName

                count = count + 1

                -- if TimeToHatch > 0 then
                --     --warn("This egg needs time to hatch: " .. TimeToHatch)
                --     --_Helper.JsonPrint(ob_data)
                --     count = count + 1
                --     continue
                -- end



                -- if not PetName or not BaseWeight then
                --     continue
                -- end
            end
        end
    end

    return count
end


_Helper.GetEggInformation = function()
    local SaveSlots = VulnManager.GetBigDataUsingKey("SaveSlots")
    for key, value in pairs(SaveSlots["AllSlots"]) do
        --warn("Key: " .. key)
        local SavedObjects = value.SavedObjects
        for uuid, sb in pairs(SavedObjects) do
            local ObjectType = sb.ObjectType
            local ob_data = sb.Data

            if ObjectType == "CosmeticCrate" then
                local CanOpen = ob_data.CanOpen
                if not CanOpen then
                    --warn("This crate not ready")
                    ---_Helper.JsonPrint(ob_data)
                    continue
                end
                --local TimeIsTimestamp = ob_data.TimeIsTimestamp
                local CosmeticType = ob_data.CosmeticType
                local CrateType = ob_data.CrateType
                Varz.found_crate_data[uuid] = { name = CrateType, reward = CosmeticType }
                --_Helper.JsonPrint(ob_data)
                continue
            end

            if ObjectType == "PetEgg" then
                local PetName = ob_data.Type
                local TimeToHatch = ob_data.TimeToHatch
                local CanOpen = ob_data.CanOpen
                local CanHatch = ob_data.CanHatch
                local BaseWeight = ob_data.BaseWeight
                local EggName = ob_data.EggName

                if TimeToHatch > 0 then
                    --warn("This egg needs time to hatch: " .. TimeToHatch)
                    --_Helper.JsonPrint(ob_data)
                    continue
                end

                if not PetName or not BaseWeight then
                    continue
                end

                local p_w = GetRealPetWeight(BaseWeight);
                Varz.found_pet_data[uuid] = { petname = PetName, weight = p_w }
            end
        end
    end
end



task.spawn(function()
    while true do
        task.wait(0.5)
        _Helper.GetEggInformation()
    end
end)

-- #data

GameDataManager.SetPetState = function()
    -- _S.ActivePetsService:FireServer("SetPetState", _S.LocalPlayer, pet_uuid, "Follow")
    local active_pets = FarmManager.GetActivePetsUUIDS()
    for _, value in ipairs(active_pets) do
        --_S.ActivePetService:SetPetState(value, "FollowPlayer")
        --_S.ActivePetsService.SetPetState(_S.LocalPlayer, value, "FollowPlayer")
        _S.ActivePetService:FireServer("SetPetState", value, "Idle")
        task.wait(0.1)
    end
end

-- for i, pet in ipairs(workspace:WaitForChild("PetsPhysical"):GetChildren()) do
--     local uuid = pet:GetAttribute("UUID") or (pet:FindFirstChild("UUID") and pet.UUID.Value) or (pet.Name .. " (InstanceID: " .. pet:GetDebugId() .. ")")
--    -- print("[" .. i .. "] UUID:", uuid)
--     game:GetService("ReplicatedStorage"):WaitForChild("GameEvents", 9e9):WaitForChild("ActivePetService", 9e9):FireServer("SetPetState", uuid, "Idle")
-- end
-- task.spawn(function()
--     while true do
--         task.wait(0.5)
--         GameDataManager.SetPetState()
--     end
-- end)


_Helper.vfx = {
    SetVisualEffect = function(_name, _val)
        game:GetService("ReplicatedStorage").GameEvents.SettingsService:FireServer(table.unpack({
            [1] = "SetSetting",
            [2] = _name,
            [3] = _val,
        }))
    end
}

GameDataManager.Inventory = {
    GetSettings = function()
        local settings = VulnManager.GetBigDataUsingKey("Settings")
        return settings
    end,
    GetCurrentPetsInData = function()
        -- new direct data
        local ls = {}
        local pet_data_inventory = GameDataManager.Inventory.GetPetInventory()

        for uuid, _petData in pairs(pet_data_inventory) do
            -- Ignore any fav pets
            local UUID = _petData.UUID
            if IsFavorite then
                -- continue
            end
            table.insert(ls, uuid)
        end
        return ls
    end,
    GetPetInventory = function()
        local ok, result = pcall(function()
            local datapets = VulnManager.GetBigDataUsingKey("PetsData")
            if not datapets then
                return {}
            end

            local inv = datapets["PetInventory"]
            if not inv or not inv.Data then
                return {}
            end

            return inv.Data
        end)

        return ok and result or {}


        -- local ok, pd = pcall(function()
        --     return _S.ActivePetsService:GetPlayerDatastorePetData(_S.LocalPlayer.Name)
        -- end)

        -- if not ok or not pd then
        --     return {} -- failed to fetch datastore
        -- end

        -- local ok2, inv = pcall(function()
        --     return pd.PetInventory and pd.PetInventory.Data
        -- end)

        -- if not ok2 or not inv then
        --     return {} -- missing inventory or data
        -- end

        -- return inv
    end,
    GetEquippedPets = function()
        local datapets = VulnManager.GetBigDataUsingKey("PetsData")
        local EquippedPets = datapets["EquippedPets"]
        return EquippedPets
    end,
    GetActivePetsAsKeyVal = function()
        local datazx = {}
        local datapets = VulnManager.GetBigDataUsingKey("PetsData")
        local EquippedPets = datapets["EquippedPets"]
        for index, value in ipairs(EquippedPets) do
            datazx[value] = true
        end
        return datazx
    end,
    GetTotalOwnedPets = function()
        local datapets = VulnManager.GetBigDataUsingKey("PetsData")
        if not datapets then
            return 0
        end
        local PetInventory_key = datapets["PetInventory"]
        local total_pets_in_inventory = 0

        if not PetInventory_key or not PetInventory_key.Data then
            return 0
        end
        -- count pets
        for _, _ in pairs(PetInventory_key.Data) do
            total_pets_in_inventory = total_pets_in_inventory + 1
        end

        return total_pets_in_inventory
    end,

    GetMaxEggsAndInventorySpaceCount = function()
        local datapets = VulnManager.GetBigDataUsingKey("PetsData")
        if not datapets then
            return 0, 0
        end
        local MutableStats_key = datapets["MutableStats"]

        if not MutableStats_key then
            return 0, 0
        end

        local MaxEggsInFarm = tonumber(MutableStats_key["MaxEggsInFarm"]) or 0
        local MaxPetsInInventory = tonumber(MutableStats_key["MaxPetsInInventory"]) or 0


        return MaxEggsInFarm, MaxPetsInInventory
    end,

    GetPetsInventoryCounts = function()
        local success, total_pets, max_pets = pcall(function()
            local datapets = VulnManager.GetBigDataUsingKey("PetsData")
            local PetInventory_key = datapets["PetInventory"]
            local MutableStats_key = datapets["MutableStats"]
            local EquippedPets = datapets["EquippedPets"]

            local MaxPetsInInventory = MutableStats_key["MaxPetsInInventory"]

            local total_pets_in_inventory = 0


            -- count pets
            for _, _ in pairs(PetInventory_key.Data) do
                total_pets_in_inventory = total_pets_in_inventory + 1
            end

            return total_pets_in_inventory, MaxPetsInInventory
        end)

        if success then
            return total_pets, max_pets
        end

        return 0, 0
    end,
    GetPetsCount_UI_TEXT = function()
        local success, r = pcall(function()
            local datapets = VulnManager.GetBigDataUsingKey("PetsData")
            local PetInventory_key = datapets["PetInventory"]
            local MutableStats_key = datapets["MutableStats"]
            local EquippedPets = datapets["EquippedPets"]

            local MaxEggsInFarm = MutableStats_key["MaxEggsInFarm"]
            local MaxEquippedPets = MutableStats_key["MaxEquippedPets"]
            local MaxPetsInInventory = MutableStats_key["MaxPetsInInventory"]

            local total_pets_in_inventory = 0
            local _color = "#00FF2A"

            -- count pets
            for _, _ in pairs(PetInventory_key.Data) do
                total_pets_in_inventory = total_pets_in_inventory + 1
            end

            if total_pets_in_inventory >= MaxPetsInInventory then
                _color = "#FF2C00"
            end

            -- UI text formatting
            local lines = {}
            table.insert(lines,
                string.format("Pets In Inventory: <font color='%s'>%s</font> / %s\n", _color, total_pets_in_inventory,
                    MaxPetsInInventory))
            table.insert(lines, string.format("Max Eggs Allowed: %s\n", MaxEggsInFarm))
            table.insert(lines, string.format("Max Pets Equip Allowed: %s\n", MaxEquippedPets))
            table.insert(lines, string.format("Eggs Planted: %s\n", GameDataManager.GetTotalEggsOnFarm()))



            return table.concat(lines)
        end)

        if success then return r end
        return ""
    end,
    GetEggsData = function()
        local saveslots = VulnManager.GetBigDataUsingKey("SaveSlots")

        for key, value in pairs(saveslots.AllSlots) do
            warn("Key: " .. key)
            _Helper.JsonPrint(value)
            warn("-----------------------")
        end
    end
}
--GameDataManager.Inventory.GetEggsData()


VulnManager.GetPlayerPetDataSnapshot = function()
    local ok, result = pcall(function()
        local datapets = VulnManager.GetBigDataUsingKey("PetsData")
        if not datapets then
            return {}
        end

        local inv = datapets["PetInventory"]
        if not inv or not inv.Data then
            return {}
        end

        for uuid, petdata in pairs(inv.Data) do
            snapshot[uuid] = petdata
        end

        return snapshot
    end)

    return ok and result or {}


    -- local ok, dx = pcall(function()
    --     local snapshot = {}

    --     local pd = _S.ActivePetsService:GetPlayerDatastorePetData(_S.LocalPlayer.Name)
    --     if not pd then
    --         return snapshot
    --     end

    --     local inv = pd.PetInventory
    --     if not inv or not inv.Data then
    --         return snapshot
    --     end

    --     for uuid, petdata in pairs(inv.Data) do
    --         snapshot[uuid] = petdata
    --     end

    --     return snapshot
    -- end)

    -- return ok and dx or {}
end


VulnManager.GetNewUUIDs = function(oldList, newList)
    local lookup = {}
    local result = {}

    -- Build lookup from old list
    for _, v in ipairs(oldList) do
        local id = type(v) == "table" and v.uuid or v
        if id then
            lookup[id] = true
        end
    end

    -- Find new UUIDs in new list
    for _, v in ipairs(newList) do
        local id = type(v) == "table" and v.uuid or v
        if id and not lookup[id] then
            table.insert(result, id)
        end
    end

    return result
end


VulnManager.GetHatchPetData = function(hatch)
    local addedPets = {}
    local failed = {}

    -- now check new pets list
    for _, uuid in ipairs(hatch) do
        local _petData = GetPetDataByUUID(uuid)
        if _petData then
            local PetData = _petData.PetData
            local PetType = _petData.PetType
            local HatchedFrom = PetData.HatchedFrom
            local Name = PetData.Name
            local Level = PetData.Level
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""

            -- skip non-hatched pets
            if MutationMachineManager.AllMutationListEnum[MutationType] then
                print("Mutation found")
                continue
            end

            -- skip non-hatchable pets
            if not IsPetHatchable(PetType) then
                print("Not on sell list: ", PetType)
                continue
            end

            local real_weight = GetRealPetWeight(BaseWeight, 1)
            real_weight = tonumber(string.format("%.2f", real_weight))

            table.insert(addedPets, {
                uuid = uuid,
                egg_name = HatchedFrom,
                pet_name = PetType,
                nickname = Name,
                level = Level,
                weight = real_weight,
            })
        else
            table.insert(failed, uuid)
            --print("No data for : ", uuid)
        end
    end

    return addedPets, failed
end

VulnManager.GetHatchPetDataxx = function(oldPetsx, newPetsx)
    local addedPets = {}

    -- create lookup for old pets
    local oldPets = {}
    for _, uuid in ipairs(oldPetsx) do
        oldPets[uuid] = true
    end

    -- now check new pets list
    for _, uuid in ipairs(newPetsx) do
        if not oldPets[uuid] then
            local _petData = GetPetDataByUUID(uuid)
            if _petData then
                local PetData = _petData.PetData
                local PetType = _petData.PetType
                local HatchedFrom = PetData.HatchedFrom
                local Name = PetData.Name
                local Level = PetData.Level
                local BaseWeight = PetData.BaseWeight
                local MutationType = PetData.MutationType or ""

                -- skip non-hatched pets
                if MutationMachineManager.AllMutationListEnum[MutationType] then
                    continue
                end

                -- skip non-hatchable pets
                if not IsPetHatchable(PetType) then
                    continue
                end

                local real_weight = GetRealPetWeight(BaseWeight, 1)
                real_weight = tonumber(string.format("%.2f", real_weight))

                table.insert(addedPets, {
                    uuid = uuid,
                    egg_name = HatchedFrom,
                    pet_name = PetType,
                    nickname = Name,
                    level = Level,
                    weight = real_weight,
                })
            else
                print("No data for : ", uuid)
            end
        end
    end

    return addedPets
end

VulnManager.GetHatchPetDatax = function(oldPetsx, newPetsx)
    local addedPets = {}

    local oldPets = {}
    local newPets = {}
    for _, value in ipairs(oldPetsx) do
        oldPets[value] = true
    end

    local inv = GameDataManager.Inventory.GetPetInventory()

    for uuid, _petData in pairs(inv) do
        if not oldPets[uuid] then
            local _UUID = _petData.UUID
            local PetData = _petData.PetData

            local PetType = _petData.PetType -- name of the name
            --local PetAbility = _petData.PetAbility

            local HatchedFrom = PetData.HatchedFrom -- "Fake Egg"
            --local IsFavorite = PetData.IsFavorite
            --local Boosts = PetData.Boosts
            local Name = PetData.Name
            local LevelProgress = PetData.LevelProgress
            --local EggName = PetData.EggName
            local Level = PetData.Level
            local Hunger = PetData.Hunger
            local BaseWeight = PetData.BaseWeight
            local MutationType = PetData.MutationType or ""
            --warn("Found pet: " .. Name)
            local CurrentMutationOnPet = MutationMachineManager.AllMutationListEnum[MutationType]
            if CurrentMutationOnPet then
                -- this is not hatched
                continue
            end

            if not IsPetHatchable(PetType) then
                continue
            end


            local real_weight = GetRealPetWeight(BaseWeight, 1)
            real_weight = tonumber(string.format("%.2f", real_weight)) -- rounds to 2 decimals

            local dx = {
                uuid = uuid,
                egg_name = HatchedFrom,
                pet_name = PetType,
                nickname = Name,
                level = Level,
                weight = real_weight,
            }
            table.insert(addedPets, dx)
        end
    end

    return addedPets
end

VulnManager.AutoSubmitHeld = {
    SubmitHeld = function()
        local batchSize = 2000 or 1000 -- default to 1000
        -- spawn tasks in parallel
        for i = 1, batchSize do
            task.spawn(function()
                -- _S.TieredPlants:FireServer("Held")
            end)
        end
    end
}

VulnManager.Visuals = {
    RewardDropVisual = function(object)
        if object.Name == "RewardDropVisual" then
            -- Destroy it immediately
            object:Destroy()
        end
    end

}

VulnManager.FoundMarmots = {}
VulnManager.FoundAcorn = {}



VulnManager.TeleportToTarget = function(target)
    --print("Goto Object Start")
    local success, result = pcall(function()
        -- Wait until the model has a PrimaryPart
        local positionVector = target:GetPivot().Position
        local hrp = _S.Character:FindFirstChild("HumanoidRootPart")
        -- Move the character to the Marmot Mound's position
        -- print("Goto Object")
        hrp.CFrame = CFrame.new(positionVector) + Vector3.new(0, 5, 0)
    end)

    if not success then
        warn("Error: ", tostring(result))
    end
end

VulnManager.TeleportModelToSelf = function(targetModel)
    if not targetModel or not targetModel:IsA("Model") then
        warn("TeleportToTarget: Invalid model")
        return
    end

    if not targetModel.PrimaryPart then
        warn("TeleportToTarget: Model has no PrimaryPart")
        return
    end

    local hrp = _S.Character and _S.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        warn("TeleportToTarget: HumanoidRootPart not found")
        return
    end

    local playerPos = hrp.Position
    local newPos = playerPos + Vector3.new(0, 5, 0) -- offset above you

    -- Teleport the model by setting its PrimaryPart CFrame
    local ok, err = pcall(function()
        targetModel:SetPrimaryPartCFrame(CFrame.new(newPos))
    end)

    if not ok then
        warn("TeleportToTarget error:", err)
    end
end


VulnManager.RedPanda = {
    updateInformation = function()
        if not UI_LABELS.lbl_redpanda_information then return end

        -- Use a table to efficiently build the final string
        local info_lines = {}
        -- Get the pre-calculated total, defaulting to 0 if it's nil
        local total_restocks = FSettings.red_panda_restock_total or 0

        table.insert(info_lines, string.format(
            "Total Restocks: <b><font color='#EF2E92'>%d</font></b>",
            total_restocks
        ))

        for itemName, itemCount in pairs(FSettings.red_panda_restock) do
            table.insert(info_lines, string.format(
                "%s: <b><font color='#00FF00'>%d</font></b>",
                itemName,
                itemCount
            ))
        end

        -- 3. Combine all lines and update the UI label
        UI_LABELS.lbl_redpanda_information:SetText(table.concat(info_lines, "\n"))
    end,
}

VulnManager.ChubbyChipmunk = {
    updateInformation = function()
        if not UI_LABELS.lbl_chubby_chipmunk_information then return end

        local info = string.format(
            "Chubby Chipmunk Event Collected: <b><font color='#EF2E92'>%d</font></b>\n" ..
            "Watering Can: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Event Lantern: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Godly Sprinkler: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Legendary Egg: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Reclaimer: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Nutty Crate: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Silver Fertilizer: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Nutty Chest: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Master Sprinkler: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Medium Treat: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Medium Toy: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Mythical Egg: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Grandmaster Sprinkler: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Rainbow Fertilizer: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Pet Mutation Shard Nutty: <b><font color='#FFF01F'>%d</font></b>",
            FOtherSettings.chubby_chipmunk_amount_collected or 0,
            FOtherSettings.chubby_chipmunk_item_watering_can or 0,
            FOtherSettings.chubby_chipmunk_item_event_lantern or 0,
            FOtherSettings.chubby_chipmunk_item_godly_sprinkler or 0,
            FOtherSettings.chubby_chipmunk_item_legendary_egg or 0,
            FOtherSettings.chubby_chipmunk_item_reclaimer or 0,
            FOtherSettings.chubby_chipmunk_item_nutty_crate or 0,
            FOtherSettings.chubby_chipmunk_item_silver_fertilizer or 0,
            FOtherSettings.chubby_chipmunk_item_nutty_chest or 0,
            FOtherSettings.chubby_chipmunk_item_master_sprinkler or 0,
            FOtherSettings.chubby_chipmunk_item_medium_treat or 0,
            FOtherSettings.chubby_chipmunk_item_medium_toy or 0,
            FOtherSettings.chubby_chipmunk_item_mythical_egg or 0,
            FOtherSettings.chubby_chipmunk_item_grandmaster_sprinkler or 0,
            FOtherSettings.chubby_chipmunk_item_rainbow_fertilizer or 0,
            FOtherSettings.chubby_chipmunk_item_petshardnutty or 0
        )

        UI_LABELS.lbl_chubby_chipmunk_information:SetText(info)
    end,

    Teleport = function(target)
        if not FOtherSettings.chubby_chipmunk_auto_collect then
            return
        end

        local success, result = pcall(function()
            VulnManager.TeleportToTarget(target)
            VulnManager.ChubbyChipmunk.updateInformation()
            SaveDataOther()
        end)

        if not success then
            warn("Error ", result)
        end
    end
}

VulnManager.Marmot = {
    updateInformation = function()
        if not UI_LABELS.lbl_marmot_information then return end

        local info = string.format(
            "Marmot Mound Collected: <b><font color='#EF2E92'>%d</font></b>\n" ..
            "Firefly Jar: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Maple Leaf Kite: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Sky Lantern: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Leaf Blower: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Maple Syrup: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Maple Sprinkler: <b><font color='#00FF00'>%d</font></b>\n" ..
            "Golden Acorn: <b><font color='#FFF01F'>%d</font></b>",
            FOtherSettings.marmot_amount_collected or 0,
            FOtherSettings.marmot_item_firefly or 0,
            FOtherSettings.marmot_item_maple_leaf_kite or 0,
            FOtherSettings.marmot_item_sky_lantern or 0,
            FOtherSettings.marmot_item_leaf_blower or 0,
            FOtherSettings.marmot_item_maple_syrup or 0,
            FOtherSettings.marmot_item_maple_sprinkler or 0,
            FOtherSettings.marmot_item_golden_acorn or 0
        )

        UI_LABELS.lbl_marmot_information:SetText(info)
    end,


    Teleport = function(mound)
        if not FOtherSettings.marmot_auto_collect then
            return
        end

        local success, result = pcall(function()
            VulnManager.TeleportToTarget(mound)
            VulnManager.Marmot.updateInformation()
            SaveDataOther()
        end)

        if not success then
            warn("Error ", result)
        end
    end
}



-- #test

_Helper.FireDigEvent = function(gridX, gridY, cframe)
    _S.DigRemote:FireServer(
        gridX,
        gridY,
        cframe
    )
end

_Helper.remain_digs = 0

_Helper.GetDigsLeft = function()
    local kx = "DiggingData"
    local datax = VulnManager.GetBigDataUsingKey(kx)
    local leftdigs = datax.RemainingDigs
    if leftdigs then
        _Helper.remain_digs = leftdigs
        return leftdigs
    end
    return 0
end

_Helper.FindAllRewards = function()
    local kx = "DiggingData"
    local datax = VulnManager.GetBigDataUsingKey(kx)
    local grid_data = datax.GridData
    local leftdigs = datax.RemainingDigs
    if leftdigs then
        _Helper.remain_digs = leftdigs
    end
    --warn("Digs: " .. leftdigs)
    local available_loc = {}
    for _, value in pairs(grid_data) do
        local IsTreasure = value.IsTreasure
        local GridY = value.GridY
        local GridX = value.GridX
        local IsDug = value.IsDug

        if leftdigs and leftdigs <= 0 then
            break
        end

        if IsDug then
            continue
        end

        if not IsTreasure then continue end


        local dx = {
            x = GridX,
            y = GridY
        }
        table.insert(available_loc, dx)

        -- _Helper.JsonPrint(value)
    end
    --_Helper.JsonPrint(available_loc)

    return available_loc
end

_Helper.ResetDig = function()
    pcall(function()
        local ui = _S.PlayerGui.Digging_UI.DiggingCompleteFrame.Visible
        if ui then
            local RestartDiggingSheckles = _S.ReplicatedStorage.GameEvents.DiggingMiniGame.RestartDiggingSheckles
            RestartDiggingSheckles:FireServer()
        end
    end)
end

_Helper.GetModelsFromGrid = function()
    local coordTable = _Helper.FindAllRewards()
    local results = {}
    local gridName = _S.LocalPlayer.Name .. "_DiggingGrid"
    local playerGrid = _S.Workspace:FindFirstChild(gridName)

    if not playerGrid then
        --warn("Digging grid not found for player: " .. playerName)
        return results
    end

    for _, coord in ipairs(coordTable) do
        for _, model in ipairs(playerGrid:GetChildren()) do
            local dirtPart = model:FindFirstChild("DirtPart")
            if dirtPart then
                local x = dirtPart:FindFirstChild("GridX")
                local y = dirtPart:FindFirstChild("GridY")
                if x and y and x.Value == coord.x and y.Value == coord.y then
                    local targetCFrame = dirtPart.CFrame
                    local datac = {
                        x = coord.x,
                        y = coord.y,
                        cf = targetCFrame
                    }
                    table.insert(results, datac)
                    break
                end
            end
        end
    end

    return results
end

_Helper.DigUseTickets = function()
    -- #dig
    local digtickets = "Dig Trinket"
    local havetrinket = InventoryManager.GetToolUsingName(digtickets)
    task.wait(0.2)
    if havetrinket then
        unequipTools()
        if not EquipToolOnChar(havetrinket) then
            return
        end
        local amount_left = 0
        if havetrinket:GetAttribute("e") then
            amount_left = havetrinket:GetAttribute("e")
        end

        if amount_left > 0 then
            -- try to use 10
            if amount_left >= 10 then
                amount_left = 10
            end
            for i = 1, amount_left, 1 do
                if Varz.IS_HATCHING then
                    break
                end

                if _Helper.GetDigsLeft() >= 10 then
                    break
                end

                if not havetrinket then
                    break
                end

                if not IsToolHeldNew(havetrinket) then
                    break
                end

                InventoryManager.TryUseGear(digtickets)
                task.wait(0.1)
            end
        end
        unequipTools()
    end
end

if TaskManager.task_letsdig then
    task.cancel(TaskManager.task_letsdig)
    TaskManager.task_letsdig = nil
end

-- #dig
TaskManager.task_letsdig = task.spawn(function()
    while true do
        task.wait(1)
        if not FSettings.halloween.auto_dig then
            task.wait(2)
            continue
        end

        if Varz.IS_HATCHING then
            task.wait(4)
            continue
        end

        Varz.IS_DIG = true
        pcall(function()
            _Helper.DigUseTickets()
        end)
        Varz.IS_DIG = false

        local cc = _Helper.GetModelsFromGrid()

        if #cc == 0 then
            --warn("Event not active")
            _Helper.ResetDig()
            task.wait(20)
            continue
        end

        if _Helper.remain_digs <= 0 then
            task.wait(5)
            --warn("No digs left")
            continue
        end

        Varz.IS_DIG = true
        pcall(function()
            _Helper.DigUseTickets()
        end)
        Varz.IS_DIG = false

        for _, ob in ipairs(cc) do
            local gx = ob.x
            local gy = ob.y
            local cf = ob.targetCFrame

            if Varz.IS_HATCHING then
                break
            end

            if _Helper.GetDigsLeft() <= 0 then
                break
            end

            _Helper.FireDigEvent(gx, gy, cf)
            task.wait(2)
        end
    end
end)

_Helper.OnSeedFoundByPets = function(model)
    local OWNER = model:GetAttribute("OWNER")
    local SEED_GIVEN = model:GetAttribute("SEED_GIVEN")

    if OWNER and SEED_GIVEN then
        print("Found seed ", SEED_GIVEN)
        if OWNER == _S.LocalPlayer.Name then
            print("tp to ", SEED_GIVEN)
            VulnManager.TeleportToTarget(model)
        end
    end
end



-------------- #workspace
-- Detect Marmot Mounds being added
_S.Workspace.ChildAdded:Connect(function(child)
    if child:IsA("Part") and child.Name == "JulyFirework" then
        child.Parent = _S.ReplicatedStorage.BenchmarkTest
        return
    end

    if child:IsA("Part") and child.Name == "SpottedEffect" then
        pcall(function()
            child.Parent = _S.ReplicatedStorage.BenchmarkTest
        end)
        return
    end

    if child:IsA("Sound") then
        --child:Destroy()
        child.Parent = _S.ReplicatedStorage.BenchmarkTest
        return
    end




    if child:IsA("Model") then
        if child.Name == "Marmot Mound" then
            table.insert(VulnManager.FoundMarmots, child)
        end

        if child.Name == "Acorn" then
            local owner = child:GetAttribute("OWNER")
            if owner and owner == Varz.player_userid then
                table.insert(VulnManager.FoundAcorn, child)
            end
        end
    end

    -- if child:IsA("Part") then
    --     child.Parent = _S.ReplicatedStorage
    --     return
    -- end

    --VulnManager.Visuals.RewardDropVisual(child)
end)

_S.Workspace.Visuals.ChildAdded:Connect(function(child)
    if child:IsA("Part") then
        child.Parent = _S.ReplicatedStorage.BenchmarkTest
        return
    end
end)

_S.Workspace.WeatherVisuals.ChildAdded:Connect(function(child)
    pcall(function()
        child.Parent = _S.ReplicatedStorage.BenchmarkTest
    end)
end)

-- #plants
_Helper.RemovePlantsOrFruitsLoop = function(plant)
    if not plant then
        warn("null plant")
        return
    end
    local delete_roots = FSessionDx.farm.delete_plants
    local delete_frutis = FSessionDx.farm.delete_fruits
    local is_parent_outside = FSessionDx.farm.change_parent

    if is_parent_outside then
        if Varz.alt_Plants_Physical then
            plant.Parent = Varz.alt_Plants_Physical
            return
        end
    end

    if delete_roots then
        for _, item in ipairs(plant:GetChildren()) do
            if (item:IsA("Part") or item:IsA("MeshPart")) and (item.Name ~= "Base" and item.Name ~= "PrimaryPart") then
                item:Destroy()
            end
        end
    end

    if delete_frutis then
        local fruits = plant:FindFirstChild("Fruits")
        if fruits then
            for _, fruit_item in ipairs(fruits:GetChildren()) do
                for _, item in ipairs(fruit_item:GetChildren()) do
                    if (item:IsA("Part") or item:IsA("MeshPart")) and (item.Name ~= "Base" and item.Name ~= "PrimaryPart") then
                        item:Destroy()
                    end
                end
            end
        end

        -- local Fruit_Spawn = plant:FindFirstChild("Fruit_Spawn")
        -- if Fruit_Spawn then
        --     for _, item in ipairs(Fruit_Spawn:GetChildren()) do
        --         item:Destroy()
        --     end
        -- end
    end
end

if TaskManager.task_plant_deleter then
    task.cancel(TaskManager.task_plant_deleter)
    TaskManager.task_plant_deleter = nil
end


TaskManager.task_plant_deleter = task.spawn(function()
    while true do
        task.wait(5)

        if not FSessionDx.farm.enable_delete_fruits then
            task.wait(3)
            continue
        end

        if Varz.IS_HATCHING then
            continue
        end

        if FarmManager.Plants_Physical then
            for index, value in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
                _Helper.RemovePlantsOrFruitsLoop(value)
            end
        end
    end
end)


-- _Helper.FindEventtemsInWorkSpace = function ()
--     warn("FindEventtemsInWorkSpace")
--     local fcount =0
--     for _, child in ipairs(_S.Workspace:GetChildren()) do
-- 			if not child:IsA("Model") then continue end
-- 			task.wait()

-- 			local name = child.Name
-- 			if name == "Marmot Mound" then
-- 				table.insert(VulnManager.FoundMarmots, child)
--             fcount = fcount + 1
-- 			elseif name == "Acorn" then
-- 				local owner = child:GetAttribute("OWNER")
-- 				if owner and owner == Varz.player_userid then
-- 					table.insert(VulnManager.FoundAcorn, child)
-- 					fcount = fcount + 1
-- 				end
-- 			end
-- 	end

-- 	warn("Found: " .. fcount)
-- end


-- task.spawn(function()
-- 	while true do -- scan every 3 seconds (adjust if needed)
-- 		task.wait(0.5)

-- 		if Varz.map_event_item_added then
--             _Helper.FindEventtemsInWorkSpace()
--             Varz.map_event_item_added = false
--             continue
--         end

--         task.wait(4)
--         _Helper.FindEventtemsInWorkSpace()


-- 	end
-- end)



if not _Helper.task_collect_objects then
    _Helper.task_collect_objects = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(2)

            -- Skip loop if no new items
            if #VulnManager.FoundMarmots > 0 then
                -- Remove the first item from the list
                local item = table.remove(VulnManager.FoundMarmots, 1)

                -- Teleport to that item

                VulnManager.Marmot.Teleport(item)


                task.wait(0.1) -- small delay after teleport
            end

            if #VulnManager.FoundAcorn > 0 then
                -- Remove the first item from the list
                local item = table.remove(VulnManager.FoundAcorn, 1)

                -- Teleport to that item

                VulnManager.ChubbyChipmunk.Teleport(item)


                task.wait(0.1) -- small delay after teleport
            end
        end
    end)
end



----------------------------------------------
-------- Water Manager
----------------------------------------------
WaterManager.UI = {
    UpdateProgress = function(_txt)
        if not UI_LABELS.lbl_watering_information then
            return
        end
        UI_LABELS.lbl_watering_information:SetText(_txt)
    end,

    UpdateStatus = function(_txt)
        if not UI_LABELS.lbl_watering_stats then
            return
        end
        UI_LABELS.lbl_watering_stats:SetText(_txt)
    end
}

WaterManager.Plants = {
    GetPlantsNotGrown = function()
        local fruitsToCollect = {}
        for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
            if not plantModel:IsA("Model") then continue end
            if not FOtherSettings.watering_list_plants[plantModel.Name] then continue end

            local potentialFruits = {}
            local fruitsFolder    = plantModel:FindFirstChild("Fruits")

            if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
                -- check if this actually has fruits inside because only multi harvest will have fruits inside.
                for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                    table.insert(potentialFruits, fruitx)
                end
            else
                table.insert(potentialFruits, plantModel)
            end

            -- Process any fruits found
            for _, fruit in ipairs(potentialFruits) do
                if not _FruitCollectorMachine.IsFruitGrown(fruit) then
                    table.insert(fruitsToCollect, fruit)
                end
            end
        end
        return fruitsToCollect
    end
}


WaterManager.Sprinkler = {
    PlaceGrandMaster = function(item_name)
        --Grandmaster Sprinkler

        local success, err = pcall(function()
            local tool = InventoryManager.GetSprinklerUsingName(item_name)
            if not tool then
                --warn("Dont have this item")
                return
            end
            local center = FarmManager.mFarm.Center_Point.Position
            local availablePositions = getGridSeedPositions(center)
            unequipTools()
            EquipToolOnChar(tool)
            task.wait(0.3)
            local placePos = availablePositions[math.random(1, #availablePositions)]
            if IsToolHeldNew(tool) then
                InventoryManager.PlaceSprinkler(placePos)
            end
            task.wait(0.9)
            unequipTools()
        end)
    end
}








-- #noti
-- Detect these, we detect these and use them
local ev_max_pet_inventory = "Not enough In Pet Inventory"
local ev_backpack_full = "max backpack space"
local ev_loaded_pets = "loaded pets"
local ev_max_eggs_reached = "max pet eggs"
local ev_lucky_sell = "from selling your pet"   --  when seal gives egg back
local ev_hatch_lucky = "egg has been recovered" -- when koi repaints
local ev_pet_inventoryfull = "you have reached the limit of pets"
local ev_max_garden_seeds = "Your garden is full"
local ev_recent_bloom = "recently Bloomed Fall! Please wait"
local ev_marmot = "You found the Marmot"
local ev_acorn = "You collected an Acorn"
local ev_redpanda = "Red Panda restocked"

local ev_acorn_added = "An Acorn appeared somewhere on the map"
local ev_marmot_added = "Marmot burrowed away! Try to find its burrow mound"

Varz.OnMarmotOrAcornAdded = function(_txt)
    --warn("Notification: ".._txt);
    Varz.map_event_item_added = true
end

Varz.ChubbyChipmunkNotifications = function(_txt)
    local success, err = pcall(function()
        -- Match quantity and item name
        local quantity, item = _txt:match("Reward:%s*(%d+)x%s*(.+)")
        quantity = tonumber(quantity)
        if not quantity or not item then return end

        -- Map
        local itemMap = {
            ["Watering Can"] = "chubby_chipmunk_item_watering_can",
            ["Event Lantern"] = "chubby_chipmunk_item_event_lantern",
            ["Godly Sprinkler"] = "chubby_chipmunk_item_godly_sprinkler",
            ["Legendary Egg"] = "chubby_chipmunk_item_legendary_egg",
            ["Reclaimer"] = "chubby_chipmunk_item_reclaimer",
            ["Nutty Crate"] = "chubby_chipmunk_item_nutty_crate",
            ["Silver Fertilizer"] = "chubby_chipmunk_item_silver_fertilizer",
            ["Nutty Chest"] = "chubby_chipmunk_item_nutty_chest",
            ["Master Sprinkler"] = "chubby_chipmunk_item_master_sprinkler",
            ["Medium Treat"] = "chubby_chipmunk_item_medium_treat",
            ["Medium Toy"] = "chubby_chipmunk_item_medium_toy",
            ["Mythical Egg"] = "chubby_chipmunk_item_mythical_egg",
            ["Grandmaster Sprinkler"] = "chubby_chipmunk_item_grandmaster_sprinkler",
            ["Rainbow Fertilizer"] = "chubby_chipmunk_item_rainbow_fertilizer",
            ["Pet Shard Nutty"] = "chubby_chipmunk_item_petshardnutty",
        }


        local key = itemMap[item]
        if key then
            FOtherSettings[key] = (FOtherSettings[key] or 0) + quantity
        end

        FOtherSettings.chubby_chipmunk_amount_collected = FOtherSettings.chubby_chipmunk_amount_collected + 1

        SaveDataOther()
        VulnManager.ChubbyChipmunk.updateInformation()
    end)

    if not success then
        warn("Error in ChubbyChipmunkNotifications:", err)
    end
end



Varz.MarmotNotifications = function(_txt)
    local success, err = pcall(function()
        -- Match quantity and item name
        local quantity, item = _txt:match("Reward:%s*(%d+)x%s*(.+)")
        quantity = tonumber(quantity)
        if not quantity or not item then return end

        -- Map
        local itemMap = {
            ["Firefly Jar"] = "marmot_item_firefly",
            ["Maple Leaf Kite"] = "marmot_item_maple_leaf_kite",
            ["Sky Lantern"] = "marmot_item_sky_lantern",
            ["Leaf Blower"] = "marmot_item_leaf_blower",
            ["Maple Syrup"] = "marmot_item_maple_syrup",
            ["Maple Sprinkler"] = "marmot_item_maple_sprinkler",
            ["Golden Acorn"] = "marmot_item_golden_acorn",
        }

        local key = itemMap[item]
        if key then
            FOtherSettings[key] = (FOtherSettings[key] or 0) + quantity
        end

        FOtherSettings.marmot_amount_collected = FOtherSettings.marmot_amount_collected + 1

        SaveDataOther()
        VulnManager.Marmot.updateInformation()
    end)

    if not success then
        warn("Error in MarmotNotifications:", err)
    end
end


Varz.RedPandaRestock = function(line)
    if not line then
        return
    end

    if not FSettings.red_panda_record_items then
        return
    end

    -- This greedy pattern correctly handles item names that contain " in the"
    local item = line:match("restocked%s+(.+)%s+in%s+the%s+.+$")

    if item then
        FSettings.red_panda_restock[item] = (FSettings.red_panda_restock[item] or 0) + 1
        --print("ðŸ§¾ Tracked:", "'" .. item .. "'", "(now", FSettings.red_panda_restock[item], "time(s))")
        FSettings.red_panda_restock_total = FSettings.red_panda_restock_total + 1
        SaveData() -- saves the FSettings object
    else
        warn("No item found in line:", line)
    end

    VulnManager.RedPanda.updateInformation()
end






Varz.Noti_Display = {
    activeNotifications = {},
    notificationLabel = nil,

    checkExpired = function(self)
        local currentTime = time()
        local didRemove = false
        local toRemove = {} -- 1. Create a list of items to remove

        -- 2. First loop: Find all expired items and mark them
        for text, data in pairs(self.activeNotifications) do
            if currentTime - data.expiryTime > 5 then
                table.insert(toRemove, text) -- Add the key to our remove list
                didRemove = true
            end
        end

        -- 3. Second loop: Safely remove all marked items
        if didRemove then
            for _, text in ipairs(toRemove) do
                self.activeNotifications[text] = nil
            end

            -- 4. Update the display once after all removals
            self:updateDisplay()
        end
    end,

    checkExpiredx = function(self)
        local currentTime = time()
        local didRemove = false -- Flag to check if we need to update

        for text, data in pairs(self.activeNotifications) do
            if currentTime - data.expiryTime > 5 then
                self.activeNotifications[text] = nil
                didRemove = true
            end
        end

        -- Update the display only if something was removed
        if didRemove then
            self:updateDisplay()
        end
    end,

    getOrCreateGui = function(self)
        if self.notificationLabel and self.notificationLabel.Parent then
            return self.notificationLabel
        end
        local player = _S.LocalPlayer
        if not player then return nil end
        local playerGui = _S.PlayerGui
        if not playerGui then return nil end

        local topMarginScale = 0.13 -- (e.g., 10% from the top)

        local camera = game.Workspace.CurrentCamera
        if not camera then return nil end

        -- 1. GET SCREEN HEIGHT (Reliable Method)
        local screenHeight = camera.ViewportSize.Y

        -- 2. CALCULATE FONT SIZE
        local fontsize = math.round(screenHeight / 38) -- Ratio (larger number = smaller font)
        fontsize = math.clamp(fontsize, 12, 18)        -- (Min 12px, Max 18px)

        local lbl_size = 0.6


        local notifyGui = playerGui:FindFirstChild("x_NotificationGui")
        if not notifyGui then
            notifyGui = Instance.new("ScreenGui")
            notifyGui.Name = "x_NotificationGui"
            notifyGui.DisplayOrder = 99999
            notifyGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            notifyGui.ResetOnSpawn = false
            notifyGui.Parent = playerGui
        end

        self.notificationLabel = notifyGui:FindFirstChild("NotificationDisplay")
        if not self.notificationLabel then
            self.notificationLabel = Instance.new("TextLabel")
            self.notificationLabel.Name = "NotificationDisplay"
            self.notificationLabel.Size = UDim2.new(lbl_size, 0, 0, 0)
            self.notificationLabel.AutomaticSize = Enum.AutomaticSize.Y
            --self.notificationLabel.Position = UDim2.new(0.5, 0, 0, topmargin)
            self.notificationLabel.TextWrapped = true
            self.notificationLabel.Position = UDim2.new(0.5, 0, topMarginScale, 0)
            self.notificationLabel.AnchorPoint = Vector2.new(0.5, 0)
            self.notificationLabel.BackgroundTransparency = 1
            self.notificationLabel.LineHeight = 1.2
            self.notificationLabel.RichText = true
            self.notificationLabel.Font = Enum.Font.SourceSansBold


            self.notificationLabel.TextColor3 = Color3.new(1, 1, 1)
            self.notificationLabel.TextSize = fontsize
            --  self.notificationLabel.TextStrokeTransparency = 0.3

            self.notificationLabel.TextStrokeColor3 = Color3.new(0, 0, 0) -- Set stroke to black
            self.notificationLabel.TextStrokeTransparency = 0.3           -- Set stroke to be solid (not transparent)

            self.notificationLabel.TextXAlignment = Enum.TextXAlignment.Center
            self.notificationLabel.TextYAlignment = Enum.TextYAlignment.Top
            self.notificationLabel.Text = ""
            self.notificationLabel.Parent = notifyGui
        end

        local gradient = self.notificationLabel:FindFirstChildOfClass("UIGradient")
        if not gradient then
            gradient = Instance.new("UIGradient")
            -- Make it go from White (0.0) to Light Grey (1.0)
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 255, 255)), -- White
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 200, 200))  -- Light grey
            })
            -- Make the gradient vertical (top-to-bottom)
            gradient.Rotation = 90
            gradient.Parent = self.notificationLabel
        end

        return self.notificationLabel
    end,

    updateDisplay = function(self)
        if not self.notificationLabel then
            -- Call getOrCreateGui in case the label was destroyed
            if not self:getOrCreateGui() then
                return -- Still couldn't create it
            end
        end

        local textLines = {}
        for _, data in pairs(self.activeNotifications) do
            if data.count > 1 then
                table.insert(textLines, data.text .. " <font color='#ffff00'>[x" .. data.count .. "]</font>")
            else
                table.insert(textLines, data.text)
            end
        end

        self.notificationLabel.Text = table.concat(textLines, "\n")
    end
}

_Helper.ShowNotification = function(text)
    -- Make sure the GUI is created and the loop is running
    Varz.Noti_Display:getOrCreateGui()

    -- if not string.find(text, "Queen Bee") then
    --     return
    -- end

    local existing = Varz.Noti_Display.activeNotifications[text]
    local newExpiryTime = time()

    if existing then
        -- STACK: Notification already exists
        existing.count = existing.count + 1
        existing.expiryTime = newExpiryTime -- Just update the timer
    else
        -- NEW: Create a new entry
        Varz.Noti_Display.activeNotifications[text] = {
            text = text,
            count = 1,
            expiryTime = newExpiryTime -- Set the timer
        }
    end

    -- Update the text on-screen immediately
    Varz.Noti_Display:updateDisplay()
end


if TaskManager.task_notification_live then
    task.cancel(TaskManager.task_notification_live)
    TaskManager.task_notification_live = nil
end
TaskManager.task_notification_live = task.spawn(function()
    while true do
        task.wait(0.5)
        pcall(function()
            Varz.Noti_Display:checkExpired()
        end)
    end
end)



local function HandleNotificationX(arg)
    -- This listens to any Notifications
    --print("Notification: "..tostring(arg));
    if strongContains(arg, ev_max_pet_inventory) then
        Varz.max_pet_inventory_space = true
    end

    if strongContains(arg, ev_redpanda) then
        Varz.RedPandaRestock(arg)
    end


    if strongContains(arg, ev_acorn_added) then
        --warn("Notification: "..tostring(arg));
        Varz.OnMarmotOrAcornAdded(arg)
    end

    if strongContains(arg, ev_marmot_added) then
        --warn("Notification: "..tostring(arg));
        Varz.OnMarmotOrAcornAdded(arg)
    end

    if strongContains(arg, ev_acorn) then
        --warn("Notification: "..tostring(arg));
        Varz.ChubbyChipmunkNotifications(arg)
    end

    if strongContains(arg, ev_marmot) then
        --warn("Notification: "..tostring(arg));
        Varz.MarmotNotifications(arg)
    end

    if strongContains(arg, ev_recent_bloom) then
        -- -- max seeds limit
        --warn("Notification: "..tostring(arg));
        Varz.recent_bloom_fall_notfi = true
    end

    if strongContains(arg, ev_max_garden_seeds) then
        -- Max seeds limit
        --warn("Notification"..tostring(arg));
        Varz.is_garden_full_seed = true
    end

    if strongContains(arg, ev_max_eggs_reached) then
        -- max eggs on farm
        --warn("Notification"..tostring(arg));
        Varz.is_max_eggs_reached = true
    end

    if strongContains(arg, ev_lucky_sell) then
        -- egg back, seal egg back
        --warn("Notification"..tostring(arg));
        got_eggs_back = got_eggs_back + 1
        Varz.has_seal_sold_happen = true
    end

    if strongContains(arg, ev_hatch_lucky) then
        -- egg recovered , koi repaint
        --warn("Notification"..tostring(arg));
        recovered_eggs = recovered_eggs + 1
        Varz.has_koi_repaint = true
    end

    if strongContains(arg, ev_backpack_full) then
        --  backpack is full
        Varz.backpack_full = true
        --warn("Notification"..tostring(arg));
    end

    -- Loaded pets
    if strongContains(arg, ev_loaded_pets) then
        -- Handle loaded pets here
        -- load out pets load complete
        --warn("Notification"..tostring(arg));
        is_loadout_ready = true
    end

    -- pet inventory full
    if strongContains(arg, ev_pet_inventoryfull) then
        -- if pet inventory is full
        --warn("Notification"..tostring(arg));
        is_pet_inventory_full = true
    end
end

_Helper.DestroyNotification = function()
    pcall(function()
        local top = _S.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("Top_Notification")
        top:Destroy()
    end)
end

if FSettings.use_noti then
    _Helper.DestroyNotification()
end

-- #noti
local function watchNotificationEvents()
    --print("started watch: Notification");
    -- Hook Notification remote
    local rs = game:GetService("ReplicatedStorage")
    local notificationRemote = rs:WaitForChild("GameEvents"):WaitForChild("Notification")

    notificationRemote.OnClientEvent:Connect(function(...)
        for _, arg in ipairs({ ... }) do
            -- Display this notification, max 3s time to live, if user gets same notification then stack them together like "some text [x111]"
            if type(arg) == "string" then
                HandleNotificationX(arg);
            end
            if FSettings.use_noti then
                pcall(function()
                    _Helper.ShowNotification(arg)
                end)
            end
        end
    end)
end

watchNotificationEvents();





-- #AgeBreak #age #break
--========= Age Break Machine
PetMutation.AgeBreakMachine = {
    cache = {},
    PetAgeBreakMachine_Data = {},
    STATES = {
        EMPTY = "EMPTY",                           -- Machine is empty
        SUBMITTED = "SUBMITTED",                   -- Pet is in the machine, but not started
        RUNNING = "RUNNING",                       -- Machine is processing the pet
        READY_TO_CLAIM = "READY_TO_CLAIM",         -- Pet is finished and ready to claim
        BYPASS_EMPTY_READY = "BYPASS_EMPTY_READY", -- In this state the machine will be ready and u can submit a pet and it will be ready right away, rare case
        UNKNOWN = "UNKNOWN"                        -- Fallback for an unrecognized state
    },


    SubmitHeld = function()
        pcall(function()
            _S.GameEvents.PetAgeLimitBreak_SubmitHeld:FireServer()
        end)
    end,
    SubmitDups = function(_list)
        --- Starts the machine
        pcall(function()
            _S.GameEvents.PetAgeLimitBreak_Submit:FireServer(_list)
        end)
    end,
    ClaimPet = function()
        pcall(function()
            _S.GameEvents.PetAgeLimitBreak_Claim:FireServer()
        end)
    end,
    CancelPet = function()
        pcall(function()
            _S.GameEvents.PetAgeLimitBreak_Cancel:FireServer()
        end)
    end,

    GetTimeRemainingStatusText = function()
        local data = PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data
        local state = PetMutation.AgeBreakMachine.GetState()
        local states = PetMutation.AgeBreakMachine.STATES

        -- Select text based on the current state
        if state == states.RUNNING then
            local raw_seconds = data.TimeLeft or 0
            return _Helper.fmt_time(raw_seconds)
        else
            return "00.00"
        end
    end,

    GetPetName = function()
        local data = PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data
        if not data or not data.SubmittedPet or not data.SubmittedPet.PetData then
            return nil
        end

        local sub = data.SubmittedPet
        local PetData = sub.PetData

        local PetType = sub.PetType
        return PetType
    end,


    PetDetails = function()
        local max_lvl = tonumber(FSettings.agebreak.max_level) or 125
        local data = PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data
        local timeleft = PetMutation.AgeBreakMachine.GetTimeRemainingStatusText()

        if not data or not data.SubmittedPet or not data.SubmittedPet.PetData then
            return "<font color='#FF4444'>No pet submitted.</font>"
        end

        local sub = data.SubmittedPet
        local PetData = sub.PetData

        local PetType = sub.PetType
        local Name = PetData.Name
        local BaseWeight = PetData.BaseWeight
        local Level = PetData.Level
        local weight = GetRealPetWeight(BaseWeight, Level)

        -- Simple colour ranges
        local diff = max_lvl - Level
        local _levelcolor
        if diff <= 1 then
            _levelcolor = "#27F527" -- green, almost max
        elseif diff <= 5 then
            _levelcolor = "#F5E027" -- yellow, close
        else
            _levelcolor = "#F52727" -- red, far
        end
        -- Make color based on how close we are to the target level.
        local display_level = string.format("(<font color='%s'>%s</font>/%s)", _levelcolor, Level, max_lvl)

        -- styled single-line format
        local str = string.format(
            "<font color='#8BE9FD'>[AgeBreak]</font> " ..
            "<font color='#FFFFFF'>Lv.%s</font> " ..
            "<font color='#BD93F9'>%s</font><font color='#FFB86C'>(%s)</font> " ..
            "<font color='#8BE9FD'>[%.2f KG]</font> - <font color='#FF79C6'>%s</font>",
            display_level,
            PetType, Name,
            weight,
            timeleft
        )

        return str
    end,

    UpdateAgebreakStatus = function(_txt)
        if UI_LABELS.lbl_agebreak_status then
            UI_LABELS.lbl_agebreak_status:SetText(_txt)
        end
        Varz.TEXT_AGEBREAK = _txt
    end,

    Fav = function(_tool, makeFav) -- makeFav = true (to favorite), false (to unfavorite)
        if not _tool then return false end

        -- Get the pet's current favorite state (true if fav, false if not)
        local isCurrentlyFavorite = _tool:GetAttribute("d") or false

        -- Only act if the current state is DIFFERENT from the desired state
        if isCurrentlyFavorite ~= makeFav then
            MakeFruitsFavSingle(_tool) -- Call the toggle function
            task.wait(0.3)
            return true
        end
        return false
    end,


    GetPetToSubmit = function()
        local user_list = FSettings.agebreak.target_team
        local tool = nil
        local petname = ""
        local max_level = tonumber(FSettings.agebreak.max_level) or 125
        local min_lvl = 100
        if #user_list == 0 then
            return tool, petname
        end
        local found_uuid = nil
        for _, uuid in ipairs(user_list) do
            local pet_data = GetPetDataByUUID(uuid)
            if not pet_data then continue end
            local pet_level = pet_data.PetData.Level
            local basekg = pet_data.PetData.BaseWeight
            local petWeight = GetRealPetWeight(basekg, pet_level)
            local petName = pet_data.PetType
            petname = petName
            if pet_level < min_lvl then
                -- under level
                continue
            end

            -- skill pets already maxed
            if pet_level >= max_level then
                continue
            end

            found_uuid = uuid
            break
        end

        if found_uuid then
            tool = InventoryManager.GetPetUsingUUID(found_uuid)
            return tool, petname
        end
        return tool, petname
    end,

    GetDupsForTarget = function(_petname)
        local targetPetName = nil
        local is_filter_enabled_weight = FSettings.agebreak.avoid_weight_filter or false
        local is_filter_enabled_age = FSettings.agebreak.avoid_age_filter or true

        if _petname then
            targetPetName = _petname
        else
            targetPetName = PetMutation.AgeBreakMachine.GetPetName()
        end
        local petlists = {}
        if not targetPetName then
            return petlists
        end

        local user_list = FSettings.agebreak.dup_team
        if #user_list == 0 then
            return petlists
        end

        for _, uuid in ipairs(user_list) do
            local pet_data = GetPetDataByUUID(uuid)
            if not pet_data then continue end
            local pet_level = pet_data.PetData.Level
            local basekg = pet_data.PetData.BaseWeight
            local petWeight = GetRealPetWeight(basekg, pet_level)
            local petWeight_baselvl = GetRealPetWeight(basekg, 1)
            local petName = pet_data.PetType

            -- Apply filters, prevent units

            local filter_base_weight = 3.5 -- units over this KG will be ignored
            local filter_level_min = 99    -- units over this level will be ignored

            if is_filter_enabled_weight and petWeight_baselvl >= filter_base_weight then
                continue
            end

            if is_filter_enabled_age and pet_level >= filter_level_min then
                continue
            end


            if petName == targetPetName then
                table.insert(petlists, uuid)
                return petlists
            end
        end
        return petlists
    end,
    AssignData = function()
        -- must be called right away
        PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data = VulnManager.GetBigDataUsingKey("PetAgeBreakMachine")
    end,
    GetSubmittedPetUUID = function()
        local data = PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data
        if data and data.SubmittedPet and data.SubmittedPet.UUID then
            return data.SubmittedPet.UUID
        end
        return nil
    end,
    FindModel = function()
        local _name = "PetAgeMachine"
        if PetMutation.AgeBreakMachine.cache[_name] then
            return PetMutation.AgeBreakMachine.cache[_name]
        end
        local modelx = FallEventManager.findInWorkspace(_name, "Model")
        if modelx then
            PetMutation.AgeBreakMachine.cache[_name] = modelx
        end
        return PetMutation.AgeBreakMachine.cache[_name]
    end,

    MakeWebhookData = function(_uuid)
        local pet_data = GetPetDataByUUID(_uuid)
        local max_level = tonumber(FSettings.agebreak.max_level) or 125
        if not pet_data then return false end
        local pet_level = pet_data.PetData.Level
        local basekg = pet_data.PetData.BaseWeight
        local petWeight = GetRealPetWeight(basekg, pet_level)
        local petName = pet_data.PetType
        local nickName = pet_data.PetData.Name
        local _dta = {
            pet_name = petName,
            nickname = nickName,
            level = pet_level,
            required_level = max_level,
            weight = petWeight
        }
        table.insert(MutationMachineManager.AgeBreakWebHook, _dta)
    end,

    -- Helper function to get the current state as a string
    GetState = function()
        local data = PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data
        local states = PetMutation.AgeBreakMachine.STATES

        -- No pet inside, but the machine says it's ready. This means we can submit and claim right away later
        if data and not data.SubmittedPet and data.PetReady and not data.IsRunning then
            return states.BYPASS_EMPTY_READY
        end

        -- State 1: EMPTY
        -- No data or no submitted pet
        if not data or not data.SubmittedPet then
            return states.EMPTY
        end

        -- State 4: READY_TO_CLAIM
        -- Pet is ready, however, if it has no pet inside? so we must check if there is a pet inside
        if data.PetReady and data.SubmittedPet and not data.IsRunning then
            return states.READY_TO_CLAIM
        end

        -- State 3: RUNNING
        -- Pet is submitted and machine is running
        if data.IsRunning and data.TimeLeft > 0 then
            return states.RUNNING
        end

        -- State 2: SUBMITTED
        -- Pet is submitted, but machine is not running
        if data.SubmittedPet and not data.IsRunning and not data.PetReady then
            return states.SUBMITTED
        end

        -- Fallback state
        return states.UNKNOWN
    end,


}

-- Important
PetMutation.AgeBreakMachine.AssignData()



if TaskManager.task_agebreak_machine then
    task.cancel(TaskManager.task_agebreak_machine)
    TaskManager.task_agebreak_machine = nil
end

-- #ageloop #breakloop #age
TaskManager.task_agebreak_machine = task.spawn(function()
    while true do
        task.wait(1.5)

        local agebreak = PetMutation.AgeBreakMachine
        local current_state = agebreak.GetState()
        local states = agebreak.STATES
        local is_enabled = FSettings.agebreak.is_active_agebreak

        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            agebreak.UpdateAgebreakStatus("ðŸ”´ [Age Break] Is Waiting for farm data to load.")
            task.wait(5)
            continue
        end

        if not is_enabled then
            agebreak.UpdateAgebreakStatus("ðŸ”´ Not Enabled.")
            task.wait(3)
            continue
        end

        if Varz.IS_HATCHING then
            local _txt = agebreak.PetDetails()
            agebreak.UpdateAgebreakStatus("[ðŸŸ¡ Hatching] " .. _txt)
            task.wait(3)
            continue
        end

        if Varz.IsPaused() then
            agebreak.UpdateAgebreakStatus("ðŸ”´ [Age Break] Systems are paused by user.")
            task.wait(5)
            continue
        end


        -- print("State: ", current_state)
        --_Helper.JsonPrint(PetMutation.AgeBreakMachine.PetAgeBreakMachine_Data)

        -- Ready to claim
        if current_state == states.READY_TO_CLAIM then
            local uuid = agebreak.GetSubmittedPetUUID()
            -- warn("Pet Ready to claim ", uuid)
            agebreak.ClaimPet()
            task.wait(5)
            agebreak.MakeWebhookData(uuid)
            task.wait(0.5)
            -- Fav this pet
            local tool = InventoryManager.GetPetUsingUUID(uuid)
            if tool then
                local setfav = true
                agebreak.Fav(tool, setfav)
                task.wait(2.3)
            end
            unequipTools()
            UpdatePetData()
            continue
        end

        if current_state == states.EMPTY then
            -- Here we can submit a pet to the machine
            -- we can only submit one so this will return tool
            agebreak.UpdateAgebreakStatus("ðŸŸ¡ Empty machine, trying to find pet to submit.")
            task.wait(0.5)
            local pet_tool, petname = agebreak.GetPetToSubmit()
            if not pet_tool then
                agebreak.UpdateAgebreakStatus(
                    "ðŸ”´ [Age Break] Unable to find any pets to submit. If the pet is active please remove it from the farm.")
                task.wait(5)
                continue
            end

            -- Also check if there are any dups for this pet.
            local ls = agebreak.GetDupsForTarget(petname)
            if #ls == 0 then
                agebreak.UpdateAgebreakStatus(
                    "ðŸ”´ [Age Break] Current Pet has no dups assigned. Please select dupes for all pets.")
                task.wait(5)
                continue
            end

            Varz.IS_MUTATION_RUNNING = true
            task.wait(2.5)

            unequipTools()
            task.wait(0.5)
            if not EquipToolOnChar(pet_tool) then
                agebreak.UpdateAgebreakStatus("ðŸ”´ [Age Break] Failed to equip this pet, will try again.")
                task.wait(5)
                Varz.IS_MUTATION_RUNNING = false
                continue
            end

            -- Unfav the pet.
            agebreak.UpdateAgebreakStatus("â¤ï¸ Remove fav if it is.")
            local setfav = false
            agebreak.Fav(pet_tool, setfav)
            task.wait(2.3)

            -- now submit it
            agebreak.UpdateAgebreakStatus("âœ… Submit pet.")
            agebreak.SubmitHeld()
            task.wait(3)
            Varz.IS_MUTATION_RUNNING = false
            continue
        end

        if current_state == states.RUNNING then
            -- its running
            local _txt = agebreak.PetDetails()
            agebreak.UpdateAgebreakStatus(_txt)
            continue
        end

        if current_state == states.SUBMITTED then
            -- here submit dups and start the machine
            --warn("Found submitted pet, add dupes")
            local ls = agebreak.GetDupsForTarget()
            if #ls == 0 then
                agebreak.UpdateAgebreakStatus("ðŸ”´ [Age Break] No dupes found for this pet.")
                task.wait(5)
                continue
            end

            agebreak.UpdateAgebreakStatus("â™»ï¸ Checking and finding dupes")
            local finallist = {}
            for _, uuid in ipairs(ls) do
                local tool = InventoryManager.GetPetUsingUUID(uuid)
                if tool then
                    -- remove fav from this
                    local setfav = false
                    agebreak.Fav(tool, setfav)
                    table.insert(finallist, uuid)
                    task.wait(0.2)
                end
            end
            task.wait(2)
            agebreak.UpdateAgebreakStatus("âœ… Submit dupes and starting.")

            -- send these to machine and start
            agebreak.SubmitDups(finallist)
            task.wait(2)
            continue
        end



        -- end of loop
    end
end)


-- #middle
_Helper.TeleportToFarmMiddle = function()
    if FSettings.char_farm_middle then
        local center = FarmManager.mFarm.Center_Point.Position
        TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(center))
    end
end

task.spawn(function()
    pcall(function()
        _Helper.TeleportToFarmMiddle()
    end)
end)




---------------------------------------------------
-- ============== Cooking
---------------------------------------------------

CookingManager.Update_AllTimers = function()
    if not UI_LABELS.lbl_cooking_display_time then return nil end
    local make_nice_text = ""

    for _uuid, _txtTime in pairs(CookingManager.TimeDisplayPots) do
        local uidcolor = _Helper.StringToColor3(_uuid)
        make_nice_text = make_nice_text .. "<font color='" .. uidcolor .. "'>" .. _uuid .. "</font> " .. _txtTime .. "\n"
    end

    UI_LABELS.lbl_cooking_display_time:SetText(make_nice_text)
end

CookingManager.Update_AllStatus = function(_txt)
    if UI_LABELS.lbl_cooking_stats then
        UI_LABELS.lbl_cooking_stats:SetText(_txt)
    end
end

CookingManager.GetAllCookingPots = function()
    local cooking_pots = {}
    for _, part in ipairs(FarmManager.Cosmetic_Physical:GetChildren()) do
        local CosmeticUUID = part:GetAttribute("CosmeticUUID")
        local cookModel = part:FindFirstChild("Cooking Kit")
        if cookModel and CosmeticUUID then
            cooking_pots[CosmeticUUID] = cookModel
        end
    end
    if next(cooking_pots) == nil then
        return nil
    end
    return cooking_pots
end

CookingManager.GetFoodFromPot = function(_uuid)
    _S.CookingPotService_RE:FireServer("GetFoodFromPot", _uuid)
    task.wait(0.1 + CookingManager.SpeedOffset)
end

CookingManager.GetTimeLeftUntilDone = function(model)
    if not model then return false end
    local success, result = pcall(function()
        return model.CookTimeDisplay.Face.SurfaceGui.TimeDisplayFrame.TimeLabel.Text
    end)


    if not success then
        -- warn("error: " , result)
    end
    return success and result or false
end

-- check if skip is enabled, means its cooking
CookingManager.GetIsCooking = function(model)
    if not model then return false end
    local success, result = pcall(function()
        return model.CookingPotPart.SkipCookingProxPrompt.Enabled
    end)

    return success and result == true
end

-- this will enabled when its ready to collect
CookingManager.IsReadyToCollect = function(model)
    if not model then return false end
    local success, result = pcall(function()
        return model.CookingPotPart.GetFoodProxPrompt.Enabled
    end)
    return success and result == true
end

-- both must be false to return true
CookingManager.IsReadyForNewCooking = function(model)
    if not model then return false end

    local success, result = pcall(function()
        local getFoodEnabled = model.CookingPotPart.GetFoodProxPrompt.Enabled
        local skipCookingEnabled = model.CookingPotPart.SkipCookingProxPrompt.Enabled
        return not getFoodEnabled and not skipCookingEnabled
    end)

    return success and result == true
end


CookingManager.BeginCooking = function(_uuid)
    -- cook it
    _S.CookingPotService_RE:FireServer("CookBest", _uuid)
    --warn("Cooking started on pot: " .. _uuid)
    return true
end

CookingManager.EmptyPot = function(_uuid)
    -- Empty
    _S.CookingPotService_RE:FireServer("EmptyPot", _uuid)
    --warn("Empty pot: " .. _uuid)
    return true
end

CookingManager.PutFruitIntoPot = function(_uuid)
    -- submit held plant
    _S.CookingPotService_RE:FireServer("SubmitHeldPlant", _uuid)
    task.wait(0.01 + CookingManager.SpeedOffset)
end

CookingManager.SubmitAllFruits = function(uuid, _listfruittools)
    -- empty it

    CookingManager.EmptyPot(uuid)
    task.wait(0.3)
    for _, fruit in ipairs(_listfruittools) do
        local timeoutx = 20
        while Varz.IS_HATCHING or Varz.QUEST_TASK_RUNNING or Varz.IS_SEEDING or Varz.IS_SHOVELING do
            if timeoutx <= 0 then
                Varz.QUEST_TASK_RUNNING = false
                break
            end
            task.wait(3)
            timeoutx = timeoutx - 1
            continue
        end
        unequipTools()
        task.wait(0.1 + CookingManager.SpeedOffset)
        EquipToolOnChar(fruit)
        task.wait(0.2 + CookingManager.SpeedOffset)
        CookingManager.PutFruitIntoPot(uuid)
        task.wait(0.2 + CookingManager.SpeedOffset)
        unequipTools()
        task.wait(0.1 + CookingManager.SpeedOffset)
    end


    task.wait(0.4 + CookingManager.SpeedOffset)
    CookingManager.BeginCooking(uuid)
    task.wait(0.2 + CookingManager.SpeedOffset)
end

CookingManager.CheckAndPlaceNewPlants = function(list_array)
    if not list_array or #list_array == 0 then
        return false
    end
    -- check if we have them
    local ls = {}
    for _, fruitName in ipairs(list_array) do
        if not _FruitCollectorMachine.HasPlantByName(fruitName) then
            table.insert(ls, fruitName)
        end
    end

    if #ls == 0 then
        return false
    end
    --_Helper.JsonPrint(ls)
    _FruitCollectorMachine.PlantsTrees(ls)
    task.wait(2)
    return true
end

CookingManager.GatherAllRequiredIngredients = function(_uuid)
    local list_ingredient = {}
    if FOtherSettings.cook_potone_item1 ~= nil and FOtherSettings.cook_potone_item1 ~= "-" then
        table.insert(list_ingredient, FOtherSettings.cook_potone_item1)
    end

    if FOtherSettings.cook_potone_item2 ~= nil and FOtherSettings.cook_potone_item2 ~= "-" then
        table.insert(list_ingredient, FOtherSettings.cook_potone_item2)
    end

    if FOtherSettings.cook_potone_item3 ~= nil and FOtherSettings.cook_potone_item3 ~= "-" then
        table.insert(list_ingredient, FOtherSettings.cook_potone_item3)
    end

    if FOtherSettings.cook_potone_item4 ~= nil and FOtherSettings.cook_potone_item4 ~= "-" then
        table.insert(list_ingredient, FOtherSettings.cook_potone_item4)
    end

    if FOtherSettings.cook_potone_item5 ~= nil and FOtherSettings.cook_potone_item5 ~= "-" then
        table.insert(list_ingredient, FOtherSettings.cook_potone_item5)
    end

    if #list_ingredient == 0 then
        --warn("Ingredient list is empty")
        return false
    end

    -- convert list_ingredient to key/value
    local whitelist = {}
    for _, fname in ipairs(list_ingredient) do
        if not whitelist[fname] then
            whitelist[fname] = 0
        end
        whitelist[fname] = whitelist[fname] + 1
    end

    local dont_have_fruits = {}

    -- we have ingredient, find and submit
    local list_found_fruits = {}
    local current_fruit_count = {}

    for _, fruit in ipairs(_S.Backpack:GetChildren()) do
        if not fruit:IsA("Tool") then continue end
        if fruit:GetAttribute("d") then continue end
        if fruit:GetAttribute("b") ~= "j" then continue end
        local fname = fruit:GetAttribute("f")
        if not whitelist[fname] then continue end
        current_fruit_count[fname] = current_fruit_count[fname] or 0
        if current_fruit_count[fname] >= whitelist[fname] then
            -- we reached max for this fruit
            continue
        end
        current_fruit_count[fname] = current_fruit_count[fname] + 1
        table.insert(list_found_fruits, fruit)
    end
    -- check what we missed
    -- list_ingredient {"Coconut","Apple","Apple","Apple"}
    -- whitelist {["Apple"] = 3, ["Coconut"] = 1}
    -- current_fruit_count = {["Apple"] = 1}
    -- not found should be {"Coconut","Apple","Apple"}
    local counted = {}

    for _, fruitName in ipairs(list_ingredient) do
        counted[fruitName] = counted[fruitName] or 0
        local haveCount = current_fruit_count[fruitName] or 0
        local needCount = whitelist[fruitName] or 0

        if counted[fruitName] < needCount - haveCount then
            table.insert(dont_have_fruits, fruitName)
            counted[fruitName] = counted[fruitName] + 1
        end
    end


    if #list_found_fruits < #list_ingredient then
        if FOtherSettings.cooking_autocollect_required then
            if #dont_have_fruits > 0 then
                CookingManager.Update_AllStatus("ðŸ’ Collect/Plant required fruits..")
                -- Plant if we missing any fruits
                if FOtherSettings.cooking_autoplant_required then
                    CookingManager.CheckAndPlaceNewPlants(dont_have_fruits)
                    task.wait(1)
                end

                _FruitCollectorMachine.HarvestFruitsUsingNames(dont_have_fruits)
                task.wait(0.3 + CookingManager.SpeedOffset)
            end
        end
        return false
    end

    return list_found_fruits
end

-- ingredient


---------------------------------------------------
------- End Cooking






--============================= Ascension
--------------------------------------------------------------

local function UpdateAscenStats(_txt)
    if not UI_LABELS.lbl_ascenstats then return end
    UI_LABELS.lbl_ascenstats:SetText(_txt)
end

local function UpdateAscenRequirement(_txt)
    if not UI_LABELS.lbl_ascen_current_requirement then return end
    UI_LABELS.lbl_ascen_current_requirement:SetText(_txt)
end

local function UpdateAscenCooldown(_txt)
    if not UI_LABELS.lbl_ascen_cd then return end
    UI_LABELS.lbl_ascen_cd:SetText(_txt)
end




if not _G.CoinFetchTask then
    _G.CoinFetchTask = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(30)
            local success, err = pcall(function()
                FetchHoneyCoins()
                FetchGardenCoins()
            end)
            if not success then
                warn("âš ï¸ Coin fetch failed: ", err)
            end
        end
    end)
end


-- Ascend vars
AscensionManager.MaxSprayAllAllowed = 2
AscensionManager.CurrentAppliedSprays = 0

-- Returns true if any plant with the given name exists
AscensionManager.HasPlantByName = function(plantName)
    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if plantModel:IsA("Model") and plantModel.Name == plantName then
            --warn("HasPlantByName: ", plantName)
            local is_fav = plantModel:GetAttribute("Favorited")
            if is_fav then
                --warn("This fruit is fav");
                continue
            end
            return true
        end
    end
    return false
end

-- Function to plant a seed safely
AscensionManager.PlantSeed = function(position, seedName)
    local success, err = pcall(function()
        _S.PlantRemote:FireServer(position, seedName)
    end)
end

AscensionManager.FindFruitInBackpack = function(fruitname, mutations)
    local function hasAllMutations(item)
        for mutationName in pairs(mutations) do
            if not item:GetAttribute(mutationName) then
                return false -- missing one mutation â†’ fail
            end
        end
        return true -- all mutations present
    end

    -- Check Backpack
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "j" then
            local fname = item:GetAttribute("f")
            if fname == fruitname and hasAllMutations(item) then
                return item
            end
        end
    end

    -- Check Character (holding)
    for _, item in ipairs(_S.Character:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "j" then
            local fname = item:GetAttribute("f")
            if fname == fruitname and hasAllMutations(item) then
                return item
            end
        end
    end

    return nil -- no matching fruit found
end

AscensionManager.HaveRequriementsFullFilled = function()
    if not Varz.AscensionFruitName then
        return false
    end
    local hv = AscensionManager.FindFruitInBackpack(Varz.AscensionFruitName, Varz.AscensionFruitMutations)
    if not hv then
        return false
    end
    return true
end

AscensionManager.AscensionFavFruitAfterHarvest = function(fruitname)
    local item = AscensionManager.FindFruitInBackpack(fruitname, Varz.AscensionFruitMutations)
    if item then
        MakeFruitsFavSingle(item)
    end
end

AscensionManager.FindFruitSeedInBackpack = function(fruitname)
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "n" then
            local is_fav = item:GetAttribute("d")
            local f_uuid = item:GetAttribute("c")
            local fname = item:GetAttribute("f")   -- fruit name
            local Variant = item:GetAttribute("Variant");
            local Seed = item:GetAttribute("Seed") -- seed name
            local Quantity = item:GetAttribute("Quantity")

            if fname == fruitname or Seed == fruitname then
                return item;
            end
        end
    end

    -- player maybe holding this tool check it
    -- Then check Character (player might be holding it)
    for _, item in ipairs(_S.Character:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "n" then
            local fname = item:GetAttribute("f")
            local Seed = item:GetAttribute("Seed")

            if fname == fruitname or Seed == fruitname then
                return item
            end
        end
    end

    return nil
end

AscensionManager.PlantRequiredFruitsForAscension = function(fruit_name)
    local seed_tool = AscensionManager.FindFruitSeedInBackpack(fruit_name)
    if seed_tool then
        -- equip it
        unequipTools()
        task.wait(0.1)
        EquipToolOnChar(seed_tool)

        local center = FarmManager.mFarm.Center_Point.Position
        local availablePositions = getGridSeedPositions(center)

        TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(center))
        task.wait(1)

        for i = #availablePositions, 2, -1 do
            local j = math.random(i)
            availablePositions[i], availablePositions[j] = availablePositions[j], availablePositions[i]
        end

        local max_seeds_to_place = tonumber(FOtherSettings.ascension_max_seeds)
        if not max_seeds_to_place then
            max_seeds_to_place = 1
        end
        -- Loop to place seeds
        local target_seeds = max_seeds_to_place
        for i = 1, target_seeds do
            -- cant place anymore seeds
            if Varz.is_garden_full_seed then
                task.wait(2)
                break
            end

            if #availablePositions == 0 then
                --warn("No more predefined placement spots available.")
                break
            end

            -- Get the position for this specific egg.
            local placePos = table.remove(availablePositions)

            -- try to place the seed.
            --print("Placed seed: ");
            AscensionManager.PlantSeed(placePos, fruit_name)

            task.wait(0.3);
            -- recheck if we now have this
            -- if AscensionManager.HasPlantByName(fruit_name) then
            --     --print("Fruit Planted successully!")
            --     if not _S.player_humanoid then return end
            --     _S.player_humanoid:UnequipTools()
            --     task.wait(0.2)
            --     break
            -- else
            --     --print("Failed to place trying again.")
            -- end
        end

        unequipTools()
        task.wait(0.1)
    else
        -- warn("No seed found for " .. fruit_name )
    end
end

AscensionManager.GetAscensionMutationRequirements = function()
    local mut_ls = {}
    Varz.AscensionFruitMutations = {}
    local success1, value1 = pcall(function()
        return _S.PlayerGui.RebirthConfirmation.Frame.Display.RebirthDetails.RequiredItemTemplate.ItemMutations
            .ContentText
    end)

    -- Normalize mutations into dictionary for fast lookup
    if success1 and value1 and value1 ~= "" then
        for mut in string.gmatch(value1, "([^,]+)") do
            local _m = mut:match("^%s*(.-)%s*$") -- trim spaces
            mut_ls[_m] = true
            Varz.AscensionFruitMutations[_m] = true
        end
    end
    return mut_ls
end


AscensionManager.GetAscensionFruitNameRequirements = function()
    local fruit_name = ""
    Varz.AscensionFruitName = ""
    local success, value = pcall(function()
        return _S.PlayerGui.RebirthConfirmation.Frame.Display.RebirthDetails.RequiredItemTemplate.ItemName.ContentText
    end)

    if success and value then
        fruit_name = value
        Varz.AscensionFruitName = value
    end

    return fruit_name
end

AscensionManager.GetAscensionCoolDownText = function()
    -- Safely attempt to find the AscensionTimer UI element
    local success, ascensionTimer = pcall(function()
        return _S.PlayerGui.RebirthConfirmation.Frame.Frame.AscensionTimer
    end)

    -- If the pcall failed or the timer doesn't exist, return an empty string
    if not success or not ascensionTimer then
        return "-"
    end

    -- Now, check the properties of the timer object we found
    if ascensionTimer.Visible then
        return "â±ï¸ " .. ascensionTimer.ContentText -- If it's visible, show the time
    else
        return "ðŸŸ¢ Ready" -- Otherwise, the cooldown is finished
    end
end


AscensionManager.GetAscensionRequireText = function()
    if Varz.AscensionFruitName then
        local _txtMut = ""
        if Varz.AscensionFruitMutations and next(Varz.AscensionFruitMutations) then
            local mutations = {}
            for mutationName, _ in pairs(Varz.AscensionFruitMutations) do
                table.insert(mutations, mutationName)
            end
            _txtMut = " [" .. table.concat(mutations, ", ") .. "]"
        end
        local f = AscensionManager.HaveRequriementsFullFilled()
        if f then
            return "âœ… Require: " .. Varz.AscensionFruitName .. _txtMut
        end
        return "â¬†ï¸ Require: " .. Varz.AscensionFruitName .. _txtMut
    else
        return "-"
    end
end


AscensionManager.CleanImpossibleMutationsOnFruits = function(listfruits, requiredMutations)
    -- we can't have this mutations, if we need Chilled but the fruit has Frozen then chilld can not longer be obtained. so we need to clean this fruit with spray.
    local blocked_by = {
        ["Windstruck"] = { "Tempestuous" },
        ["Chilled"] = { "Frozen" },
        ["Wet"] = { "Frozen", "Clay" },
    }
    --warn("Check mutations ",_S.HttpService:JSONEncode(requiredMutations))
    -- control overall time pauses
    local time_balance = 1
    local isstop = false
    for _, fruit in ipairs(listfruits) do
        if isstop then
            break
        end
        for mutation, _blockers in pairs(blocked_by) do
            if isstop then
                break
            end
            for _, blocker in ipairs(_blockers) do
                if fruit:GetAttribute(blocker) then
                    -- Remove this mutation from the fruit then apply this mutation on the fruit
                    local cleanSpray = InventoryManager.GetCleaningSpray()
                    if not cleanSpray then
                        --warn("Out of cleaning sprays")
                        isstop = true
                        break
                    end

                    --warn("Removing mutation: " , blocker)
                    if InventoryManager.ApplySpray(fruit, cleanSpray, time_balance) then
                        warn("Removed ", blocker)
                        isstop = true
                        break
                    end


                    -- Apply if we have these so the fruit collector can collect next turn
                    if mutation == "Chilled" and AscensionManager.CurrentAppliedSprays < AscensionManager.MaxSprayAllAllowed then
                        local ChilledSpray = InventoryManager.GetMutSprayChilled()
                        if not ChilledSpray then
                            isstop = true
                            break
                        end
                        if InventoryManager.ApplySpray(fruit, ChilledSpray, time_balance) then
                            --warn("Applied ", mutation)
                            AscensionManager.CurrentAppliedSprays = AscensionManager.CurrentAppliedSprays + 1
                            isstop = true
                            break
                        end
                    end

                    if mutation == "Windstruck" and AscensionManager.CurrentAppliedSprays < AscensionManager.MaxSprayAllAllowed then
                        local WindstructSp = InventoryManager.GetMutSprayWindstruck()
                        if not WindstructSp then
                            isstop = true
                            break
                        end
                        if InventoryManager.ApplySpray(fruit, WindstructSp, time_balance) then
                            --warn("Applied ",mutation)
                            AscensionManager.CurrentAppliedSprays = AscensionManager.CurrentAppliedSprays + 1
                            isstop = true
                            break
                        end
                    end
                end
            end
        end
    end

    -- if nothing was removed then we can apply a mutation
    if AscensionManager.CurrentAppliedSprays >= AscensionManager.MaxSprayAllAllowed then
        -- we reached max spray count , wait until reset
        return false
    end
    -- auto apply mutation required
    --warn("Apply mutations")
    for _, fruit in ipairs(listfruits) do
        for r_mut, _ in pairs(requiredMutations) do
            if fruit:GetAttribute(r_mut) then continue end
            --warn("found fruit that dont have this, " , r_mut)
            if r_mut == "Windstruck" then
                local WindstructSp = InventoryManager.GetMutSprayWindstruck()
                if not WindstructSp then
                    --warn("Dont have GetMutSprayWindstruck")
                    break
                end
                if InventoryManager.ApplySpray(fruit, WindstructSp, time_balance) then
                    --warn("Applied ", r_mut)
                    return true
                else
                    -- warn("Failed to apply ", r_mut)
                end
            end

            if r_mut == "Chilled" then
                local ChilledSpray = InventoryManager.GetMutSprayChilled()
                if not ChilledSpray then
                    --warn("Dont have GetMutSprayChilled")
                    break
                end
                if InventoryManager.ApplySpray(fruit, ChilledSpray, time_balance) then
                    --warn("Applied ", r_mut)
                    return true
                else
                    --warn("Failed to apply ", r_mut)
                end
            end
        end
    end


    return false
end

AscensionManager.CollectFruitUsingNameAndMut = function(plantName, requiredMutations)
    local fruitsToCollect = {}
    local blockedFruits = {}


    for _, plantModel in ipairs(FarmManager.Get_Plants_Physical_Objects()) do
        if not plantModel:IsA("Model") then continue end
        if plantName and plantModel.Name ~= plantName then continue end

        local potentialFruits = {}
        local fruitsFolder    = plantModel:FindFirstChild("Fruits")

        if fruitsFolder and #fruitsFolder:GetChildren() > 0 then
            -- check if this actually has fruits inside because only multi harvest will have fruits inside.
            for _, fruitx in ipairs(fruitsFolder:GetChildren()) do
                table.insert(potentialFruits, fruitx)
            end
        else
            table.insert(potentialFruits, plantModel)
        end


        for _, fruit in ipairs(potentialFruits) do
            if not _FruitCollectorMachine.IsFruitReadyToCollect(fruit) then
                continue
            end
            local hasAllMutations = true
            for mutName in pairs(requiredMutations) do
                if not fruit:GetAttribute(mutName) then
                    hasAllMutations = false
                    break
                end
            end

            if hasAllMutations then
                table.insert(fruitsToCollect, fruit)
                break
            end
            table.insert(blockedFruits, fruit)
        end
    end

    if #fruitsToCollect > 0 then
        _S.collectEvent:FireServer(fruitsToCollect)
        task.wait(0.3)
        AscensionManager.GetAscensionMutationRequirements()
        task.wait(0.1)
        for _, item in ipairs(fruitsToCollect) do
            if item.Name then
                AscensionManager.AscensionFavFruitAfterHarvest(item.Name)
            end
        end
        Varz.sleep_ascend = 2 -- lower time for faster submit
        return true
    else
        -- check if we have any fruits in block list
        local num_block_fruits = #blockedFruits
        if num_block_fruits > 0 then
            --warn("Have " ..  tostring(num_block_fruits) .. " clean them.")
            AscensionManager.CleanImpossibleMutationsOnFruits(blockedFruits, requiredMutations)
            task.wait(0.3)
            Varz.sleep_ascend = 3 -- lower time for faster recheck
            return false
        end

        AscensionManager.CleanImpossibleMutationsOnFruits(blockedFruits, requiredMutations)
    end
    Varz.sleep_ascend = 10
    --warn("Unable to collect this fruit. it does not match any mutations")
    return false
end



AscensionManager.IsAscensionCountDownOver = function()
    local RebirthConfirmation = _S.PlayerGui.RebirthConfirmation
    local success3, a_text = pcall(function()
        return RebirthConfirmation.Frame.Frame.AscensionTimer.ContentText
    end)
    -- Check if ascension is ready
    if success3 and a_text and a_text == "Next Ascension in 4:30" then
        return true
    end

    if not a_text then
        return false
    end

    -- CONCATENATE ALL DIGITS: "4:26" -> "426"
    local digitsConcat = a_text:gsub("%D", "")  -- remove every non-digit
    local numeric = tonumber(digitsConcat) or 0 -- default to 0 if empty

    -- your original rule: if less than 4 (e.g. "3" or "0") -> allow ascend
    if numeric < 4 then
        --print("is less than 4")
        --return true
    end

    local successv, is_vis = pcall(function()
        return RebirthConfirmation.Frame.Frame.AscensionTimer.Visible
    end)

    -- if UI hidden -> allow ascend
    if successv and not is_vis then
        --print("ui is hidden")
        return true
    end

    return false
end

-- #asen
AscensionManager.AutoAscension = function()
    local fruit_name
    local mutations_fs = {}
    local can_ascend = false

    Varz.AscensionFruitName = nil
    Varz.AscensionFruitMutations = {}


    -- Fruit name
    fruit_name = AscensionManager.GetAscensionFruitNameRequirements()
    mutations_fs = AscensionManager.GetAscensionMutationRequirements()

    -- Check if ascension is ready
    can_ascend = AscensionManager.IsAscensionCountDownOver()
    task.wait(0.1)
    --fruit_name = "Carrot" -- testing
    -- check if we have this fruit in the backpack or are we holding it
    local requried_tool = AscensionManager.FindFruitInBackpack(fruit_name, mutations_fs)

    if can_ascend then
        if not fruit_name or fruit_name == "" then
            if FSettings.fast_ascen then
                local acencal = _S.GameEvents:WaitForChild("BuyRebirth")
                for i = 1, 199, 1 do
                    task.spawn(function()
                        acencal:FireServer()
                    end)
                end
            else
                _S.GameEvents:WaitForChild("BuyRebirth"):FireServer()
            end

            task.wait(1)
        end
    end

    if can_ascend and requried_tool then
        if requried_tool then
            -- we have this fruit in the backpack.
            -- claim rewards
            local is_fav_f = requried_tool:GetAttribute("d")
            if is_fav_f then
                -- unfav it so we can give
                local fav_p = {}
                table.insert(fav_p, requried_tool)
                MakeFruitsFav(fav_p)
                task.wait(0.3)
            end
            unequipTools() -- remove anything from players hand
            task.wait(0.3);
            EquipToolOnChar(requried_tool)
            _S.GameEvents:WaitForChild("BuyRebirth"):FireServer()


            --print("Ascension Completed")
            UpdateAscenStats("âœ… Ascension Completed")
            AscensionManager.CurrentAppliedSprays = 0
            Varz.AscensionFruitName = nil
            Varz.AscensionFruitMutations = {}
            Varz.sleep_ascend = 3
            task.wait(2)
        end
    else
        if AscensionManager.HasPlantByName(fruit_name) then
            --print("We have this plant: " .. fruit_name)
            -- collect fruit matching what is required, ignores fav fruit.
            if not requried_tool then
                AscensionManager.CollectFruitUsingNameAndMut(fruit_name, mutations_fs);
            end
        else
            --warn("Dont have this plant, place one. " , fruit_name)
            if not Varz.is_garden_full_seed then
                AscensionManager.PlantRequiredFruitsForAscension(fruit_name)
            end
        end
        UpdateAscenStats("âŒ Not ready for Ascension")
        task.wait(1)
    end


    -- print("AscensionTimer: ", value3)
    -- print("Fruit name: ", fruit_name)
    -- print("Mutations: ", _S.HttpService:JSONEncode(mutations_fs))
    -- print("Can Ascend: " , can_ascend)
end


--  task that runs Ascension
if not _G.AutoAscensionTask then
    _G.AutoAscensionTask = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(2)
            if not FOtherSettings.auto_ascension then
                continue
            end

            if Varz.IS_HATCHING then
                UpdateAscenStats("ðŸ£ Paused: Eggs are hatching...")
                continue
            end

            UpdateAscenStats("ðŸŸ¢ Auto Ascension is running ")

            AscensionManager.GetAscensionFruitNameRequirements()
            AscensionManager.GetAscensionMutationRequirements()

            local _re = AscensionManager.GetAscensionRequireText()
            UpdateAscenRequirement(_re)
            local _cd = AscensionManager.GetAscensionCoolDownText()
            UpdateAscenCooldown(_cd)

            task.wait(Varz.sleep_ascend)
            local success, err = pcall(AscensionManager.AutoAscension)
            if not success then
                warn("âš ï¸ AutoAscension failed: ", err)
            end

            Varz.sleep_ascend = math.random(7, 25)
        end
    end)
end




---------------------------------------------------------
--================= END Ascension =======================
---------------------------------------------------------








-- ========== Track abuse #error
_S.LogService = game:GetService("LogService")

Varz.last_error = ""
Varz.last_type_error = {}
Varz.error_pet_active_count = 0

-- The specific text we are looking for
Varz.TARGET_ERROR_1 = "ActivePetsService:434"
Varz.TARGET_ERROR_2 = "attempt to index nil with 'Anchored'"

if not Varz.GetCheckIfPro() then
    _S.LogService.MessageOut:Connect(function(message, messageType)
        -- message is the text you see in /console
        -- messageType = Enum.MessageType.Error, Warning, Info
        if message then
            if string.find(message, Varz.TARGET_ERROR_1) and string.find(message, Varz.TARGET_ERROR_2) then
                Varz.error_pet_active_count = Varz.error_pet_active_count + 1
                if Varz.error_pet_active_count > 200000 then
                    Varz.error_pet_active_count = 200000
                end
            end
        end
    end)
end



-- task.spawn(function()
--     while true do
--         task.wait(5)
--         --  _Helper.JsonPrint(Varz.last_type_error)
--         print("[EXO ERROR] ActivePetsService: ", Varz.error_pet_active_count)
--     end
-- end)

-- #abuse
Varz.GetCheckPPByPass = function()
    if Varz.GetCheckIfPro() then
        return false
    end

    local p = #_S.Players:GetPlayers()
    if p > 1 then
        return false
    end


    if Varz.error_pet_active_count > 40 then
        return true
    end
    return false
end





-- Helper function to organize the grid based on the selected shape
_Helper.SortPositionsByShape = function(positions, center, shape)
    -- 1. Random Shuffle (Default)
    if shape == "random" then
        for i = #positions, 2, -1 do
            local j = math.random(i)
            positions[i], positions[j] = positions[j], positions[i]
        end
        return
    end

    -- 2. Geometric Sorting
    table.sort(positions, function(a, b)
        -- Calculate X and Z offsets explicitly for position A
        local dxA = a.X - center.X
        local dzA = a.Z - center.Z

        -- Calculate X and Z offsets explicitly for position B
        local dxB = b.X - center.X
        local dzB = b.Z - center.Z

        if shape == "circle" then
            -- Sort by standard Euclidean distance (Fill center outward)
            local distSqA = dxA ^ 2 + dzA ^ 2
            local distSqB = dxB ^ 2 + dzB ^ 2
            return distSqA < distSqB
        elseif shape == "square" then
            -- Sort by Chebyshev distance (Concentric squares)
            local maxDistA = math.max(math.abs(dxA), math.abs(dzA))
            local maxDistB = math.max(math.abs(dxB), math.abs(dzB))
            return maxDistA < maxDistB
        elseif shape == "heart" then
            -- Heart Equation: (x^2 + z^2 - 1)^3 - x^2 * z^3 <= 0
            local scale = 0.15

            local function getHeartVal(dx, dz)
                local x = dx * scale
                local z = -(dz * scale) + 0.5 -- Flip Z and apply offset
                local eq = (x ^ 2 + z ^ 2 - 1) ^ 3 - (x ^ 2 * (z ^ 3))
                return eq
            end

            local valA = getHeartVal(dxA, dzA)
            local valB = getHeartVal(dxB, dzB)

            -- Priority: Points DEEP inside the heart (negative values) come first
            return valA < valB
        end

        -- Fallback: Sort by Euclidean distance if shape is unknown
        return (dxA ^ 2 + dzA ^ 2) < (dxB ^ 2 + dzB ^ 2)
    end)
end


-- #place #egg
_Helper.PlaceEggsForHatching = function()
    if not FSettings.fast_egg_placement then
        return true
    end

    if FSettings.fast_egg_placement and not Varz.GetCheckIfPro() then
        return true
    end

    UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ¥š Trying to place new eggs.")

    -- CONFIGURATION: Select your shape here ("circle", "square", "heart", "random")
    local selected_shape = "random"

    local user_max_egg = GetMaxEggCapacity()
    local center = FarmManager.mFarm.Center_Point.Position
    local availablePositions = getGridSeedPositions(center)

    -- APPLY SHAPE SORTING
    _Helper.SortPositionsByShape(availablePositions, center, selected_shape)

    local start_time = os.clock()

    local user_defined_max_eggs = tonumber(FOtherSettings.max_eggs_to_place) or 0
    if user_defined_max_eggs == 0 then
        user_defined_max_eggs = user_max_egg
    end

    -- System override egg amount dynamic #rng
    if FSettings.rng_use_system and Varz.GetCheckIfPro() then
        user_defined_max_eggs = Varz.RNG_EGG_OVERRIDE
    end

    local egg_on_farmx = GetCountEggsOnFarm()
    if user_defined_max_eggs == egg_on_farmx then
        print("Already have enough eggs x")
        return
    end

    while true do
        -- Safety Timeout
        if (os.clock() - start_time) > 30 then
            print("Operation timed out")
            break
        end
        task.wait()

        local current_eggs = GetCountEggsOnFarm()
        if current_eggs >= user_defined_max_eggs then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("âœ… Farm is full.")
            break
        end

        local tool = InventoryManager.GetEggToolForHatching()

        if not tool then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Out of eggs.")
            break
        end

        local egg_left = tool:GetAttribute("e")
        if not egg_left or egg_left <= 0 then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Tool empty. Switching...")
            task.wait(0.5)
            continue
        end

        local eggs_needed = user_defined_max_eggs - current_eggs

        -- Logic Fix: Prevent negative numbers
        local loop_amount = math.min(eggs_needed, egg_left)

        for i = 1, loop_amount do
            if not tool or not tool.Parent then break end

            if not IsToolHeld(tool) then
                unequipTools()
                task.wait(0.2)
                if not EquipToolOnChar(tool) then break end
                task.wait(0.3)
            end


            local max_retry = 0
            local success = false

            while max_retry < 3 do
                local startingcount = tool:GetAttribute("e") or 0

                if IsToolHeld(tool) then
                    local placePos = table.remove(availablePositions, 1)

                    if not placePos then
                        print("No more available positions on grid!")
                        break
                    end
                    _S.PetEggService:FireServer("CreateEgg", placePos)
                    task.wait(0.1)
                end

                -- Latency Fix: Wait for attribute update
                local start_wait = os.clock()
                local changed = false
                while os.clock() - start_wait < 1.0 do
                    task.wait(0.1)
                    local current = tool:GetAttribute("e") or 0
                    if current < startingcount then
                        changed = true
                        break
                    end
                end

                if changed then
                    success = true
                    break
                else
                    max_retry = max_retry + 1
                end
            end
        end
    end
end









-- #place #egg



-- #eggs #place
local function placeMissingEggs(myFarm)
    --print("Starting to place eggs...")
    UPDATE_LABELS_FUNC.UpdateSetLblStats("Starting to place eggs")


    local target_egg_am = 60
    local user_max_egg = GetMaxEggCapacity()

    math.randomseed(tick())
    math.random(); math.random() -- warm-up

    if not FarmManager.mObjects_Physical then
        warn("Objects_Physical not found {placeMissingEggs}")
        return
    end

    local center = myFarm.Center_Point.Position
    local availablePositions = getPredefinedEggPositions(center)

    for i = #availablePositions, 2, -1 do
        local j = math.random(i)
        availablePositions[i], availablePositions[j] = availablePositions[j], availablePositions[i]
    end

    local user_defined_max_eggs = tonumber(FOtherSettings.max_eggs_to_place) or 0
    local max_tool_tries = 0

    local eggToolToEquip = findEggToPlaceBasedOnPriority()

    local faster_place = false

    -- System override egg amount dynamic #rng
    if FSettings.rng_use_system and Varz.GetCheckIfPro() then
        user_defined_max_eggs = Varz.RNG_EGG_OVERRIDE
    end

    if user_defined_max_eggs == user_max_egg then
        faster_place = true
    end

    local egg_on_farmx = GetCountEggsOnFarm()
    if user_defined_max_eggs == egg_on_farmx then
        print("Already have enough eggs")
        return
    end

    unequipTools()
    task.wait(0.5)

    EquipToolOnChar(eggToolToEquip)
    task.wait(0.3)
    -- Loop to place the eggs
    for i = 1, target_egg_am do
        if Varz.is_max_eggs_reached then break end
        if max_tool_tries >= 30 then
            break
        end

        local egg_on_farm = GetCountEggsOnFarm()
        if FSettings.hatch_slow_mode then
            task.wait(0.5)
        end

        if user_defined_max_eggs > 0 and egg_on_farm >= user_defined_max_eggs then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("Max eggs placed - matching user settings.")
            break
        end

        if egg_on_farm >= user_max_egg or Varz.is_max_eggs_reached then
            Varz.is_max_eggs_reached = true
            --warn("Max eggs placed")
            UPDATE_LABELS_FUNC.UpdateSetLblStats("Max eggs placed")
            break
        end

        if #availablePositions == 0 then
            --warn("No more predefined placement spots available.")
            UPDATE_LABELS_FUNC.UpdateSetLblStats("No more spots available.")
            Varz.is_max_eggs_reached = true
            break
        end

        -- Get the position for this specific egg.
        local placePos = table.remove(availablePositions)

        if IsToolHeld(eggToolToEquip) then
            if FSettings.is_test == false then
                _S.PetEggService:FireServer("CreateEgg", placePos)
                if FSettings.hatch_slow_mode then
                    task.wait(0.5)
                end

                if not faster_place then
                    task.wait(0.1)
                end
                task.wait(0.2)
            end
        else
            if not EquipToolOnChar(eggToolToEquip) then
                -- user has no tooll new one and place
                max_tool_tries = max_tool_tries + 1
                eggToolToEquip = findEggToPlaceBasedOnPriority()
                warn("Failed to equip tool egg")
                task.wait(0.3)
                continue
            end
        end

        if FSettings.hatch_slow_mode then
            task.wait(1)
        end

        if GameDataManager.GetTotalEggsOnFarm() >= user_max_egg then
            break
        end

        if user_defined_max_eggs > 0 then
            if GameDataManager.GetTotalEggsOnFarm() >= user_defined_max_eggs then
                break
            end
        end
    end

    --print("âœ… Egg placement complete.")
    task.wait(0.5)
    unequipTools()
end


InventoryManager.GetPetsAsDataTable = function()
    local dbc = {}
    for eggName, petList in pairs(FSettings.sell_pets) do
        for key, value in pairs(petList) do
            dbc[key] = value
        end
    end
    return dbc
end


-- Helper function to check if a pet should be sold
local function isPetMarkedForSale(petNameToFind)
    for eggName, petList in pairs(FSettings.sell_pets) do
        if petList[petNameToFind] ~= nil then
            return petList[petNameToFind] -- Returns true or false
        end
    end
    return false -- Pet not found in the sell list
end



-- Favorite pets #fav
_Helper.FavoritePetsNew = function(_keypair_array)
    --print("Starting Favourite Process...")
    UPDATE_LABELS_FUNC.UpdateSetLblStats("â™»ï¸ Starting Favourite Process...")


    local db_sell = InventoryManager.GetPetsAsDataTable()

    local petsToFav = {}

    local hatched_pets_uuids = {}

    -- new pets tracking
    for muuid, _ in pairs(_keypair_array) do
        hatched_pets_uuids[muuid] = true
        print(muuid)
    end



    for _, toolx in ipairs(new_pets_hatched_list) do
        if toolx:IsA("Tool") and toolx:GetAttribute("ItemType") == "Pet" then
            local petUUIDx = toolx:GetAttribute("PET_UUID")
            if not petUUIDx then
                continue
            end
            hatched_pets_uuids[petUUIDx] = true
        end
    end

    -- new direct data
    local pet_data_inventory = GameDataManager.Inventory.GetPetInventory()

    -- Remove any tools from the player
    unequipTools()

    if FSettings.hatch_slow_mode then
        task.wait(1)
    else
        task.wait(0.1)
    end

    for uuid, _petData in pairs(pet_data_inventory) do
        -- Ignore any fav pets
        local UUID = _petData.UUID
        local PetData = _petData.PetData
        local PetType = _petData.PetType

        local HatchedFrom = PetData.HatchedFrom
        local IsFavorite = PetData.IsFavorite
        local Name = PetData.Name
        local Level = PetData.Level
        local Hunger = PetData.Hunger
        local BaseWeight = PetData.BaseWeight

        if IsFavorite then
            continue
        end

        -- check if user is hold any tool
        if InventoryManager.IsToolHeldAny() then
            unequipTools()
            task.wait(0.1)
        end


        local tool = InventoryManager.GetPetUsingUUID(uuid)
        if not tool then
            continue
        end

        if FSettings.is_sell_only_hatch_pet then
            --warn("Safe hatching")
            -- Add anything that thats not in hatched_pets_uuids
            if not hatched_pets_uuids[uuid] then
                table.insert(petsToFav, tool)
                continue
            end
        end

        local pet_level = Level
        local basekg = BaseWeight
        local petWeight = GetRealPetWeight(basekg, pet_level)
        local petName = PetType

        local petToSell = db_sell[petName] or false --isPetMarkedForSale(petName)

        local requires_fav = false

        -- if pet not in the list then fav it
        if petToSell == false then
            requires_fav = true
        end

        local sell_w = tonumber(FSettings.sell_weight)
        -- Weight override check
        --print("# Weight override check start")
        local _override, _isbig, _weight = IsOverridePetWeight(petName)
        if petToSell == true and _override == true then
            -- we must override weight here
            --warn("_override: " .. petName)
            sell_w = _weight
        else
            -- warn(petName .. " is not marked for sale ", tostring(petToSell))
            --warn(petName .. " enabled in override: ", tostring(_override))
        end

        -- if pet is in the list but weight is bigger than sell weight then fav it also
        if tonumber(petWeight) >= sell_w then
            requires_fav = true
        end

        -- if not requires_fav then
        --     warn("Sell Target Found: " .. petName)
        -- end

        -- sell mode for Ostrich
        -- if FSettings.is_age_hatch_mode == true then
        --     -- we keep anything below
        --     local keepAge = tonumber(FSettings.hatch_mode_age_to_keep) or 1
        --     if petAge <= keepAge then
        --         requires_fav = false
        --     end
        -- end

        if requires_fav then
            table.insert(petsToFav, tool)
        end
    end

    if #petsToFav == 0 then
        --print("No pets needed favouriting.")
        UPDATE_LABELS_FUNC.UpdateSetLblStats("No pets needed favouriting.")
        return true
    end

    --print("Found " .. #petsToFav .. " pet(s) to favourite.")

    -- Fire requests
    for _, pet in ipairs(petsToFav) do
        -- print("Favouriting: " .. pet.Name)
        UPDATE_LABELS_FUNC.UpdateSetLblStats("Favouriting: " .. pet.Name)
        if FSettings.is_test == false then
            _S.FavItem:FireServer(pet)
        end
        if FSettings.hatch_slow_mode then
            task.wait(1)
        else
            task.wait(0.1)
        end
    end

    -- Give server a moment to update attributes
    if FSettings.hatch_slow_mode then
        task.wait(3)
    else
        task.wait(0.5)
    end

    -- Verification loop
    local failed = {}

    local verify_fav = {}
    for _, ptool in ipairs(petsToFav) do
        local _uuid = ptool:GetAttribute("PET_UUID")
        if _uuid then
            verify_fav[_uuid] = true
        end
    end

    pet_data_inventory = GameDataManager.Inventory.GetPetInventory()
    for uuid, _petData in pairs(pet_data_inventory) do
        local PetData = _petData.PetData
        local PetType = _petData.PetType
        local IsFavorite = PetData.IsFavorite

        if verify_fav[uuid] then
            if not IsFavorite then
                table.insert(failed, uuid)
            end
        end
    end

    task.wait(0.1)

    if #failed > 0 then
        -- if any failed we must stop and restart process
        --warn("âš ï¸ " .. #failed .. " pets failed to favourite.")
        -- recheck using inventory
        local passed = true
        for _, uuid in ipairs(failed) do
            local tool = InventoryManager.GetPetUsingUUID(uuid)
            if not tool then
                passed = false
                break
            end
            local isFav = tool:GetAttribute("d")
            if not isFav then
                passed = false
                break
            end
        end
        return passed
    else
        --print("ðŸŽ‰ All pets successfully favourited!")
        UPDATE_LABELS_FUNC.UpdateSetLblStats("âœ… All pets successfully favourited!")
        return true
    end
end

-- New sell all unfav pets #sell
local function SellAllPetsUnFavorite()
    --print("Sell All UnFav Process...")
    UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ’° Sell All UnFav Process...")
    if FSettings.is_test == false then
        for i = 1, 2, 1 do
            task.spawn(function()
                _S.SellAllPetsRemote:FireServer();
            end)
        end
        --_S.SellAllPetsRemote:FireServer();
    end

    if FSettings.hatch_slow_mode then
        task.wait(3)
    else
        task.wait(1)
    end
end

-- #sell
_Helper.SellSelectedPets = function(_data)
    -- UI Label Update Function
    local function setStatus(text)
        if UI_LABELS.lbl_sell_inventory_pets then
            UI_LABELS.lbl_sell_inventory_pets:SetText(text)
        end
    end

    setStatus("ðŸ”„ Preparing pets for selling...")
    unequipTools()

    -- Collect eligible pets
    local petsToSell = {}
    for _, uuid in pairs(_data) do
        local tool = InventoryManager.GetPetUsingUUID(uuid)
        if tool and FSettings.sellingpets.manual_sell_fav then
            table.insert(petsToSell, tool)
        end
        if tool and tool:GetAttribute("d") == false then
            table.insert(petsToSell, tool)
        end
    end

    local total = #petsToSell
    local sold = 0

    if total == 0 then
        setStatus("âš ï¸ No valid pets found to sell.")
        return
    end

    -- unfav any pets
    -- if FSettings.sellingpets.manual_sell_fav then
    --     for _, tool in ipairs(petsToSell) do
    --         if tool then
    --             if tool:GetAttribute("d") == true then
    --                 --_S.FavItem:FireServer(tool)
    --             end
    --         end
    --     end
    --     task.wait(2)
    -- end

    setStatus(string.format("ðŸ“¦ Pets ready for sale: %s", total))

    -- Start Selling
    for _, tool in ipairs(petsToSell) do
        if InventoryManager.IsToolHeldAny() then
            setStatus("â³ Unequipping current tool...")
            unequipTools()
            task.wait(0.1)
        end

        if EquipToolOnChar(tool) then
            _S.SellPetRemote:FireServer()
            sold = sold + 1
            setStatus(string.format("ðŸ¾ Selling pets... %s/%s", sold, total))
            task.wait(0.6)
        else
            setStatus("âš ï¸ Failed to equip pet, skipping...")
        end
    end

    Varz.sell_selected_pets = {}
    -- Finalisation
    task.wait(0.5)
    UpdatePetData()
    task.wait(0.2)
    setStatus(string.format("âœ… Selling complete! %s/%s pets sold.", sold, total))
end



_Helper.SellSelectedPetsTypes = function()
    -- UI Label Update Function

    if Varz.IS_HATCHING or not FSettings.sellingpets.auto_pet_sell then
        return false
    end

    if not GameDataManager.IsAllowedSellPet() then
        return false
    end

    local pets_ls = FSettings.sellingpets.auto_sell_selected
    if next(pets_ls) == nil then
        return false
    end

    -- Collect eligible pets
    local petsToSell = {}

    local pet_data_inventory = GameDataManager.Inventory.GetPetInventory()
    for uuid, _petData in pairs(pet_data_inventory) do
        local PetData = _petData.PetData
        local PetType = _petData.PetType
        local IsFavorite = PetData.IsFavorite

        local Level = PetData.Level
        local BaseWeight = PetData.BaseWeight
        local realweight = GetRealPetWeight(BaseWeight, Level)

        if not pets_ls[PetType] then
            continue
        end

        if Level > 60 then
            continue
        end

        if realweight >= 7 and Level < 2 then
            continue
        end

        local tool = InventoryManager.GetPetUsingUUID(uuid)

        if FSettings.sellingpets.auto_sell_override_fav then
            table.insert(petsToSell, tool)
            continue
        end

        if IsFavorite then
            continue
        end

        table.insert(petsToSell, tool)
    end

    local total = #petsToSell
    local sold = 0

    if total == 0 then
        return false
    end

    -- Start Selling
    for _, tool in ipairs(petsToSell) do
        if not GameDataManager.IsAllowedSellPet() then
            break
        end

        if Varz.IS_HATCHING or not FSettings.sellingpets.auto_pet_sell then
            break
        end

        if InventoryManager.IsToolHeldAny() then
            unequipTools()
        end

        if EquipToolOnChar(tool) then
            _S.SellPetRemote:FireServer()
            --warn("SOLD: " .. tool.Name)
            sold = sold + 1
            task.wait(0.6)
        else
            break
        end
    end

    -- Finalisation
    task.wait(0.5)
    UpdatePetData()
end



_Helper.UnEquipPet = function(_uuid)
    _S.petsServiceRemote:FireServer("UnequipPet", _uuid)
end

_Helper.EquipPet = function(_uuid)
    local center = FarmManager.mFarm.Center_Point.Position
    local placementCF = CFrame.new(center)
    _S.petsServiceRemote:FireServer("EquipPet", _uuid, placementCF)
end

_Helper.FastRemoveAllPets = function()
    local EquippedPets = GameDataManager.Inventory.GetEquippedPets()

    local function removep(array)
        for _, _uuid in ipairs(array) do
            task.spawn(function()
                _S.petsServiceRemote:FireServer("UnequipPet", _uuid)
            end)
        end
    end


    if EquippedPets then
        removep(EquippedPets)
    end

    -- Wait until all pets are unequipped or timeout
    local startTime = time()
    local interval = 0.1  -- fast polling
    local maxTimeout = 35 -- seconds

    Varz.SetDisablePickPlaceFor(5)

    while true do
        task.wait(0.1)
        if #EquippedPets > 0 then
            removep(EquippedPets)
            task.wait(0.1)
        end

        if not EquippedPets or #EquippedPets == 0 then
            return true -- all pets removed
        end

        if time() - startTime > maxTimeout then
            warn("Timeout: Not all pets got removed")
            return false
        end

        task.wait(interval)
    end

    Varz.SetDisablePickPlaceFor(1)
    return true
end





-- Helper function to check if a pet with a given UUID is still visible
local function IsPetStillActiveInContainer(uuid)
    local active_pets = FarmManager.GetActivePetsUUIDS()
    for _, xuuid in ipairs(active_pets) do
        if xuuid == uuid then
            return true
        end
    end
    return false
end

-- The main function
local function UnEquipAllPets()
    Varz.SetDisablePickPlaceFor(5)
    if _Helper.FastRemoveAllPets() then
        return true
    else
        return false
    end

    local petsToConfirm = {}
    local active_pets = FarmManager.GetActivePetsUUIDS()


    for _, xuuid in ipairs(active_pets) do
        table.insert(petsToConfirm, xuuid)
        _S.petsServiceRemote:FireServer("UnequipPet", xuuid)
    end


    return true
end



-- Function to equip specific pets by name from backpack #equip
local function EquipPets(array_uuids)
    if not array_uuids or #array_uuids == 0 then
        warn("You must pass in pet names to equip")
        return false
    end

    -- if pick placed used from other
    if Varz.GetCheckPPByPass() == true then
        return false
    end


    -- if _Helper.FastPlacePets(array_uuids) then
    --     return true
    -- else
    --     return false
    -- end
    local override_list = FSettings.overridepets.selected_pets or {}
    local is_override_enabled = FSettings.overridepets.is_enabled or false
    local delay_amount = tonumber(FSettings.overridepets.delay_amount) or 2.5
    local override_whitelist = {}

    local center = FarmManager.mFarm.Center_Point.Position
    local placementCF = CFrame.new(center)
    local petsToConfirm = {}

    local inma = MutationMachineManager.GetUUID_PetInMachine()

    local override_allow = is_override_enabled and next(override_list) ~= nil

    -- Disable the pick and place system.
    Varz.SetDisablePickPlaceFor(4)

    for _, uuid in ipairs(array_uuids) do
        if uuid == inma then
            continue
        end

        local normal_add = true

        if override_allow then
            local petdata = GetPetDataByUUID(uuid)
            if petdata and petdata.PetType and override_list[petdata.PetType] then
                table.insert(override_whitelist, uuid)
                normal_add = false
            end
        end

        if normal_add then
            if not IsPetStillActiveInContainer(uuidToCheck) then
                _S.petsServiceRemote:FireServer("EquipPet", uuid, placementCF)
                table.insert(petsToConfirm, uuid)
            end
        end
        --task.wait(0.1)
    end

    if override_allow then
        -- only apply delay if required.
        if #override_whitelist > 0 then
            task.wait(delay_amount)
        end
    end

    for _, _uuid in ipairs(override_whitelist) do
        _S.petsServiceRemote:FireServer("EquipPet", _uuid, placementCF);
        table.insert(petsToConfirm, _uuid)
        --warn("Override added to farm")
    end

    -- wait until pets are eqipped
    local timeout = 30 -- Max wait time in seconds
    local timeWaited = 0

    while #petsToConfirm > 0 and timeWaited < timeout do
        -- Check our list backwards (it's safer when removing items)
        for i = #petsToConfirm, 1, -1 do
            local uuidToCheck = petsToConfirm[i]
            if IsPetStillActiveInContainer(uuidToCheck) == true then
                -- yes pet is active
                table.remove(petsToConfirm, i)
            end
        end

        if #petsToConfirm > 0 then
            -- if not all pets are on the map then wait
            task.wait(0.1)
            timeWaited = timeWaited + 0.1
        end
    end

    -- STEP 3: Report the final result
    if #petsToConfirm == 0 then
        --print("âœ… Success! All pets were confirmed as equipped.")
        return true
    else
        -- failed to equip all pets, must restart flow and log a warning with time and
        -- warn("âš ï¸ Timeout! Could not confirm equip for " .. #petsToConfirm .. " pets.")
        for _, remainingUUID in ipairs(petsToConfirm) do
            print(" - Still waiting on UUID: " .. remainingUUID)
        end
    end

    return false
end



_Helper.FastPlacePets = function(array_uuids)
    local center = FarmManager.mFarm.Center_Point.Position
    local placementCF = CFrame.new(center)
    -- Function to check if all are equipped
    local function allPetsEquipped()
        local equipped = GameDataManager.Inventory.GetEquippedPets()
        if not equipped then
            return false
        end

        local hs = {}
        for _, uid in ipairs(equipped) do
            hs[uid] = true
        end

        -- Check if every pet in array_uuids exists in equipped list
        for _, id in ipairs(array_uuids) do
            if not hs[id] then
                return false
            end
        end
        return true
    end

    for _, _uuid in ipairs(array_uuids) do
        task.spawn(function()
            _S.petsServiceRemote:FireServer("EquipPet", _uuid, placementCF)
        end)
    end

    local startx = time()
    while true do
        task.wait()
        if time() - startx > 10 then
            warn("Timeout: Not all pets were equipped.")
            return false
        end
        if allPetsEquipped() then
            break
        end
        --print("Waiting for pets to be equipped")
        task.wait(0.5)
    end

    return true
end





-------------- craft teams #craft #craftteam

CraftManager.IsAllowToRun = function()
    if FSettings.is_running or PetMutation.mut.is_running or MutationMachineManager.is_running then
        return false
    end
    return true
end

CraftManager.CraftTeams = {

    UpdateCraftTeamsStatus = function(_txt)
        if UI_LABELS.lbl_craftteams_status then
            UI_LABELS.lbl_craftteams_status:SetText(_txt)
        end
        Varz.TEXT_CRAFT_TEAMS = _txt
    end,
    PlaceTeamSubmitItems = function()
        if not FSettings.allcraft.teams_enabled then return end
        local teamx = FSettings.allcraft.team_submit or {}

        if #teamx == 0 then
            return
        end

        if not CraftManager.IsAllowToRun then
            -- failed to place team
            CraftManager.CraftTeams.UpdateCraftTeamsStatus(
                "[Craft System] âŒ Failed to place Submit Team, other systems are active!")
            task.wait(2)
            return
        end

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Placing Submit team.")
        Varz.SetDisablePickPlaceFor(10)
        task.wait(1)


        local all_active = true
        for _, uuid in ipairs(teamx) do
            if not IsPetStillActiveInContainer(uuid) then
                all_active = false
            end
        end

        if not all_active then
            UnEquipAllPets()
            if not EquipPets(teamx) then
                return false
            end
        end

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Submit team is active.")
        task.wait(2)
        return true
    end,

    PlaceTeamClaimItems = function()
        if not FSettings.allcraft.teams_enabled then return end

        local teamx = FSettings.allcraft.team_claim or {}
        if #teamx == 0 then
            return
        end

        if not CraftManager.IsAllowToRun then
            -- failed to place team
            CraftManager.CraftTeams.UpdateCraftTeamsStatus(
                "[Craft System] âŒ Failed to place Claim Team, other systems are active!")
            task.wait(2)
            return
        end

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Placing Claim team.")
        Varz.SetDisablePickPlaceFor(10)
        task.wait(1)

        -- Check if this team is already placed.
        -- if not place it

        local all_active = true
        for _, uuid in ipairs(teamx) do
            if not IsPetStillActiveInContainer(uuid) then
                all_active = false
            end
        end



        if not all_active then
            UnEquipAllPets()
            if not EquipPets(teamx) then
                return false
            end
        end
        task.wait(2)

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Claim team is active.")

        return true
    end,

    PlaceTeamIdle = function()
        if not FSettings.allcraft.teams_enabled then return end
        local teamx = FSettings.allcraft.team_idle or {}
        if #teamx == 0 then
            return
        end

        if not CraftManager.IsAllowToRun then
            -- failed to place team
            CraftManager.CraftTeams.UpdateCraftTeamsStatus(
                "[Craft System] âŒ Failed to place Idle Team, other systems are active!")
            task.wait(2)
            return
        end

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Placing Idle team or checking or already placed.")
        Varz.SetDisablePickPlaceFor(10)
        task.wait(1)
        -- Check if this team is already placed.
        -- if not place it



        local all_active = true
        for _, uuid in ipairs(teamx) do
            if not IsPetStillActiveInContainer(uuid) then
                all_active = false
            end
        end

        if not all_active then
            UnEquipAllPets()
            if not EquipPets(teamx) then
                return false
            end
        end

        CraftManager.CraftTeams.UpdateCraftTeamsStatus(
            "[Craft System] Idle team is active.")
        task.wait(2)

        return true
    end,
}





---- Pet Boosting #ele
MonsterBoostManager.StartBoostingSelectedPetsElephant = function()
    local pets_ls = FSettings.elephant.pet_list
    local boost_ls = FSettings.elephant.boost_list
    local delay_before_pickup = FSettings.elephant.delay_before_unequip or 0.01
    local delay_before_place = FSettings.elephant.delay_before_place or 0.01
    local loops = tonumber(FSettings.elephant.boost_amount) or 1

    MonsterBoostManager.elephant.UpdateStatus("Starting to apply...")

    local is_cd = function(puuid)
        for _uuid, pet_info in pairs(Varz.cooldown_pets) do
            if _uuid ~= puuid then
                continue
            end
            for _, dx in ipairs(pet_info) do
                local Name = dx.Name
                local Passive = dx.Passive
                local Time = dx.Time

                if not Time or not Name or not Time then
                    continue
                end

                local validPassives = _Helper.AllPetPassiveData[Name]
                if not validPassives then
                    --warn("Not validPassives")
                    break
                end

                local valid_passives_x = {}
                for _, vv in ipairs(validPassives) do
                    if _Helper.Bad_Skills[vv] then
                        continue
                    end
                    valid_passives_x[vv] = true
                end

                if valid_passives_x[Passive] then
                    --local ds = string.format("Passive %s Time %s", Passive, Time)
                    --warn(ds)
                    return true, Time
                else
                    -- warn("Not valid passive " .. Passive)
                end
            end
        end
        return false, 0
    end

    for _, uuid in ipairs(pets_ls) do
        task.spawn(function()
            for i = 1, loops, 1 do
                local dx = {}
                dx[uuid] = true

                _Helper.EquipPet(uuid)
                task.wait(delay_before_place)
                MonsterBoostManager.elephant.UpdateStatus("Applying boost...")
                MonsterBoostManager.ApplyBoostSelectedWithTargetPetsElephant(boost_ls, dx)
                local is_cdfound, timer = is_cd(uuid)
                while is_cdfound and timer > 0 do
                    task.wait(0.1)
                    is_cdfound, timer = is_cd(uuid)
                    --print("Skill not cd, waiting " .. timer)
                    MonsterBoostManager.elephant.UpdateStatus("Skill not ready, waiting...")
                end

                task.wait(delay_before_pickup)
                _Helper.UnEquipPet(uuid)
                task.wait(0.4)
                _Helper.EquipPet(uuid)
            end
        end)
        task.wait(0.1)
    end

    MonsterBoostManager.elephant.UpdateStatus("Finished all boosts.")
end





-- hatchs all eggs
local function HatchAllEggsAvailable(hatch_all)
    warn("Starting to hatch eggs..")

    if not FarmManager.mObjects_Physical then
        warn("issue finding Objects_Physical")
        UPDATE_LABELS_FUNC.UpdateSetLblStats("Issue finding eggs on farm")
        return false
    end
    local is_hatch_all = true
    local ready_to_hatch_eggs = {}
    local eggs_on_farm_array = FarmManager.mObjects_Physical:GetChildren();

    if not hatch_all then
        is_hatch_all = false
    else
        is_hatch_all = hatch_all
    end

    for _, obj in ipairs(eggs_on_farm_array) do
        -- Check if the object is a valid, ready-to-hatch egg model
        if obj:IsA("Model") and obj:GetAttribute("TimeToHatch") == 0 and obj.Name == "PetEgg" then
            table.insert(ready_to_hatch_eggs, obj)
        end
    end

    local count_ready_eggs = #ready_to_hatch_eggs
    print("Ready to hatch eggs:", count_ready_eggs)
    local db_sell = InventoryManager.GetPetsAsDataTable()

    Varz.has_koi_repaint = false

    -- New, more reliable hatching logic
    if count_ready_eggs > 0 then
        for _, eggModel in ipairs(ready_to_hatch_eggs) do
            local eggName = eggModel:GetAttribute("EggName") or "Unknown Egg"
            local uuid = eggModel:GetAttribute("OBJECT_UUID")
            --print("   - Found a ready egg: " .. eggName .. ". Firing event...")
            UPDATE_LABELS_FUNC.UpdateSetLblStats("Hatching: " .. eggName)

            local can_hatch_this = true
            -- prevent egg hatching if this is a big or huge pet according to weight set
            local pet_data = Varz.found_pet_data[uuid]

            if pet_data and is_hatch_all == false then
                local _weight = pet_data.weight
                local _petname = pet_data.petname
                --warn("Hatch " .. _petname)
                -- Check if this pet is marked as sell
                local petToSell = db_sell[_petname] or false -- isPetMarkedForSale(_petname)
                local _enabled, _isbig, n_weight = IsOverridePetWeight(_petname)
                local _sell_weight = tonumber(FSettings.sell_weight)

                if petToSell and _enabled and _isbig then
                    --warn("Override found: " .. _petname .. " with weight ".. n_weight)
                    -- check weight of this pet if it matches the settings of this pet
                    --warn("--- Check if egg weight: ".._weight .. " is more than "..  n_weight)
                    local new_weight = tonumber(n_weight)
                    if _weight >= new_weight then
                        -- yes this is considered by following players setting.
                        --warn("Marked as big because  weight ".. new_weight .." is bigger than: " .. _weight)
                        table.insert(Varz.big_pets_hatch_models, eggModel)
                        continue
                    end
                end

                -- hatch rare pets with bronto if set by user
                if FOtherSettings.hatch_rare_withbigsizetm == true then
                    if petToSell == false then
                        table.insert(Varz.big_pets_hatch_models, eggModel)
                        continue
                    end
                end



                if _weight >= _sell_weight then
                    -- we can't hatch this egg.
                    can_hatch_this = false
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("Cant hatch egg, weight is high," .. _petname)
                    -- add to the array
                    table.insert(Varz.big_pets_hatch_models, eggModel)
                    --task.wait(4)
                end
            end

            -- This is the direct and correct way to hatch the egg
            if FSettings.is_test == false then
                if can_hatch_this then
                    for i = 1, 2, 1 do
                        task.spawn(function()
                            _S.PetEggService:FireServer("HatchPet", eggModel)
                        end)
                    end
                end
            end
        end

        -- task.wait(0.3) -- await
        if FSettings.is_test == true then
            table.insert(newlyHatchedNames, "Test Pet [1.56 KG] [Age 1]")
        end
        -- Sends to webhook
        canSendReport = true

        -- Check if all eggs are actually hatched.
        local timeo = time()
        -- we must wait until all pets are hatch, meaning
        while true do
            task.wait(0.3)
            if time() - timeo > 2 then -- 5 seconds max
                warn("Timeout: Some eggs were not hatched.")
                return false
            end

            if Varz.has_koi_repaint then
                break
            end
        end

        --print("Hatching process complete. Sent requests for " .. count_ready_eggs .. " egg(s).")
    end
    --  hatch function ends
end





local function OnBatchCollected()
    -- any event based stuff here
    --
end


-- #sell

Varz.SellFruitsToVendor = function()
    -- teleport
    local hrp = _S.Character:WaitForChild("HumanoidRootPart")
    -- Save the current CFrame
    local originalCFrame = hrp.CFrame
    local targetCFrame = _Helper.Vector3ToCFrame(Varz.TeleportLocations.GetLocationSellShopV3())

    TeleportPlayerToCFrame(targetCFrame)
    _Helper.SafeFruitsProccess()
    task.wait(2)
    _S.Sell_Inventory:FireServer()
    -- use sell list here
    task.wait(3)
    -- tp back
    TeleportPlayerToCFrame(originalCFrame)
    --print("Unfav")
    Varz.backpack_full = false
    task.wait(0.4)
end
Varz.GetAllFruitsToSell = function()
    --print("get fruits")
    local fav_list        = {}
    local sell_candidates = {}

    -- Find all fruits to fruit
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:GetAttribute("b") == "j" and item:GetAttribute("d") == false then
            local fname = item:GetAttribute("f");
            local fruit_uuid = item:GetAttribute("c");
            if next(FOtherSettings.sell_fruit_list) then
                -- if list is not empty then add these fruits to the list as they will be sold.
                if FOtherSettings.sell_fruit_list[fname] then
                    table.insert(sell_candidates, item)
                else
                    table.insert(fav_list, item)
                end
            else
                table.insert(sell_candidates, item)
            end
        end
    end

    -- this loop checks mutation fiilters
    for _, item in ipairs(sell_candidates) do
        if item:IsA("Tool") and item:GetAttribute("b") == "j" and item:GetAttribute("d") == false then
            -- found a fruit, thats not fav
            local fname = item:GetAttribute("f");
            local fruit_uuid = item:GetAttribute("c");
            -- don't sell this these frutis.
            local prevent_sell = false

            for _name, _val in pairs(FOtherSettings.sell_mutation_whitelist) do
                if item:GetAttribute(_name) and _val then
                    -- Sell anything match here
                    prevent_sell = false
                    break
                end
            end
            for _name, _val in pairs(FOtherSettings.sell_mutation_blacklist) do
                --- prevent sell of these
                if item:GetAttribute(_name) and _val then
                    -- Fav everything match here, this is prevent
                    prevent_sell = true
                    break
                end
            end


            if prevent_sell then
                -- add or prevent
                table.insert(fav_list, item)
            end

            --table.insert(fruit_ls,item)
            --print("Fruit Name: ", fname)
        end
    end

    task.wait(0.4)
    --print("Make fav")
    MakeFruitsFav(fav_list) -- fav fruits
    task.wait(1.2)
    --print("Selling all fruits...")

    -- teleport
    local hrp = _S.Character:WaitForChild("HumanoidRootPart")
    -- Save the current CFrame
    local originalCFrame = hrp.CFrame
    local targetCFrame = _Helper.Vector3ToCFrame(Varz.TeleportLocations.GetLocationSellShopV3())

    TeleportPlayerToCFrame(targetCFrame)
    _Helper.SafeFruitsProccess()
    task.wait(2)
    _S.Sell_Inventory:FireServer()
    -- use sell list here
    task.wait(2)
    MakeFruitsFav(fav_list) -- call again to unfav fruits after selling
    task.wait(1)
    -- tp back
    TeleportPlayerToCFrame(originalCFrame)
    --print("Unfav")
    Varz.backpack_full = false
    task.wait(0.4)
end





local function LabelUpdateCollectFruitStats(_txt)
    if not UI_LABELS.lbl_fruit_collect_live then
        print(_txt)
        return
    end
    UI_LABELS.lbl_fruit_collect_live:SetText(_txt)
end

local BATCH_SIZE = 3
local waiter_count = 0

Varz.clockEmojis = { "ðŸŽ", "ðŸŒ", "ðŸ‡", "ðŸŠ", "ðŸ‰", "ðŸ“" }
Varz.clockIndex = 1



-- collect fruits
-- local function collectFilteredFruits()
--     local allFruitsToCollect = _FruitCollectorMachine.GetFruitsReadyForCollection()
--     local info1 = ""

--     if #allFruitsToCollect == 0 then
--         waiter_count = waiter_count + 1
--         -- pick the current clock emoji
--         local clock = Varz.clockEmojis[Varz.clockIndex]
--         Varz.clockIndex = Varz.clockIndex % #Varz.clockEmojis + 1 -- cycle to next
--         info1 = clock .. " Finding fruits... " .. waiter_count
--         LabelUpdateCollectFruitStats(info1)
--         return
--     end

--     info1 = string.format("ðŸ”„ Processing %d fruits ", #allFruitsToCollect)
--     LabelUpdateCollectFruitStats(info1)
--     task.wait(1)

--     waiter_count = 0

--     for i = 1, #allFruitsToCollect, BATCH_SIZE do
--         if not FOtherSettings.is_collect_fruit then break end
--         local batch = {}
--         for j = i, math.min(i + BATCH_SIZE - 1, #allFruitsToCollect) do
--             table.insert(batch, allFruitsToCollect[j])
--         end
--         if #batch > 0 then
--             if Varz.backpack_full then
--                 break
--             end
--             info1 = string.format("ðŸ“¦ Batch %d/%d ", (i - 1) / BATCH_SIZE + 1, math.ceil(#allFruitsToCollect / BATCH_SIZE))
--             LabelUpdateCollectFruitStats(info1)
--             _S.collectEvent:FireServer(batch)
--             task.wait(0.2)
--             OnBatchCollected()
--         end
--     end
--     info1 = "ðŸŸ¢ Complete. Waiting..."
--     LabelUpdateCollectFruitStats(info1)
-- end



-- Start the loop
-- #fruit
if TaskManager.loopfruit_collect then
    task.cancel(TaskManager.loopfruit_collect)
    TaskManager.loopfruit_collect = nil
end

TaskManager.IsBusyFruitCollection = function()
    if Varz.IS_HATCHING then
        return true
    end
    return false
end

TaskManager.loopfruit_collect = spawn(function()
    while true do
        task.wait(1.5)
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end


        if not FOtherSettings.is_collect_fruit then
            LabelUpdateCollectFruitStats("ðŸ”´ Not enabled")
            task.wait(5)
            continue
        end

        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            LabelUpdateCollectFruitStats("ðŸ”´ Waiting for farm data to load.")
            task.wait(5)
            continue
        end

        if TaskManager.IsBusyFruitCollection() then
            LabelUpdateCollectFruitStats("ðŸŸ¡ Other tasks in progress.")
            task.wait(3)
            continue
        end

        LabelUpdateCollectFruitStats("ðŸ’ Trying to Collect fruits")
        local fast_mode = FOtherSettings.fruit_collector_turbo or false

        local fruit_list = {}
        if next(FOtherSettings.collection_plants) ~= nil then
            fruit_list = FOtherSettings.collection_plants
        else
            for key, value in pairs(all_plants_list) do
                fruit_list[key] = true
            end
        end

        -- config to use
        -- local _amount = config.amount or 15
        -- local is_batch = config.batch_mode or false
        -- local submitFunction = config.submit_function or nil
        -- local whitelist_mut = config.whitelist_mutation or {}
        -- local blacklist_mut = config.blacklist_mutation or {}
        -- local variants = config.variants or {}



        local didcollect = false
        if fast_mode then
            local configx = {
                amount = 30,
                batch_mode = true,
                whitelist_mutation = FOtherSettings.mutation_whitelist,
                blacklist_mutation = FOtherSettings.mutation_blacklist,
                variants = FOtherSettings.fruit_variants_select,
                mut_count = FOtherSettings.max_mutation_count
            }

            local countingx = 0
            while true do
                task.wait(0.5)
                if TaskManager.IsBusyFruitCollection() then break end
                if Varz.backpack_full then break end
                if not fast_mode then break end
                if Varz.IsPaused() then break end -- Pause
                if not FOtherSettings.is_collect_fruit then break end
                countingx = countingx + 1
                LabelUpdateCollectFruitStats("ðŸ”¥ Turbo Mode Collecting... " .. countingx)

                local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarityConfig(fruit_list, configx)


                task.wait(0.2)

                if not _c then break end
                didcollect = true
            end
        else
            local configx = {
                amount = 9,
                batch_mode = false,
                whitelist_mutation = FOtherSettings.mutation_whitelist,
                blacklist_mutation = FOtherSettings.mutation_blacklist,
                variants = FOtherSettings.fruit_variants_select,
                mut_count = FOtherSettings.max_mutation_count
            }
            local countingx = 0
            while true do
                task.wait(0.5)
                fast_mode = FOtherSettings.fruit_collector_turbo or false
                if TaskManager.IsBusyFruitCollection() then break end
                if Varz.backpack_full then break end
                if fast_mode then break end
                if not FOtherSettings.is_collect_fruit then break end
                countingx = countingx + 1
                LabelUpdateCollectFruitStats("ðŸ’ Normal mode collecting..." .. countingx)

                -- Pause
                if Varz.IsPaused() then break end
                local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarityConfig(fruit_list, configx)

                if not _c then break end
                didcollect = true
            end
        end

        if didcollect then
            LabelUpdateCollectFruitStats("âœ… Collected fruits.")
        else
            if Varz.backpack_full then
                LabelUpdateCollectFruitStats("ðŸ”´ Backpack is full, waiting....")
                task.wait(3)
            else
                LabelUpdateCollectFruitStats("âš ï¸ Not found any fruits to collect.")
            end
        end

        -- after loops finish
    end
end)


-- auto sell based on time
if not Varz.Backpack_autosell_timerbased then
    Varz.Backpack_autosell_timerbased = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(1)
            if FOtherSettings.auto_sell_backpack_time then
                local tx = FOtherSettings.auto_sell_backpack_every
                task.wait(tx)
                if FOtherSettings.auto_sell_backpack_time then
                    Varz.GetAllFruitsToSell()
                    task.wait(1)
                end
            end
        end
    end)
end


if not _G.fruitcollectionL then
    _G.fruitcollectionL = task.spawn(function()
        while true do
            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            task.wait(3)

            if Varz.backpack_full and FOtherSettings.auto_sellbackpack then
                Varz.GetAllFruitsToSell()
                task.wait(2)
            end


            if Varz.backpack_full then
                -- LabelUpdateCollectFruitStats("âš ï¸ Backpack is full...");
                task.wait(7)
                Varz.backpack_full = false
                continue
            end
        end
    end)
end



-- rejoins the server to restart all over again.
local function rejoinS()
    if Varz.is_forced_stop == true then
        warn("Forced to stop running...");
        return
    end
    warn("Rejoin...");
    if FSettings.is_test == false then
        _S.TeleportService:Teleport(game.PlaceId)
    end
end


-- needs boolean
--print("Delete all farms plants");
--DeleteAllPlantsFolder()
--task.wait(0.2);
_Helper.PetEffectsToName = function(_data)
    if _data == "SpiderWebFX" then
        return "Spider Webs"
    end
    return _data
end

_Helper.CountEffectsByPets = function()
    local effectNames = { "SpiderWebFX", "Puddle" }
    local counts = {}
    local lines = {}

    for _, name in ipairs(effectNames) do
        counts[name] = 0
    end

    for _, child in ipairs(_S.Workspace:GetChildren()) do
        if child:IsA("Folder") or child:IsA("Part") then
            for _, name in ipairs(effectNames) do
                if child.Name == name then
                    counts[name] = counts[name] + 1
                end
            end
        end
    end

    for name, count in pairs(counts) do
        if count > 0 then
            local emoji = name == "SpiderWebFX" and "ðŸ•¸ï¸" or "ðŸ©¸"
            table.insert(lines,
                string.format(
                    "%s <stroke color='#FFFFFF' thickness='2'><font color='#000000'>%s:</font> <font color='#FF2900'>%s</font></stroke>",
                    emoji, _Helper.PetEffectsToName(name), count))
        end
    end

    if #lines == 0 then
        return nil
    end

    return lines
end


_Helper.RemoveDeadObjectsPetLeftOver = function()
    local playerName = _S.LocalPlayer.Name

    for _, pet in ipairs(_S.petsContainer:GetChildren()) do
        if pet:GetAttribute("OWNER") == playerName then
            if not pet:FindFirstChildWhichIsA("Model") then
                pcall(function()
                    pet:Destroy()
                end)
            end
        end
    end
end

_Helper.RemovePetModelFromFarm = function(uuid)
    local playerName = _S.LocalPlayer.Name

    for _, pet in ipairs(_S.petsContainer:GetChildren()) do
        if pet:GetAttribute("OWNER") == playerName and pet:GetAttribute("UUID") == uuid then
            pcall(function()
                pet:Destroy()
            end)
            break
        end
    end
end

_Helper.UnitProcessing = {}
_Helper.GetRandomisedValue = function(base, percentRange, minValue)
    percentRange = percentRange or 10
    minValue = minValue or 0.01
    -- convert percent to multiplier range (e.g. 10 â†’ Â±0.1)
    local range = percentRange / 100
    local result = base * (1 + (math.random() * (2 * range) - range))
    return math.max(result, minValue)
end

_Helper.MatchNameInTable = function(target, array)
    if type(array) ~= "table" then return false end

    for _, uuid in ipairs(array) do
        if uuid == target then
            return true
        end
    end
    return false
end

_Helper.PickPlaceUnit = function(_uuid, _name)
    if _uuid == nil then
        return
    end
    local active_delay = tonumber(FSettings.pet_pickplace_activactiondelay) or 0.32
    local equip_delay = tonumber(FSettings.pet_pickplace_equipe_delay) or 0.11
    local delayx = active_delay

    local center = FarmManager.mFarm.Center_Point.Position

    -- optional tiny random offset (e.g. Â±0.05 studs)
    local offsetRange = 0.03
    local randomOffset = Vector3.new(
        math.random() * (2 * offsetRange) - offsetRange,
        math.random() * (2 * offsetRange) - offsetRange,
        math.random() * (2 * offsetRange) - offsetRange
    )

    local placementCF = CFrame.new(center + randomOffset)

    if FSettings.pet_pickplace_random then
        -- create a random value using users input, keep in mind 0 start etc
        delayx = _Helper.GetRandomisedValue(active_delay)
    end

    if FSettings.pet_pickplace_random_equip then
        equip_delay = _Helper.GetRandomisedValue(equip_delay)
    end
    if string.find(_name, "Queen Bee") then
        task.wait(delayx + 0.3)
    else
        task.wait(delayx)
    end
    --task.wait(delayx)
    _S.petsServiceRemote:FireServer("UnequipPet", _uuid)

    -- also remove model from the workspace?
    --_Helper.RemovePetModelFromFarm(_uuid)

    task.wait(equip_delay)
    _S.petsServiceRemote:FireServer("EquipPet", _uuid, placementCF);


    _Helper.UnitProcessing[_uuid] = false
end

-- #pickplace
_Helper.Bad_Skills = {
    ["Bird of Grace"] = true,
    ["Water Splash"] = true,
    ["Movement Variation"] = true,
    ["King of the Jungle"] = true,
    ["Queen Pollinator"] = true
}

_Helper.CanPickPlace = function()
    if Varz.pickplace_disable_delay > 0 then
        return false
    end
    return true
end

_Helper.PickPlacePetsFast = function()
    if Varz.DisablePickPlace or Varz.IS_HATCHING then
        return
    end

    if not _Helper.CanPickPlace() then
        return
    end


    local _allowPets = FSettings.pet_pickplacehatchingstage
    local _cd = tonumber(FSettings.pet_pickplace_cooldownsecs)
    local isThreading = FSettings.pet_pickplace_threading

    local avoid_pets = FSettings.mut_system.targetteam

    for _uuid, pet_info in pairs(Varz.cooldown_pets) do
        local _petname = _Helper.PetDataLocal[_uuid]
        if not _petname then
            --warn("Not found name")
            continue
        end

        if _Helper.UnitProcessing[_uuid] or Varz.DisablePickPlace then
            continue
        end

        if _Helper.MatchNameInTable(_uuid, avoid_pets) then
            continue
        end

        for _, dx in ipairs(pet_info) do
            if _Helper.UnitProcessing[_uuid] or Varz.DisablePickPlace then
                -- unit is already processing
                --warn("Unit already processing. skip")
                break
            end
            local validPassives = _Helper.AllPetPassiveData[_petname]
            if not validPassives then
                --warn("Not validPassives")
                break
            end

            local Name = dx.Name
            local Passive = dx.Passive
            local Time = dx.Time

            if not Time or not Name or not Time then
                continue
            end

            if not _allowPets[Name] then
                -- _Helper.JsonPrint(_allowPets)
                break
            end


            local valid_passives_x = {}
            for _, vv in ipairs(validPassives) do
                if _Helper.Bad_Skills[vv] then
                    continue
                end
                valid_passives_x[vv] = true
            end

            if valid_passives_x[Passive] then
                --local ds = string.format("Passive %s Time %s", Passive, Time)
                --warn(ds)

                if Time <= _cd then
                    _Helper.UnitProcessing[_uuid] = true
                    if isThreading then
                        task.spawn(function()
                            _Helper.PickPlaceUnit(_uuid, Name)
                        end)
                    else
                        _Helper.PickPlaceUnit(_uuid, Name)
                    end
                end
            else
                --warn("Not valid passive ".. Passive)
            end
        end
    end
end


Varz.is_eggs_reduction_active = false
Varz.dead_pet_remover_time = 0

--- Faster Unequip #pickplace
if TaskManager.unequip_task_faster then
    task.cancel(TaskManager.unequip_task_faster)
    TaskManager.unequip_task_faster = nil
end

if TaskManager.pickplace_rester_sys then
    task.cancel(TaskManager.pickplace_rester_sys)
    TaskManager.pickplace_rester_sys = nil
end

TaskManager.pickplace_rester_sys = task.spawn(function()
    while true do
        task.wait(1)
        if Varz.IsPaused() then
            task.wait(0.3)
            continue
        end

        if Varz.pickplace_disable_delay > 0 then
            Varz.pickplace_disable_delay = Varz.pickplace_disable_delay - 1
            if Varz.pickplace_disable_delay <= 0 then
                Varz.pickplace_disable_delay = 0
            end
        end
    end
end)

-- #pickplace loop
TaskManager.unequip_task_faster = task.spawn(function()
    while true do
        task.wait(0.2)

        --#pro
        if not Varz.GetCheckIfPro() then
            break
        end

        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        if not FSettings.pet_pickplace_enabled or not Varz.is_eggs_reduction_active then
            if not FSettings.pet_pickplace_anywhere then
                task.wait(5)
                continue
            end
        end

        if not FSettings.is_running then
            Varz.DisablePickPlace = false
            if not FSettings.pet_pickplace_anywhere then
                Varz.is_eggs_reduction_active = false
                continue
            end
        end

        if Varz.dead_pet_remover_time > 500 then
            _Helper.RemoveDeadObjectsPetLeftOver()
            Varz.dead_pet_remover_time = 0
        end
        Varz.dead_pet_remover_time = Varz.dead_pet_remover_time + 1

        if Varz.IS_HATCHING then
            Varz.is_eggs_reduction_active = false
            task.wait(5)
            continue
        end

        if Varz.IS_PET_MUTATION_RUNNING then
            task.wait(3)
            continue
        end

        _Helper.PickPlacePetsFast()


        --_Helper.JsonPrint(Varz.cooldown_pets)
    end
end)





TaskManager.HatcherTeamOverrider = function()
    local is_enabled = FSettings.team_reduction_enabled_teams or false
    if not is_enabled then
        return "not_enabled"
    end

    if not Varz.GetCheckIfPro() then
        return "not_pro"
    end

    -- Core configuration
    local capacity = GetMaxPetCapacity()
    local main_team = FSettings.team3
    local phase_one_team = FSettings.team_reduction_placefirst
    local phase_two_team = FSettings.team_reduction_placeafter
    local wait_duration = tonumber(FSettings.team_reduction_timer) or 16.5

    local ui = UPDATE_LABELS_FUNC.UpdateSetLblStats

    ui("ðŸ’¡ Trying to place custom pet.")
    --task.wait(0.3)

    -- Validation
    if #main_team >= capacity then
        ui("ðŸ”´ Failed: Main egg reduction team is full, no remaining slots.")
        task.wait(3)
        return "team_maxed"
    end

    if #phase_one_team == 0 then
        ui("ðŸ”´ Failed: First team is empty.")
        task.wait(3)
        return "empty"
    end

    if #phase_two_team == 0 then
        ui("ðŸ”´ Failed: Last team is empty.")
        return "empty"
    end

    -- Start process
    local inserted_pets = {}
    local free_slots = capacity - #main_team

    -- Phase 1 â€” temporarily add reduction pets
    ui("â³ Placing phase 1 team, please wait...")
    local added_count = 0
    for _, uuid in ipairs(phase_one_team) do
        _Helper.EquipPet(uuid)
        table.insert(inserted_pets, uuid)
        added_count = added_count + 1

        if added_count >= free_slots then
            break
        end
    end
    --task.wait(0.1)
    local current_waited = 0
    local timeIcons = { "ðŸ•’", "ðŸ•“", "ðŸ•”", "ðŸ•ž", "ðŸ•Ÿ", "ðŸ• ", "ðŸ•¡" }

    while true do
        Varz.DisablePickPlace = false
        current_waited = current_waited + 1

        -- cycle through icons
        local iconIndex = ((current_waited - 1) % #timeIcons) + 1
        local iconx = timeIcons[iconIndex]
        local st = string.format(
            '%s <font color="#FF7B00">Waiting to remove first team... </font> <font color="#A6FF8F">%s/%s</font>',
            iconx,
            current_waited,
            wait_duration
        )
        ui(st)
        -- are we done?
        if current_waited >= wait_duration then
            break
        end
        task.wait(1)
    end

    Varz.SetDisablePickPlaceFor(3)
    task.wait(0.5)
    ui("ðŸ”„ Removing phase one team. Please wait...")
    -- Phase 2 â€” remove the temporary pets safely
    for _, uuid in ipairs(inserted_pets) do
        _Helper.UnEquipPet(uuid)
        task.wait(0.1)
        _Helper.UnEquipPet(uuid) -- second attempt for safety

        -- Up to 5 seconds: wait until fully removed
        local waitsecs = os.clock()
        while true do
            task.wait(0.1)

            if (os.clock() - waitsecs) > 5 then
                break
            end

            if not IsPetStillActiveInContainer(uuid) then
                break
            end
        end
    end

    ui("â„¹ï¸ Removed team phase one")
    --task.wait(0.3)

    ui("âš¡ Placing final phase team. please wait...")
    -- Phase 3 â€” place the final pets
    local final_count = 0
    for _, uuid in ipairs(phase_two_team) do
        _Helper.EquipPet(uuid)
        task.wait(0.1)
        _Helper.EquipPet(uuid)

        final_count = final_count + 1
        if final_count >= free_slots then
            break
        end
    end
    ui("âœ… Completed. moving to hatching process..")
    return "added"
end



-- RNG Detection #rng

-- CONFIGURATION
Varz.MAX_EGGS = GetMaxEggCapacity()
Varz.PENALTY_LOSS = 30     -- Points lost per negative gain
Varz.PENALTY_STAGNANT = 0  -- Points lost for 0 gain
Varz.CRITICAL_SCORE = 10   -- Score below this triggers REJOIN
Varz.UNSTABLE_SCORE = 30   -- Score below this triggers LOWER EGGS
Varz.MAX_HISTORY_LIMIT = 6 -- used to remove if we have more data
Varz.GOOD_SCORE = 30

Varz.RNG_EGG_OVERRIDE = GetMaxEggCapacity()

Varz.RemoveOldHatchHistory = function()
    if #Varz.hatch_history_list > Varz.MAX_HISTORY_LIMIT then
        -- Removes the item at index 1 and shifts everything else down
        table.remove(Varz.hatch_history_list, 1)
    end
end



Varz.AnalyzeRNG = function(history)
    local COUNT = 3

    if #history < COUNT then
        return { action = "WAIT", score = 100, reason = "Not enough data" }
    end

    local net_profit = 0

    for i = #history - COUNT + 1, #history do
        local gain = history[i].gain or 0
        if gain ~= 0 then
            net_profit = net_profit + gain
        end
    end

    -- Decision Logic
    if net_profit >= 2 then
        return {
            action = "CONTINUE",
            score = 100,
            reason = "Stable Profit (" .. net_profit .. ")"
        }
    elseif net_profit > -5 then
        -- Covers: -4, -3, -2, -1, 0, 1, 2
        return {
            action = "LOWER_AMOUNT",
            score = 50,
            reason = "Small Loss / Stall (" .. net_profit .. ")"
        }
    else
        -- Covers: -5, -6, ...
        return {
            action = "REJOIN",
            score = 10,
            reason = "Bad RNG / Big Loss (" .. net_profit .. ")"
        }
    end
end


-- #enhance
_Helper.findinf = function()
    local fruits = InventoryManager.GetFruitsFromBackpackSorted()
    --print("found fruits " .. #fruits)
    local amount = 0
    local can_sell = false
    Varz.StopEnhancer(6)
    for index, item in ipairs(fruits) do
        local MaxAge = item:GetAttribute("MaxAge")
        local s = item:GetAttribute("s")
        if s and MaxAge and MaxAge == math.huge then
            --warn("inf detected")
            _Helper.FavItemCustom(item, true)
            amount = amount + 1
        else
            if not InventoryManager.IsFavFruit(item) then
                _Helper.FavItemCustom(item, false)
                can_sell = true
            end
        end
    end
    local s_amount = 0
    -- for index, item in ipairs(fruits) do
    --     -- print("check fruit: " .. item.Name)
    --     local s = item:GetAttribute("s")
    --     if s then
    --         --warn("inf detected")
    --         --_Helper.FavItemCustom(item, true)
    --         s_amount = s_amount + 1
    --     end
    -- end
    -- print("-------S fruits: ", s_amount)

    --warn("Int fruits: ", amount)

    -- if amount > 0 then
    --     Varz.rng_found_stable_tools = true
    -- else
    --     Varz.rng_found_stable_tools = false
    -- end

    if can_sell then
        -- sell here
        if FSettings.fav_fruit_enhance_sell then
            Varz.StopEnhancer(7)
            Varz.SellFruitsToVendor()
        end
    end
end

-- #rng
-- task.spawn(function()
--     while true do
--         task.wait(2)
--         if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
--             task.wait(5)
--             continue
--         end
--         if not FSettings.fav_fruit_enhancer then
--             continue
--         end
--         task.wait(15)
--         _Helper.findinf()
--     end
-- end)


-- task.spawn(function()
--     while true do
--         task.wait(0.5)
--         local total_fruits = InventoryManager.GetFruitCount()
--         if total_fruits <= 0 then
--             local names = {}
--             names["Carrot"] = true;
--             local am = 1
--             _FruitCollectorMachine.CollectFruitByNamesSortedRarity(names, am)
--             task.wait(3)
--             continue
--         end

--         if Varz.backpack_full then
--             task.wait(4)
--             continue
--         end

--         if Varz.was_hatch_done then
--             if Varz.gains <= 3 then
--                 local fruit = InventoryManager.GetFruitRandomOrHeld()
--                 _Helper.FavItemCustom(fruit, false)
--                 print("Bad Gains delete fruit")
--                 task.wait(1)
--                 Varz.backpack_full = true
--                 task.wait(5)
--             else
--                 print("Good fruit exit")
--                 break
--             end
--         end

--         local fruit = InventoryManager.GetFruitRandomOrHeld()
--         if fruit then
--             MakeFruitsFavSingle(fruit)
--         end
--     end
-- end)



local waiting_for_hatch_count = 0
Varz.spinnerFrames = { "â—", "â—“", "â—‘", "â—’" }
Varz.spinner_frames = 1
Varz.rejoin_hatch_count = 0

-- #hatch
local function SessionLoop()
    -- This loop runs continuously in the same server session without rejoining.
    local _key = "hatchtimer"
    while not Varz.is_forced_stop and FSettings.is_running do
        task.wait(0.3)

        -- Reset flags and counters for the new cycle
        newlyHatchedNames = {}
        new_pets_hatched_list = {}
        Varz.hatched_pets = {}

        is_pet_inventory_full = false
        canSendReport = false
        Varz.is_max_eggs_reached = false

        waiting_for_hatch_count = 0
        Varz.big_pets_hatch_models = {}

        Varz.IS_HATCHING = false
        Varz.is_eggs_reduction_active = false

        _Helper.UpdatePlayerStats() -- reset any buffs


        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Waiting for farm data to load.")
            task.wait(10)
            continue
        end

        Varz.SetDisablePickPlaceFor(6)

        UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ’¡ Checking for any eggs to hatch")
        task.wait(0.2)

        --========== Egg Timer Reduction Team


        local is_ready_hatch = CheckAnyEggsToHatch()
        local eggs_onfarm = GetCountEggsOnFarm()

        local start_timer = false

        Varz.IS_HATCHING = true
        if FSettings.disable_team3 == false then
            -- Place team only if eggs need reduction
            if is_ready_hatch == false then
                -- place team
                UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”„ Placing egg reduction team.")
                if UnEquipAllPets() == false then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to unequip team. Restarting.")

                    task.wait(1)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end

                if not EquipPets(FSettings.team3) then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to place egg reduction team. Restarting.")
                    task.wait(3)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end
                task.wait(0.3)
                _Helper.StartTimer(_key)
                start_timer = true

                -- Apply boosts to egg reduction team
                if FSettings.hatch_boost_eggcd_enabled then
                    Varz.IS_HATCHING = true
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸš€ Applying Boosts!")
                    MonsterBoostManager.ApplyBoostSelectedWithPetNames(FSettings.hatch_boost_eggcd_team,
                        FSettings.hatch_team_boost_targets)
                    task.wait(0.3)
                    Varz.IS_HATCHING = false
                end

                -- Place advanced setups
                Varz.IS_HATCHING = false
                Varz.is_eggs_reduction_active = true
                local success, fail = pcall(function()
                    Varz.DisablePickPlace = false
                    Varz.SetDisablePickPlaceFor(0)
                    task.wait(0.2)
                    local status_ad = TaskManager.HatcherTeamOverrider()
                end)

                if not success then
                    warn("Issue with advanced team placement: ", status_ad)
                end
            end
        end

        -- monitor hatching time
        if not start_timer then
            _Helper.StartTimer(_key)
        end

        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.2)
        elseif FSettings.hatch_slow_mode then
            task.wait(9.2)
        else
            task.wait(2.5)
        end

        Varz.IS_HATCHING = false

        -- _Helper.JsonPrint(Varz.hatch_history_list)
        -- check rng and next phase what to do
        local successz, resx = pcall(function()
            local actionrng = Varz.AnalyzeRNG(Varz.hatch_history_list)
            Varz.RemoveOldHatchHistory()
            print("  -> Action: " .. actionrng.action)
            print("  -> Score:  " .. actionrng.score .. "/100")
            local max_eggs = Varz.MAX_EGGS
            local lowest_am = math.floor(max_eggs / 2)
            if actionrng.action == "LOWER_AMOUNT" then
                -- Varz.RNG_EGG_OVERRIDE = Varz.RNG_EGG_OVERRIDE - 2
                -- if Varz.RNG_EGG_OVERRIDE < lowest_am then
                --     Varz.RNG_EGG_OVERRIDE = lowest_am
                -- end
                -- _S.LocalPlayer:SetAttribute("BLOCK_TIME_UPDATES", false)
                Varz.st_rng_detector_stable = "afk"
            end
            if actionrng.action == "CONTINUE" then
                -- rng is fine increase egg placement
                -- Varz.RNG_EGG_OVERRIDE = Varz.RNG_EGG_OVERRIDE + 3
                -- if Varz.RNG_EGG_OVERRIDE > Varz.MAX_EGGS then
                --     Varz.RNG_EGG_OVERRIDE = Varz.MAX_EGGS
                -- end
                -- _S.LocalPlayer:SetAttribute("BLOCK_TIME_UPDATES", true)
                Varz.st_rng_detector_stable = "good"
            end

            if actionrng.action == "REJOIN" then
                warn("Danger. RNG is bad")
                -- Varz.RNG_EGG_OVERRIDE = Varz.RNG_EGG_OVERRIDE - 2
                -- if Varz.RNG_EGG_OVERRIDE < lowest_am then
                --     Varz.RNG_EGG_OVERRIDE = lowest_am
                -- end
                Varz.st_rng_detector_stable = "bad"

                if FSettings.rng_auto_rejoin and FSettings.rng_use_system then
                    rejoinS()
                    task.wait(5)
                    -- continue
                end
            end
        end)

        if not successz then
            warn("Error RNG: ", resx)
        end




        -- Wait until there are eggs ready to hatch

        local last_boost_time = 0
        local delay_secs_for_boost = 13 -- 10s
        Varz.SetDisablePickPlaceFor(3)


        while FSettings.is_running do
            task.wait(0.5)

            -- [2] Check if 10 seconds have passed since the last boost
            if FSettings.always_active_boosts and FSettings.hatch_boost_eggcd_enabled and (os.clock() - last_boost_time >= delay_secs_for_boost) then
                -- Update the time immediately so it doesn't spam
                last_boost_time = os.clock()

                -- Apply the boost (without waiting/pausing the script)
                if not MonsterBoostManager.ApplyBoostSelectedWithPetNames(FSettings.hatch_boost_eggcd_team, FSettings.hatch_team_boost_targets) then
                    --print("No boost needs to be applied")
                end
                task.wait(0.3)
            end

            Varz.is_eggs_reduction_active = true
            Varz.DisablePickPlace = false
            local timel = _Helper.FormatTime(Varz.egg_hatch_time_left)
            local eggsc = GetCountEggsOnFarm()

            local txt_egs = "ðŸ¥š Eggs on farm: " .. eggsc

            local _infotext = Varz.spinnerFrames[Varz.spinner_frames] ..
                " Hatching in <font color='#FFFFFF'><b>" .. tostring(timel) .. "</b></font>"

            local _ntx = string.format("%s\n%s", _infotext, txt_egs)

            UPDATE_LABELS_FUNC.UpdateSetLblStats(_ntx)
            waiting_for_hatch_count = waiting_for_hatch_count + 1
            Varz.IS_HATCHING = false
            Varz.spinner_frames = (Varz.spinner_frames % #Varz.spinnerFrames) + 1

            if CheckAnyEggsToHatch() then
                break
            end

            if Varz.is_forced_stop then
                break
            end
        end

        Varz.is_eggs_reduction_active = false

        -- If the loop was stopped while waiting, exit now.
        if Varz.is_forced_stop or not FSettings.is_running then
            break
        end


        if GetCountEggsOnFarm() == 0 then
            print("No Eggs on farm detected, place and restart.")
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ¤– No eggs on farm. Placing new eggs...")
            -- #place  #eggs #egg
            task.spawn(function()
                local sx, fx = pcall(function()
                    _Helper.PlaceEggsForHatching()
                end)

                if not sx then
                    warn("Fail:", fx);
                end
            end)
            task.wait(1)
            continue
        end



        Varz.IS_HATCHING = true
        Varz.tracked_bonus_egg_recovery = 0
        Varz.tracked_bonus_egg_sell_refund = 0
        pet_size_bonus = 0
        passive_pet_bonus = 0
        Varz.pets_fav_count = 0
        got_eggs_back = 0
        recovered_eggs = 0

        UnEquipAllPets()

        if FSettings.pet_pickplace_enabled then
            --task.wait(5)
            -- #fast
            if FSettings.hatch_fast_mode then
                task.wait(0.5)
            elseif FSettings.hatch_slow_mode then
                task.wait(12)
            else
                task.wait(5)
            end
        end

        -- update what we own
        TrackPets()
        local eggs_onfarmx = GetCountEggsOnFarm()
        --if not FSettings.hatch_fast_mode then task.wait(0.4) else task.wait(0.1) end -- #fast
        --task.wait(0.3)

        UPDATE_LABELS_FUNC.UpdateSetLblStats("â­ Eggs are ready to hatch!.")

        --task.wait(0.5)
        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.1)
        elseif FSettings.hatch_slow_mode then
            task.wait(5)
        else
            task.wait(0.5)
        end

        BeforeUpdateEggCountForAllEggs()
        --local pet_snapshot_start = GameDataManager.Inventory.GetCurrentPetsInData()

        local pet_snapshot_start
        local ok, result = pcall(function()
            return GameDataManager.Inventory.GetCurrentPetsInData()
        end)

        if ok and result then
            pet_snapshot_start = result
        else
            warn("Failed to get pets:", result)
            pet_snapshot_start = {} -- fallback
        end


        local pet_snap_a = InventoryManager.GetAllPetsUUIDS_Backpack()

        Varz.SetDisablePickPlaceFor(3)
        --================= HATCH CYCLE =================
        -- Place Hatching Team (Team 2)
        if FSettings.disable_team2 == false then
            if UnEquipAllPets() == false then
                UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to unequip team. Restarting.")

                task.wait(4)
                Varz.IS_HATCHING = false
                continue -- Restart the loop
            end
            task.wait(0.2)
            UPDATE_LABELS_FUNC.UpdateSetLblStats("Placing hatching team...")
            if not EquipPets(FSettings.team2) then
                UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ [KOI] Team Failed to place. Missing team or pets. Restarting.")

                task.wait(5)
                Varz.IS_HATCHING = false
                continue -- Restart the loop
            end
        end

        UPDATE_LABELS_FUNC.UpdateSetLblStats("â³ Waiting for hatch buffs")
        --task.wait(3.5)
        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(2.3)
        elseif FSettings.hatch_slow_mode then
            task.wait(10)
        else
            task.wait(4)
        end

        -- apply any boosts
        if FOtherSettings.boost_auto_team_placed_koi then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸš€ Applying Boosts!")
            MonsterBoostManager.ApplyBoostHeldKoi();
            task.wait(0.2)
        end

        -- Apply Grandmaster sprinkler
        if FOtherSettings.boost_sprinkler_koi_team then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸš€ Placeing Grandmaster Sprinkler!")
            local item_namek = "Grandmaster Sprinkler"
            local _gm = FarmManager.GetSprinklerOnFarm(item_namek)
            if not _gm then
                --warn("Placed gm")
                WaterManager.Sprinkler.PlaceGrandMaster(item_namek)
            end
            task.wait(0.2)
        end



        UPDATE_LABELS_FUNC.UpdateSetLblStats("â™»ï¸ Hatching all available eggs...")
        _Helper.UpdatePlayerStats()
        Varz.tracked_bonus_egg_recovery = GameDataManager.GetPlayerEggRecovery()
        newlyHatchedNames = {} --  reset this so we tracking new pets
        new_pets_hatched_list = {}
        Varz.hatched_pets = {}

        local timeoutx = time()
        while Varz.tracked_bonus_egg_recovery < 1 do
            task.wait(0.5)
            if time() - timeoutx > 2 then
                break
            end
            Varz.tracked_bonus_egg_recovery = GameDataManager.GetPlayerEggRecovery()
        end


        HatchAllEggsAvailable(false) -- HATCH EGGS, provide false, we can't hatch big pets here
        task.spawn(function()
            local sx, fx = pcall(function()
                _Helper.PlaceEggsForHatching()
            end)

            if not sx then
                warn("Fail:", fx);
            end
        end)

        UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸŸ¢ Hatching Complete.")
        --task.wait(4)
        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(2)
        elseif FSettings.hatch_slow_mode then
            task.wait(7)
        else
            task.wait(5.5)
        end

        -- we no longer need hatching team to be equipped
        UnEquipAllPets()

        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.2)
        elseif FSettings.hatch_slow_mode then
            task.wait(5)
        else
            task.wait(2)
        end


        -- ============ BIG PET HATCH #big
        -- These pets can be hatched using pets that can increase size.
        if #Varz.big_pets_hatch_models > 0 then
            -- We have big pets to hatch

            -- place big pets hatching team here...
            -- Team 4 is big size pet team
            if FSettings.disable_team4 == false then
                Varz.SetDisablePickPlaceFor(4)
                if UnEquipAllPets() == false then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to unequip team. Restarting.")

                    task.wait(3)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end

                -- #fast
                if FSettings.hatch_fast_mode then
                    task.wait(3)
                elseif FSettings.hatch_slow_mode then
                    task.wait(5)
                else
                    task.wait(0.5)
                end
                UPDATE_LABELS_FUNC.UpdateSetLblStats("Placing pet size team...")
                if not EquipPets(FSettings.team4) then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Big Pet Team Failed to equip. Missing team or missing pets.")
                    task.wait(5)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end

                -- Apply boosts to big pet team
                if FSettings.hatch_boost_bron_enabled then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("Applying Boosts!")
                    MonsterBoostManager.ApplyBoostSelected(FSettings.hatch_boost_bron_team);
                    task.wait(0.3)
                end
            end

            if FSettings.auto_hatch_big_pets == true then
                UPDATE_LABELS_FUNC.UpdateSetLblStats("Hatching big pets.");
                task.wait(7)                -- wait for buffs
                _Helper.UpdatePlayerStats() --  update the player stats so we know if buffs were applied etc
                pet_size_bonus = Varz.PlayerSecrets.PetEggHatchSizeBonus

                HatchAllEggsAvailable(true) -- set to true to hatch all eggs including big
                task.spawn(function()
                    local sx, fx = pcall(function()
                        _Helper.PlaceEggsForHatching()
                    end)

                    if not sx then
                        warn("Fail:", fx);
                    end
                end)

                UPDATE_LABELS_FUNC.UpdateSetLblStats("Hatching Big Pets Complete.")

                -- #fast
                if FSettings.hatch_fast_mode then
                    task.wait(3)
                elseif FSettings.hatch_slow_mode then
                    task.wait(5)
                else
                    task.wait(3)
                end
            end
            UnEquipAllPets()
            task.wait(0.1)
        end


        if is_pet_inventory_full then
            SendErrorMessage("Your Pet Inventory is getting full! Some eggs were not hatched.")
            --Varz.is_forced_stop = true
            --break
        end

        -- We will track what new pets we got after the hatch.

        --local pet_snapshot_end = GameDataManager.Inventory.GetCurrentPetsInData()

        local pet_snapshot_end
        local ok1, result1 = pcall(function()
            return GameDataManager.Inventory.GetCurrentPetsInData()
        end)

        if ok1 and result1 then
            pet_snapshot_end = result1
        else
            warn("Failed to get pets:", result1)
            pet_snapshot_end = {} -- fallback
        end


        local pet_snap_b = InventoryManager.GetAllPetsUUIDS_Backpack()

        -- not needed for now
        local new_uuids = VulnManager.GetNewUUIDs(pet_snap_a, pet_snap_b)
        for _, uuids in ipairs(new_uuids) do
            Varz.hatched_pets[uuids] = true
        end

        local uuids_extra = VulnManager.GetNewUUIDs(pet_snapshot_start, pet_snapshot_end)
        -- print("Found uuids from extras: " .. #uuids_extra)
        for _, uuids in ipairs(uuids_extra) do
            Varz.hatched_pets[uuids] = true
        end

        local failed_pet_detection = false
        local difxx = 0
        local max_wait_timer = os.clock()
        UPDATE_LABELS_FUNC.UpdateSetLblStats("â™»ï¸ Detecting hatched pets. please wait...")
        local detection_attempts = 0
        local final_hatch_result = {}

        while true do
            local hpets, failedpets = VulnManager.GetHatchPetData(new_uuids)
            if #failedpets == 0 then
                final_hatch_result = hpets
                break
            end

            if #final_hatch_result > 0 then
                final_hatch_result = hpets
                break
            end

            -- max 40s wait
            if (os.clock() - max_wait_timer) > 40 then
                failed_pet_detection = true
                break
            end
            detection_attempts = detection_attempts + 1
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Detection failed count: " .. detection_attempts)
            task.wait(0.5)
        end

        if #final_hatch_result == 0 then
            failed_pet_detection = true
        end

        for _, item in ipairs(final_hatch_result) do
            local itemuuid = item.uuid
            if itemuuid then
                Varz.hatched_pets[itemuuid] = true
                difxx = difxx + 1
            end
        end

        --print("DIF: " .. difxx)

        if failed_pet_detection then
            print("Failed to detect pets")
        end


        if eggs_onfarmx == 0 then
            failed_pet_detection = false
        end


        --================= SELL CYCLE =================
        UPDATE_LABELS_FUNC.UpdateSetLblStats("â¤ï¸ Favouriting Pets...")

        if not _Helper.FavoritePetsNew(Varz.hatched_pets) then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to favorite pets Lag or delayed.. Retrying cycle...")
            task.wait(5)
            Varz.IS_HATCHING = false
            continue -- Restart the loop from the top instead of stopping
        end


        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.3)
        elseif FSettings.hatch_slow_mode then
            task.wait(10)
        else
            task.wait(2.5)
        end


        local can_sell = true

        if FSettings.hatch_sell_delayed then
            can_sell                                = false

            -- but check if we going to be full next hatch? we can check this using users max eggs unlocked and total pet inventory space and total current pets in inventory.
            local userMaxEggs, userMaxInventoryPets = GameDataManager.Inventory.GetMaxEggsAndInventorySpaceCount()
            local userTotalPets                     = GameDataManager.Inventory.GetTotalOwnedPets()

            if (userTotalPets + userMaxEggs) >= userMaxInventoryPets then
                can_sell = true
            end
        end

        if FSettings.is_sell_only_hatch_pet then
            can_sell = true
        end

        --warn("Can we sell?: ", can_sell)

        -- =================== #sell
        -- =================== Place Selling Team (Team 1)
        -- ===================
        if can_sell then
            if FSettings.disable_team1 == false then
                if UnEquipAllPets() == false then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Failed to unequip team. Restarting.")

                    task.wait(5)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end
                UPDATE_LABELS_FUNC.UpdateSetLblStats("Placing selling team...")
                if not EquipPets(FSettings.team1) then
                    UPDATE_LABELS_FUNC.UpdateSetLblStats(
                        "âŒ [SEAL] Team placement failed. Missing team or pets. Retrying...")

                    task.wait(5)
                    Varz.IS_HATCHING = false
                    continue -- Restart the loop
                end
            end

            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ’° Selling pets...")
            --task.wait(5) -- Wait for sell buffs to apply
            if FSettings.hatch_fast_mode then
                if FSettings.hatch_sell_delayed then
                    task.wait(4.2)
                else
                    task.wait(2.2)
                end
            elseif FSettings.hatch_slow_mode then
                task.wait(9)
            else
                task.wait(4.2)
            end

            -- Apply boosts to sell team
            if FSettings.hatch_boost_seal_enabled then
                UPDATE_LABELS_FUNC.UpdateSetLblStats("Applying Boosts!")
                MonsterBoostManager.ApplyBoostSelected(FSettings.hatch_boost_seal_team);
            end

            _Helper.UpdatePlayerStats()
            Varz.tracked_bonus_egg_sell_refund = GameDataManager.GetPlayerPetSellEggRefundChance()
            Varz.has_seal_sold_happen = false

            local timeoutxx = time()
            while Varz.tracked_bonus_egg_sell_refund < 1 do
                if time() - timeoutxx > 3 then
                    break
                end
                Varz.tracked_bonus_egg_sell_refund = GameDataManager.GetPlayerPetSellEggRefundChance()
                task.wait(0.5)
            end

            if not failed_pet_detection then
                SellAllPetsUnFavorite()
            else
                UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Unable to sell pets. Data issue detected. Skipping...")
            end


            local wsecs = time()
            while true do
                task.wait(0.5)
                if (time() - wsecs) > 3 then
                    print("Time out sell, unfav")
                    break
                end
                if Varz.has_seal_sold_happen then
                    break
                end
            end
            --task.wait(2)
            UPDATE_LABELS_FUNC.UpdateSetLblStats("Selling complete.")
            -- #fast
            if FSettings.hatch_fast_mode then
                task.wait(1)
            elseif FSettings.hatch_slow_mode then
                task.wait(10)
            else
                task.wait(5)
            end
        else
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Unable to sell pets, not allowed, due to settings.")
            print("ðŸ”´ Unable to sell pets, not allowed, due to settings.")
            if FSettings.hatch_fast_mode then
                task.wait()
            elseif FSettings.hatch_slow_mode then
                task.wait(5)
            else
                task.wait(1)
            end
        end
        -- =================== SELL DONE



        --================= CLEANUP AND REPORTING =================

        UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ¤– Placing new eggs...")
        UnEquipAllPets()
        -- #place  #eggs #egg
        placeMissingEggs(FarmManager.mFarm)                                          -- This function will set Varz.is_forced_stop if it runs out of eggs.
        --task.wait(0.5)
        if not FSettings.hatch_fast_mode then task.wait(0.5) else task.wait(0.1) end -- #fast

        if Varz.is_forced_stop then                                                  -- CRITICAL STOP: This cannot be recovered by retrying.
            UPDATE_LABELS_FUNC.UpdateSetLblStats("âŒ Out of eggs to place. Stopping farm.")
            --break
        end

        passive_pet_bonus = Varz.PlayerSecrets.PetPassiveBonus


        -- unequip player so it is not holding any tools.
        unequipTools() -- remove anything from players hand
        --task.wait(0.1)
        --UpdatePetData()
        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.1)
        elseif FSettings.hatch_slow_mode then
            task.wait(5)
        else
            task.wait(0.2)
        end


        AfterUpdateEggCountForAllEggs()



        --_Helper.JsonPrint(final_hatch_result)
        Varz.IS_HATCHING = false


        --========== Create webhook data
        local wb_data = {
            pets = final_hatch_result,
            koi_bonus = Varz.tracked_bonus_egg_recovery,
            seal_bonus = Varz.tracked_bonus_egg_sell_refund,
            bronto_bonus = pet_size_bonus,
            passive_bonus = passive_pet_bonus,
            egg_back = got_eggs_back,
            eggs_repaint = recovered_eggs,
            fav_count = Varz.pets_fav_count,
        }

        table.insert(VulnManager.HatchDataWebhook, wb_data)

        -- Update and save tracking data
        -- local hatched_this_cycle = #newlyHatchedNames
        -- if hatched_this_cycle > 0 then
        --     FSettings.pets_hatched_total = FSettings.pets_hatched_total + hatched_this_cycle
        --     FSettings.eggs_hatched_in_10_min_session = FSettings.eggs_hatched_in_10_min_session + hatched_this_cycle
        --     FSettings.eggs_hatched_in_hourly_session = FSettings.eggs_hatched_in_hourly_session + hatched_this_cycle
        --     SaveData()
        -- end

        -- if canSendReport then
        --     UPDATE_LABELS_FUNC.UpdateSetLblStats("Sending report...")
        --     --HatchReport()
        --     --task.wait(2)
        -- end

        UPDATE_LABELS_FUNC.UpdateSetLblStats("Cycle finished. Waiting for next batch.")

        if not FSettings.hatch_fast_mode then task.wait(0.2) else task.wait(0.1) end -- #fast

        -- Check if user requires rejoin.
        if FSettings.auto_restartjoin_server then
            Varz.rejoin_hatch_count = Varz.rejoin_hatch_count + 1
            if Varz.rejoin_hatch_count >= FSettings.auto_rejoin_after_hatchcount then
                -- user requires restart, do safe restart.
                Varz.IS_HATCHING = true
                task.wait(6)
                rejoinS()
                task.wait(5)
            else
                warn("Rejoin soon .. " .. Varz.rejoin_hatch_count)
            end
        end


        -- #fast
        if FSettings.hatch_fast_mode then
            task.wait(0.5)
        elseif FSettings.hatch_slow_mode then
            task.wait(3)
        else
            task.wait(0.5)
        end


        Varz.found_pet_data = {}
        Varz.found_crate_data = {}
        _Helper.StopTimer(_key)
    end -- End of main while loop

    -- Cleanup code for when the loop is stopped
    UPDATE_LABELS_FUNC.UpdateSetLblStats("Session-based hatching stopped.")
    FSettings.is_running = false

    SaveData()
    Varz.IS_HATCHING = false
end



PetMutation.STATE = {
    LEVEL = "LEVEL",
    MUTATE = "MUTATE",
}


-- Pet Mutation #mutloop
PetMutation.XpBoostApply = function()
    if FSettings.pet_mut_xpteam_boost_enabled then
        MutationMachineManager.UI.UpdateStats("Applying Boosts!")
        MonsterBoostManager.ApplyBoostSelectedWithPetNames(FSettings.pet_mut_xpteam_boosts,
            FSettings.pet_mut_xpteam_petlist);
        task.wait(0.3)
    end
end

PetMutation.MutationTeamBoostApply = function()
    if FSettings.pet_mutation_team_boost_enabled then
        task.wait(0.2)
        MutationMachineManager.UI.UpdateStats("Applying Boosts!")
        MonsterBoostManager.ApplyBoostSelectedWithPetNames(FSettings.pet_mutation_boost_list,
            FSettings.pet_mutation_team_list);
        task.wait(0.3)
    end
end

PetMutation.HasCheckedTeams = false

PetMutation.CheckMissingTeam = function(team_array)
    for _, uuid in ipairs(team_array) do
        local pd = GetPetDataByUUID(uuid)
        if not pd then return false end
    end
    return true
end

PetMutation.CheckTeamsForMissingPets = function()
    -- Local references for clarity
    local team_maxlevel   = FSettings.mut_system.maxlevel_team
    local team_xp         = FSettings.mut_system.xpteam
    local team_mut        = FSettings.mut_system.mut_team
    local team_baseweight = FSettings.mut_system.baseweight_team
    local team_target     = FSettings.mut_system.targetteam

    -- Max-level team
    if not PetMutation.CheckMissingTeam(team_maxlevel) then
        return false, "Max Leveling"
    end

    -- XP team
    if not PetMutation.CheckMissingTeam(team_xp) then
        return false, "XP"
    end

    -- Mutation team
    if not PetMutation.CheckMissingTeam(team_mut) then
        return false, "Mutation"
    end

    -- Base weight team
    if not PetMutation.CheckMissingTeam(team_baseweight) then
        return false, "Base Weight"
    end

    -- Target team
    -- if not PetMutation.CheckMissingTeam(team_target) then
    --     return false, "Target"
    -- end

    return true, ""
end

PetMutation.Loop = function()
    PetMutation.is_running = true
    while PetMutation.is_running do
        task.wait(0.3)
        Varz.IS_PET_MUTATION_RUNNING = false
        if next(FSettings.mut_system.wanted) == nil then
            PetMutation.mut_ui.UpdateStats("ðŸ”´ No mutations selected.")
            continue
        end

        local use_always_active_change = FSettings.mut_system.continue_enable
        local is_turbo_mode = FSettings.mut_system.turbo_xp_teams

        PetMutation.mut_ui.UpdateStats("ðŸŸ¢ Running Pet Mutation system")

        if not PetMutation.HasCheckedTeams then
            task.wait(1)
            PetMutation.mut_ui.UpdateStats("ðŸš¨ Checking teams please wait.")
            task.wait(1)
            local ck_teams, fail_name = PetMutation.CheckTeamsForMissingPets()

            if not ck_teams then
                local tx_team = string.format(
                    "âŒ Team <font color='#FF0000'>%s</font> team is missing pets, please update your team. Stopped.",
                    fail_name)
                PetMutation.mut_ui.UpdateStats(tx_team)
                task.wait(6)
                PetMutation.HasCheckedTeams = false
                break
            end

            PetMutation.HasCheckedTeams = true
        end

        -- Check if we need to max level any pets, these are pets that have reached required mutation and have not reached maximum level yet.
        if FSettings.mut_system.max_level_enable then
            local max_level_pets, is_turbo_maxed = PetMutation.mut.GetPetsRequireMaxLevel()
            local is_levelOnly = FSettings.mut_system.only_level_mode
            local _keylevel = "maxlevel"

            if #max_level_pets > 0 then
                Varz.IS_PET_MUTATION_RUNNING = true

                local teamlvl, petsAddedMl, isMaxLevelPlaced = PetMutation.mut.AdvancedTeamMaker(max_level_pets, true)

                if isMaxLevelPlaced then
                    PetMutation.mut_ui.UpdateStats("âœ¨ Placing Max Level Team")
                else
                    PetMutation.mut_ui.UpdateStats("ðŸŸ¡ Placing XP Team")
                end


                UnEquipAllPets()
                task.wait(1)
                UnEquipAllPets()
                task.wait(2)
                if not EquipPets(teamlvl) then
                    PetMutation.mut_ui.UpdateStats("âŒ Failed to place team xp/level")
                    task.wait(1)
                    continue
                end

                -- apply any boosts
                PetMutation.XpBoostApply()

                Varz.IS_PET_MUTATION_RUNNING = false

                _Helper.StartTimer(_keylevel)

                local last_boost_timexx = 0
                local delay_secs_for_boostxx = 10 -- 10s

                while PetMutation.is_running do
                    task.wait(0.3)
                    local anyreached, tbl_names = PetMutation.mut.HasPetReachedMaxLevel(max_level_pets,
                        petsAddedMl, isMaxLevelPlaced)

                    if #anyreached > 0 then
                        PetMutation.mut_ui.UpdateStats("âœ… Success Level, restarting... ")
                        task.wait(0.3)
                        break
                    end


                    if FSettings.always_active_boosts and (os.clock() - last_boost_timexx >= delay_secs_for_boostxx) then
                        -- Update the time immediately so it doesn't spam
                        last_boost_timexx = os.clock()
                        -- Apply the boost (without waiting/pausing the script)
                        PetMutation.XpBoostApply()
                        task.wait(0.3)
                    end

                    -- local str_names = ""
                    -- for _, _namep in ipairs(tbl_names) do
                    --     str_names = str_names .. _namep .. "\n"
                    -- end


                    local str_names = ""
                    local limit_display_names_ui = 6
                    local total_names = #tbl_names

                    for i, _namep in ipairs(tbl_names) do
                        if i > limit_display_names_ui then
                            break
                        end
                        str_names = str_names .. _namep .. "\n"
                    end

                    if total_names > limit_display_names_ui then
                        str_names = str_names ..
                            string.format("<font color='#FFA500'>+%d more</font>", total_names - limit_display_names_ui)
                    end

                    local totalx = #tbl_names

                    local team_name = "[ðŸ”· XP]"
                    if isMaxLevelPlaced then
                        team_name = "[âœ¨ Max]"
                    end

                    local _title = "â­ <font color='#00FF9D'>Max Leveling:</font>"
                    if is_levelOnly then
                        _title = "â¬†ï¸ <font color='#29D1FF'>LEVEL MODE</font> â¬†ï¸"
                    end

                    local timerx = _Helper.GetTimerFormatted(_keylevel)

                    local display_txt = string.format("%s %s (%s)\n%s \n%s",
                        team_name,
                        _title,
                        totalx, timerx, str_names)
                    PetMutation.mut_ui.UpdateStats(display_txt)
                    task.wait(0.5)
                end

                _Helper.StopTimer(_keylevel)
                continue
            end
        end

        task.wait(0.3)

        local pets_under_level = PetMutation.mut.GetPetsNotReadyForMutations()
        local pet_started_count = #pets_under_level
        local retry_count = 0
        -- Level pets until none left to level
        if #pets_under_level > 0 and PetMutation.GetCurrentTurn() == PetMutation.Turns.LEVEL then
            PetMutation.mut_ui.UpdateStats("ðŸŸ¢ Placing xp/leveling team")
            --local tm, petsAdded = PetMutation.mut.GenTeam(FSettings.mut_system.xpteam, pets_under_level)

            -- Advanced auto team picker placer.
            -- local tm, petsAdded, isMaxLevelPlaced = PetMutation.mut.SmartGenTeam_MaxLevel(pets_under_level, false)
            local tm, petsAdded, isMaxLevelPlaced = PetMutation.mut.AdvancedTeamMaker(pets_under_level, false)
            --pets_under_level = {}
            for _uuid, _ in pairs(petsAdded) do
                --table.insert(pets_under_level, _uuid)
            end
            task.wait(0.5)
            if isMaxLevelPlaced then
                PetMutation.mut_ui.UpdateStats("âœ¨ Placing Max Level Team âœ¨")
            else
                PetMutation.mut_ui.UpdateStats("ðŸŸ¢ Placing XP Team ðŸŸ¢")
            end

            Varz.IS_PET_MUTATION_RUNNING = true
            UnEquipAllPets()
            task.wait(1)
            UnEquipAllPets()
            task.wait(2)
            if not EquipPets(tm) then
                PetMutation.mut_ui.UpdateStats("âŒ Failed to place team")
                task.wait(1)
                continue
            end

            -- apply any boosts
            PetMutation.XpBoostApply()

            Varz.IS_PET_MUTATION_RUNNING = false

            -- start timers
            local _key = "xp_team"
            _Helper.StartTimer(_key)


            local was_break = false
            local was_end_turboxp = false

            local last_boost_timex = 0
            local delay_secs_for_boostx = 10 -- 10s

            while PetMutation.is_running do
                task.wait(0.3)
                if next(FSettings.mut_system.wanted) == nil then
                    break
                end

                if FSettings.always_active_boosts and (os.clock() - last_boost_timex >= delay_secs_for_boostx) then
                    -- Update the time immediately so it doesn't spam
                    last_boost_timex = os.clock()
                    -- Apply the boost (without waiting/pausing the script)
                    PetMutation.XpBoostApply()
                    task.wait(0.3)
                end

                -- check if any pets have reached any required levels
                local _reached, tbl_names, mturbo = PetMutation.mut.HasPetReachedRequiredLevel(pets_under_level,
                    petsAdded, isMaxLevelPlaced)
                if #_reached > 0 then
                    if mturbo then
                        was_break = true
                        was_end_turboxp = true

                        PetMutation.mut_ui.UpdateStats("ðŸ”„ Pet reached required level.")
                        task.wait(0.5)
                        break
                    end
                    if use_always_active_change then
                        local rmovedcount = 0

                        for _, ruuid in ipairs(_reached) do
                            _Helper.UnEquipPet(ruuid)
                            rmovedcount = rmovedcount + 1
                            petsAdded[ruuid] = nil
                            task.wait(0.3)
                        end
                        task.wait(0.4)
                        pets_under_level = PetMutation.mut.GetPetsNotReadyForMutations()
                        if #pets_under_level == 0 then
                            break
                        end
                        task.wait(0.3)
                        -- add new pets to the farm
                        local cadded = 0
                        for _, puuid in ipairs(pets_under_level) do
                            if cadded >= rmovedcount then
                                break
                            end

                            if petsAdded[puuid] then
                                continue
                            end

                            cadded = cadded + 1
                            _Helper.EquipPet(puuid)
                            petsAdded[puuid] = true
                            task.wait(0.2)
                        end

                        _Helper.StopTimer(_key)

                        -- apply any boosts
                        PetMutation.XpBoostApply()
                        _Helper.StartTimer(_key)
                    else
                        PetMutation.mut_ui.UpdateStats("âœ… Success, Pet Level Reached ")
                        pets_under_level = PetMutation.mut.GetPetsNotReadyForMutations()
                        if #pets_under_level == 0 then
                            break
                        end
                        if #pets_under_level > 0 then
                            was_break = true
                            task.wait(1)
                            break
                        end
                    end
                end

                -- prevent inf loop in case
                local count_pets_left = PetMutation.mut.GetPetsNotReadyForMutations()
                if #count_pets_left == 0 then
                    retry_count = retry_count + 1
                    task.wait(0.3)
                end
                if retry_count > 7 then
                    was_break = true
                    task.wait(0.5)
                    break
                end

                local str_names = ""
                local limit_display_names_ui = 6
                local total_names = #tbl_names

                for i, _namep in ipairs(tbl_names) do
                    if i > limit_display_names_ui then
                        break
                    end
                    str_names = str_names .. _namep .. "\n"
                end

                if total_names > limit_display_names_ui then
                    str_names = str_names ..
                        string.format("<font color='#FFA708'>+%d more...</font>", total_names - limit_display_names_ui)
                end

                local total_ = #FSettings.mut_system.targetteam
                local dif = total_ - #pets_under_level

                local team_name = "[â­ XP Team]"
                if isMaxLevelPlaced then
                    team_name = "[âœ¨ Max Level Team]"
                end

                -- nicely formatted timer display
                local timer_st = _Helper.GetTimerFormatted(_key)

                local disply_in = string.format("%s Leveling: (%s/%s)\n%s \n%s", team_name, dif, total_, timer_st,
                    str_names)

                PetMutation.mut_ui.UpdateStats(disply_in)
                task.wait(0.5)
            end

            -- Change turn
            if not was_break then
                PetMutation.UpdateTurn(PetMutation.Turns.MUTATE)
            end

            if not was_end_turboxp then
                _Helper.StopTimer(_key)
            end

            task.wait(0.3)
            continue
        end


        -- ================= mutation stage
        -- any pets require mutation?
        local pets_require_mut, _flag = PetMutation.mut.GetPetsNeedMutations()
        local count_started_mt = #pets_require_mut
        local is_weight_team_added = false
        local is_mut_team_added = false
        local tries_failure = 0
        local mut_key = "mutationtrack"
        --warn("Pet need mutation: "..count_started_mt)
        if #pets_require_mut > 0 and PetMutation.GetCurrentTurn() == PetMutation.Turns.MUTATE then
            local team_toplace = {}
            local fail_msg = "âŒ Failed to place mutation team"
            if _flag == "mut" then
                PetMutation.mut_ui.UpdateStats("ðŸŸ¢ Placing mutation team")
                team_toplace = _Helper.CloneArray(FSettings.mut_system.mut_team)
                is_mut_team_added = true
            elseif _flag == "weight" then
                PetMutation.mut_ui.UpdateStats("ðŸ˜ Placing weight increase team")
                fail_msg = "âŒ Failed to place base weight team"
                team_toplace = _Helper.CloneArray(FSettings.mut_system.baseweight_team)
                is_weight_team_added = true
            else
                PetMutation.mut_ui.UpdateStats("ðŸ”´ Failed to detect mode. ")
                task.wait(3)
                continue
            end



            if #team_toplace == 0 then
                PetMutation.mut_ui.UpdateStats("ðŸ”´ Missing mutation team or base weight team ")
                task.wait(3)
                continue
            end
            task.wait(0.3)

            local tm1, petsAddedM = PetMutation.mut.GenTeamMutation(pets_require_mut, team_toplace)
            Varz.IS_PET_MUTATION_RUNNING = true
            UnEquipAllPets()
            task.wait(2)
            UnEquipAllPets()
            task.wait(2)
            if not EquipPets(tm1) then
                PetMutation.mut_ui.UpdateStats(fail_msg)
                task.wait(1)
                continue
            end


            -- apply any boosts
            PetMutation.MutationTeamBoostApply()


            Varz.IS_PET_MUTATION_RUNNING = false

            local was_exit = false

            local last_boost_time = 0
            local delay_secs_for_boost = 10 -- 10s

            local pass_timex = 0
            _Helper.StartTimer(mut_key)
            while PetMutation.is_running do
                --warn("")
                task.wait(0.2)
                if next(FSettings.mut_system.wanted) == nil then
                    break
                end


                if FSettings.always_active_boosts and (os.clock() - last_boost_time >= delay_secs_for_boost) then
                    -- Update the time immediately so it doesn't spam
                    last_boost_time = os.clock()
                    -- Apply the boost (without waiting/pausing the script)
                    PetMutation.MutationTeamBoostApply()
                    task.wait(0.3)
                end


                -- checks success
                local anyreached, tbl_names = PetMutation.mut.HasPetsReachedRequiredMutations_OnFarm(pets_require_mut,
                    petsAddedM, _flag)
                if #anyreached > 0 then
                    _Helper.StopTimer(mut_key)
                    if is_weight_team_added then
                        if not FSettings.mut_system.elephant_hotswap then
                            was_exit = true
                            break
                        end
                    end
                    if use_always_active_change then
                        local t_removed = 0
                        for _, ruuid in ipairs(anyreached) do
                            _Helper.UnEquipPet(ruuid)
                            t_removed = t_removed + 1
                            petsAddedM[ruuid] = nil
                        end
                        task.wait(1)

                        -- Get any remaining pets.
                        pets_require_mut, _flag = PetMutation.mut.GetPetsNeedMutations()
                        if _flag == "N/A" then
                            -- truly no pets need mutation/baseweight
                            break
                        end
                        if #pets_require_mut == 0 then
                            -- no more pets left for mutation.
                            break
                        end

                        if is_weight_team_added and _flag ~= "weight" then
                            was_exit = true
                            break
                        end



                        -- WE have some pets to add back
                        local nadded = 0
                        for _, puuid in ipairs(pets_require_mut) do
                            if nadded >= t_removed then
                                -- we added same amount we removed.
                                break
                            end
                            if petsAddedM[puuid] then
                                continue
                            end
                            _Helper.EquipPet(puuid)
                            nadded = nadded + 1
                            petsAddedM[puuid] = true
                        end

                        -- Apply any boosts
                        PetMutation.MutationTeamBoostApply()
                        task.wait(1)
                        _Helper.StartTimer(mut_key)
                        continue
                    else
                        PetMutation.mut_ui.UpdateStats("âœ… Success, restarting... ")
                        was_exit = true
                        task.wait(1)
                        break
                    end
                    task.wait(0.3)
                    continue
                end



                -- what about failed?
                local anyfailed = PetMutation.mut.GetPetsNotReachedWantedMut(pets_require_mut, _flag)
                if #anyfailed > 0 then
                    _Helper.StopTimer(mut_key)
                    if is_weight_team_added then
                        if not FSettings.mut_system.elephant_hotswap then
                            was_exit = true
                            break
                        end
                    end
                    if use_always_active_change then
                        local t_removed = 0

                        for _, ruuid in ipairs(anyfailed) do
                            _Helper.UnEquipPet(ruuid)
                            t_removed = t_removed + 1
                            petsAddedM[ruuid] = nil
                        end
                        task.wait(1)

                        -- Get any remaining pets.
                        pets_require_mut, _flag = PetMutation.mut.GetPetsNeedMutations()

                        if _flag == "N/A" then
                            break
                        end

                        if #pets_require_mut == 0 then
                            -- no more pets left for mutation.
                            break
                        end

                        if is_weight_team_added and _flag ~= "weight" then
                            was_exit = true
                            break
                        end



                        -- WE have some pets to add back
                        local nadded = 0
                        for _, puuid in ipairs(pets_require_mut) do
                            if nadded >= t_removed then
                                -- we added same amount we removed.
                                break
                            end

                            if petsAddedM[puuid] then
                                continue
                            end

                            _Helper.EquipPet(puuid)
                            nadded = nadded + 1
                            petsAddedM[puuid] = true
                        end

                        -- apply any boosts
                        PetMutation.MutationTeamBoostApply()
                        _Helper.StartTimer(mut_key)
                    else
                        PetMutation.mut_ui.UpdateStats("ðŸ”´ Failed, restarting... ")
                        was_exit = true
                        task.wait(1)
                        break
                    end
                    continue
                end


                -- prevent inf loops
                local count_pets_require_mut, mflag = PetMutation.mut.GetPetsNeedMutations()
                if #count_pets_require_mut == 0 then
                    tries_failure = tries_failure + 1
                end

                if is_mut_team_added and mflag ~= "mut" then
                    -- we done with mutation?
                    PetMutation.mut_ui.UpdateStats("ðŸ”„ Switching mutation type...")
                    was_exit = true
                    task.wait(0.5)
                    break
                end

                if is_weight_team_added and mflag ~= "weight" then
                    -- we done with mutation?
                    PetMutation.mut_ui.UpdateStats("ðŸ”„ Switching mutation type...")
                    was_exit = true
                    task.wait(0.5)
                    break
                end

                -- check if required pets are on the active list
                local active_pets = GameDataManager.Inventory.GetActivePetsAsKeyVal()
                for xuuid, value in pairs(petsAddedM) do
                    if not active_pets[xuuid] then
                        tries_failure = tries_failure + 1
                    end
                end

                if tries_failure > 10 then
                    was_exit = true
                    task.wait(0.5)
                    break
                end


                local str_names = ""
                local xlimit_display_names_ui = 6
                local total_names = #tbl_names

                for i, _namep in ipairs(tbl_names) do
                    if i > xlimit_display_names_ui then
                        break
                    end
                    str_names = str_names .. _namep .. "\n"
                end

                if total_names > xlimit_display_names_ui then
                    str_names = str_names ..
                        string.format("<font color='#FFA500'>+%d more</font>", total_names - xlimit_display_names_ui)
                end

                local lbl_mutbw = "ðŸ§¬ Mutating Pets"
                if _flag == "weight" and is_weight_team_added then
                    lbl_mutbw = "ðŸ˜ Base Weight Pets"
                end
                local timerzx = _Helper.GetTimerFormatted(mut_key)
                local totalx = #FSettings.mut_system.targetteam
                local disply_in = string.format("%s Left: (%s)\n%s\n%s", lbl_mutbw, #pets_require_mut, timerzx, str_names)

                pass_timex = pass_timex + 1
                PetMutation.mut_ui.UpdateStats(disply_in)
                task.wait(1)

                -- try to clean any pet mutation.
                PetMutation.mut.CleanPet(pets_require_mut)
                task.wait(1)
            end



            -- Change turn only if loop was ended without any breaks
            if not was_exit then
                PetMutation.UpdateTurn(PetMutation.Turns.LEVEL)
            end
            task.wait(0.5)
            _Helper.StopTimer(mut_key)
            continue
        end

        -- Change turn

        -- self correct
        if count_started_mt > 0 and pet_started_count == 0 then
            -- level has nothing, and mutation has stuff to mutate.
            PetMutation.UpdateTurn(PetMutation.Turns.MUTATE)
            PetMutation.mut_ui.UpdateStats("ðŸŸ¢ Found pets to process.")
        else
            PetMutation.UpdateTurn(PetMutation.Turns.LEVEL)
            PetMutation.mut_ui.UpdateStats("ðŸ”´ No pets found to do anything.")
            task.wait(3)
        end


        task.wait(1)
        continue
    end

    PetMutation.is_running = false
    petmut_thread = nil
    FSettings.mut_system.is_ruuning = false
    SaveData()
end



PetMutation.StartThread = function()
    if petmut_thread then
        Library:Notify("Already running")
        return
    end

    if main_thread or mutation_thread or custom_team_system_thread then
        Library:Notify("Unable to start, other systems are active")
        return
    end


    if not FSettings.mut_system.is_ruuning then
        Library:Notify("Failed to start, user stopped.")
        return
    end

    Library:Notify("Started mutation")
    FSettings.mut_system.is_ruuning = true
    SaveData()
    petmut_thread = task.spawn(PetMutation.Loop)
end


PetMutation.StopThread = function()
    if not petmut_thread then
        Library:Notify("Not running...")
        return
    end
    Library:Notify("Stopped mutation")
    task.cancel(petmut_thread)
    petmut_thread = nil
    PetMutation.is_running = false
    FSettings.mut_system.is_ruuning = false
    SaveData()
end





---=========== Custom Teams
-- #teams
TaskManager.TeamsUiUpdate = function(_txt)
    Varz.TEXT_TEAM_SYSTEM = _txt
end
TaskManager.StartTeamsLoop = function()
    local ui = TaskManager.TeamsUiUpdate
    local teamtoplace = FSettings.customteams_team1
    if #teamtoplace == 0 then
        Library:Notify("Stopping system. No team selected.")
        ui("Stopping system. No team selected.");
        PetMutation.StopCustomTeams()
        return
    end
    Varz.pickplace_disable_delay = 10
    ui("[Team Running] Removing pets from farm.");
    task.wait(3)

    UnEquipAllPets()

    ui("[Team Running] Placeing teams");
    task.wait(0.3)

    if not EquipPets(teamtoplace) then
        local fmsg = "[Team Running] Failed to place team. Stopping"
        ui(fmsg);
        warn(fmsg)
        PetMutation.StopCustomTeams()
        task.wait(1)
        return
    end

    local keyx = "teamsystem_t1"
    ui("[Team Running] Started");
    task.wait(1)
    _Helper.StartTimer(keyx)
    while FSettings.is_running_custom_teams do
        task.wait(1)
        local timerzx = _Helper.GetTimerFormatted(keyx)
        local disply_in = string.format("[Team Running] \n%s", timerzx)
        ui(disply_in);
    end
    _Helper.StopTimer(keyx)
    PetMutation.StopCustomTeams()
end




PetMutation.StartCustomTeams = function()
    if custom_team_system_thread then
        Library:Notify("Already running")
        return
    end

    if main_thread or mutation_thread or petmut_thread then
        Library:Notify("Unable to start, other systems are active")
        FSettings.is_running_custom_teams = false
        SaveData()
        return
    end


    Library:Notify("Started system")
    FSettings.is_running_custom_teams = true
    SaveData()
    custom_team_system_thread = task.spawn(TaskManager.StartTeamsLoop)
end


PetMutation.StopCustomTeams = function()
    if not custom_team_system_thread then
        Library:Notify("Not running...")
        return
    end
    Library:Notify("Stopped system")
    if custom_team_system_thread then
        task.cancel(custom_team_system_thread)
    end

    custom_team_system_thread = nil
    FSettings.is_running_custom_teams = false
    SaveData()
end











-- Mutation Machine
MutationMachineManager.ForceLevelingTeam = false
MutationMachineManager.FirstChecker = false

-- #mut
MutationMachineManager.MachineLoop = function()
    while MutationMachineManager.is_running do
        Varz.IS_MUTATION_RUNNING = false
        task.wait(3)

        Varz.max_pet_inventory_space = false
        MutationMachineManager.UI.UpdateStats("Running mutation system")

        if next(FOtherSettings.mut_target_mutations) == nil then
            MutationMachineManager.is_running = false
            Library:Notify("[Stopped] Please select mutations", 3)
            break
        end

        -- Check current mutation machine status
        local current_stats = MutationMachineManager.GetCurrentStatus()

        if FOtherSettings.mut_batch_process_enable and MutationMachineManager.GetCurrentTurn() == MutationMachineManager.Status.TURN_LEVEL then
            if not MutationMachineManager.FirstChecker then
                MutationMachineManager.ForceLevelingTeam = true
                MutationMachineManager.FirstChecker = true --this will never run again
            end
        end

        --================ STATE âšª LEVEL
        if MutationMachineManager.ForceLevelingTeam == true then
            -- this was flagged, user requires leveling, they do not have any pets
            -- Must unequip all pets before we can check
            MutationMachineManager.ForceLevelingTeam = false
            local is_level_success_mutated = FOtherSettings
                .mut_max_level_successfulpets -- maybe we can level the success pets to max levels

            local findpetforlevel = MutationMachineManager.GetAvailablePetsForLeveling()
            if #findpetforlevel == 0 then
                if is_level_success_mutated == false then
                    MutationMachineManager.UI.UpdateStats("Theres nothing to level, going idle for a while...")
                    warn("Theres nothing to level, going idle for a while...")
                    task.wait(15)
                    continue
                end
            end

            local was_found_level_max = false
            local max_lvl_pets_team = {}

            if is_level_success_mutated then
                -- user wants to max the mutated pets
                local matchedCount = MutationMachineManager.GetPetsToMaxLevelMetMutationGoal()
                task.wait(0.2)
                if #matchedCount == 0 then
                    -- don't have anything to max level
                else
                    findpetforlevel = matchedCount
                    max_lvl_pets_team = matchedCount
                    was_found_level_max = true
                end
            end

            if #findpetforlevel == 0 then
                MutationMachineManager.UI.UpdateStats("No pets to level. Retrying...")
                task.wait(1)
                continue
            end



            local pet_to_level_array = MutationMachineManager.MakeLevelingTeam(findpetforlevel)
            if #pet_to_level_array == 0 then
                MutationMachineManager.UI.UpdateStats("Could not make a team for leveling... retrying...")
                warn("After making team, user still has no pets for leveling, idle for a while...")
                task.wait(3)
                continue
            end
            -- user has some pets to level, level them

            UnEquipAllPets()
            task.wait(2)
            if not EquipPets(pet_to_level_array) then
                warn("Failed to place leveling support team. Will retry.")
                MutationMachineManager.UI.UpdateStats("Failed to place leveling team, retry..")
                task.wait(3)
                continue
            end
            task.wait(3)

            -- apply any boosts
            if FSettings.mutation_boost_level_team_enabled then
                Varz.IS_MUTATION_RUNNING = true
                task.wait(2)
                MutationMachineManager.UI.UpdateStats("Applying Boosts!")
                MonsterBoostManager.ApplyBoostSelected(FSettings.mutation_boost_level_team);
                task.wait(0.3)
                Varz.IS_MUTATION_RUNNING = false
            end

            -- level until we have some pet to submit
            local pets_for_submit = MutationMachineManager.GetPetsReadyForSubmit()

            local state_claim = MutationMachineManager.Status.CLAIM_PET
            local state_startmut = MutationMachineManager.Status.START_MUTATION

            MutationMachineManager.UI.UpdateStats("Placed leveling team..")
            while true do
                --warn("Leveling pets")
                task.wait(0.03)
                if current_stats == state_claim or current_stats == state_startmut then
                    if not FOtherSettings.mut_batch_process_enable then
                        break
                    end
                end

                if is_level_success_mutated and was_found_level_max then
                    MutationMachineManager.UI.UpdateStats("âœ¨ Leveling Pets TO MAX LEVEL")
                    local anypetsreachedmaxlevel = MutationMachineManager.GetHasPetsReachedMaxLevelMutationGoal(
                        max_lvl_pets_team)
                    if anypetsreachedmaxlevel then
                        warn("Success, one or more pet has reached max level.")
                        break
                    end
                    current_stats = MutationMachineManager.GetCurrentStatus()
                else
                    pets_for_submit = MutationMachineManager.GetPetsReadyForSubmit()
                    current_stats = MutationMachineManager.GetCurrentStatus()
                    local currentTurn = MutationMachineManager.GetCurrentTurn()

                    if FOtherSettings.mut_batch_process_enable and currentTurn == MutationMachineManager.Status.TURN_LEVEL then
                        -- if batch process is enabled then allow leveling until we no longer have any pets left
                        local remain_pets_to_level, tbl_names = MutationMachineManager.GetPetsNotReadyForSubmit()
                        local left_to_level = #findpetforlevel - #remain_pets_to_level
                        local str_names = ""
                        for _, _namep in ipairs(tbl_names) do
                            str_names = str_names .. _namep .. "\n"
                        end

                        local checkOnFieldPetLevel = MutationMachineManager.GetPetsReachedMutationLevelRequirement(
                            findpetforlevel)
                        --warn("######### [On_Field_Pets] " .. #checkOnFieldPetLevel)

                        local display_left_c = string.format("ðŸŸ¢ Batch lvl (%s/%s)\n%s", left_to_level, #findpetforlevel,
                            str_names)

                        MutationMachineManager.UI.UpdateStats(display_left_c)
                        if #remain_pets_to_level == 0 then
                            -- we are done, switch to machine
                            MutationMachineManager.UI.UpdateStats("ðŸŸ¢ Leveling batch completed.. switching to mutation.")
                            MutationMachineManager.SetNewTurn(MutationMachineManager.Status.TURN_CD)
                            task.wait(0.5)
                            break
                        end

                        -- important check if on field targets have reached target level for mutation.

                        if #checkOnFieldPetLevel > 0 then
                            warn("One or more units has reached max level.")
                            -- enforce leveling system to resume
                            MutationMachineManager.ForceLevelingTeam = true
                            MutationMachineManager.UI.UpdateStats("âœ… One or more pet leveled to requirement.")
                            task.wait(0.1)
                            break
                        end

                        task.wait(1)
                        continue
                    else
                        pets_for_submit = MutationMachineManager.GetPetsReadyForSubmit()
                        if #pets_for_submit > 0 then
                            warn("Found pet to submit, stop leveling...")
                            break
                        end
                    end

                    MutationMachineManager.UI.UpdateStats("ðŸŸ¢ Leveling up pets")
                end

                task.wait(3)
            end

            if MutationMachineManager.ForceLevelingTeam then
                -- above loop request level enfrocement
                continue
            end

            MutationMachineManager.UI.UpdateStats("Complete, Have a pet to submit.")
            task.wait(2)
        end

        --================ STATE âœ… CLAIM PET
        if current_stats == MutationMachineManager.Status.CLAIM_PET then
            --warn("Claim pet from machine")
            -- place team claim team here
            local was_claim_team_placed = false
            Varz.IS_MUTATION_RUNNING = true
            if #FOtherSettings.mut_claimpet_team > 0 then
                UnEquipAllPets()
                task.wait(2)

                if not EquipPets(FOtherSettings.mut_claimpet_team) then
                    --warn("Team failed to please, restart")
                    MutationMachineManager.UI.UpdateStats("Claim Pet: Team failed to place, retry..")
                    task.wait(5)
                    continue
                end
                -- Apply boosts here

                -- apply any boosts
                if FSettings.mutation_boost_claim_enabled then
                    MutationMachineManager.UI.UpdateStats("Applying Boosts!")
                    MonsterBoostManager.ApplyBoostSelected(FSettings.mutation_boost_team_claim);
                    task.wait(0.3)
                end
                was_claim_team_placed = true
            else
                MutationMachineManager.UI.UpdateStats("Claim Pet: No team to place.")
                warn("Claim Pet: No team to place.")
            end
            task.wait(1)
            MutationMachineManager.ClaimMutatedPet()
            --warn("Claimed pet.")
            MutationMachineManager.UI.UpdateStats("Claiming pet.")
            task.wait(4)

            if was_claim_team_placed then
                UnEquipAllPets()
            end

            -- check if it was success? maybe user backpack is full

            if Varz.max_pet_inventory_space then
                MutationMachineManager.UI.UpdateStats("[Stop] Unable to claim pet, no space in your inventory")
                _Helper.SendWebhookSendError(
                    "[Stopped] Max Pet Inventory. Unable to claim pet from your mutation machine.")
                MutationMachineManager.is_running = false
                Library:Notify("Stopping, unable to claim pet.")
                break
            end

            -- check mutation the pet got after claiming.
            local claimuuid = ""
            local uuid, datax = next(Mutation_Data)
            if uuid and datax then
                local PetType = datax.PetType
                local MutationType = datax.MutationType
                local Name = datax.Name
                claimuuid = uuid
                table.insert(MutationTableWebhook, datax)
                local mutname = MutationMachineManager.AllMutationListEnum[MutationType]
                local cmstr = string.format("Claimed: %s Mut: %s ", PetType, mutname)
                MutationMachineManager.UI.UpdateStats(cmstr)
            end
            -- discard any data

            Mutation_Data = {}
            task.wait(1)

            if not MutationMachineManager.InsertPetBackIntoTargetList(claimuuid) then
                local saveduuid = MutationMachineManager.GetUUID_PetInMachine()
                if saveduuid ~= "" then
                    MutationMachineManager.InsertPetBackIntoTargetList(saveduuid)
                end
            end

            task.wait(0.2)
            MutationMachineManager.ResetPetSavedUUID()
            task.wait(1)
            unequipTools()

            -- Try to fav the pet
            local pet_g = InventoryManager.GetPetUsingUUID(claimuuid)
            if pet_g then
                MakeFruitsFavSingle(pet_g)
                task.wait(0.3)
            end

            UpdatePetData()
            task.wait(1.5)
            Varz.IS_MUTATION_RUNNING = false
            continue
        end

        --================ STATE ðŸ”„ COOLDOWN [RUNNING]
        if current_stats == MutationMachineManager.Status.SKIP then
            -- Put machine cooldown team
            -- But if we dont have anything to submit then we can't cooldown the machine.
            MutationMachineManager.ForceLevelingTeam = false
            if #FOtherSettings.mut_mutation_machineteam > 0 then
                UnEquipAllPets()
                task.wait(2)
                if not EquipPets(FOtherSettings.mut_mutation_machineteam) then
                    --warn("Failed to place cooldown team.")
                    MutationMachineManager.UI.UpdateStats("Failed to place cooldown team.")
                    task.wait(2)
                    continue
                end
                task.wait(2)

                -- apply any boosts
                if FSettings.mutation_boost_cd_team_enabled then
                    MutationMachineManager.UI.UpdateStats("Applying Boosts!")
                    MonsterBoostManager.ApplyBoostSelected(FSettings.mutation_boost_cd_team);
                    task.wait(0.3)
                end

                while current_stats == MutationMachineManager.Status.SKIP do
                    --warn("Machine cooldown team is active...")
                    MutationMachineManager.UI.UpdateStats("Cooldown Team is active")
                    current_stats = MutationMachineManager.GetCurrentStatus()
                    task.wait(3)
                end

                continue
            else
                if not FOtherSettings.mut_batch_process_enable then
                    MutationMachineManager.ForceLevelingTeam = true
                    MutationMachineManager.UI.UpdateStats("No cooldown team. Trying to level.")
                    continue
                else
                    MutationMachineManager.UI.UpdateStats("No cooldown team. Going idle...")
                    task.wait(15)
                    continue
                end
            end
        end


        --================ STATE ðŸŸ¡ SUBMIT A PET
        if current_stats == MutationMachineManager.Status.SUBMIT_PET then
            MutationMachineManager.ForceLevelingTeam = false
            -- check if we have any pets to level that are less than required
            local ready_for_submit = MutationMachineManager.GetPetsReadyForSubmit()
            if #ready_for_submit == 0 then
                -- find any pets to level
                --warn("No pets found to level and no pets ready , means user has nothing to mutate, ending");
                MutationMachineManager.ForceLevelingTeam = true
                MutationMachineManager.UI.UpdateStats("Not pets to submit, restarting checks..")
                MutationMachineManager.SetNewTurn(MutationMachineManager.Status.TURN_LEVEL)
                task.wait(3)
                continue
            else
                MutationMachineManager.ForceLevelingTeam = false
                MutationMachineManager.UI.UpdateStats("Submitting new pet")
                local _petuuid = ready_for_submit[math.random(1, #ready_for_submit)]
                Varz.IS_MUTATION_RUNNING = true
                --warn("Got pet to submit: " .. _petuuid)
                -- store identifier
                UnEquipAllPets()
                task.wait(4)
                local pet_tool = InventoryManager.GetPetUsingUUID(_petuuid)
                if pet_tool then
                    -- unfave
                    local isFav = pet_tool:GetAttribute("d")
                    if isFav then
                        MutationMachineManager.UI.UpdateStats("Unfavorite pet...")
                        MakeFruitsFavSingle(pet_tool)
                        task.wait(1)
                    end

                    unequipTools()
                    task.wait(0.4)
                    EquipToolOnChar(pet_tool)
                    task.wait(1)
                    MutationMachineManager.SubmitHeldPet()
                    MutationMachineManager.UI.UpdateStats("Submitted pet")
                    task.wait(0.7)
                    MutationMachineManager.SavePetUUID(_petuuid)
                end

                task.wait(2)
                UpdatePetData()
                task.wait(1.3)
                Varz.IS_MUTATION_RUNNING = false
            end
        end

        --================ STATE ðŸŸ¢ START MACHINE
        if current_stats == MutationMachineManager.Status.START_MUTATION then
            MutationMachineManager.ForceLevelingTeam = false
            -- there is pet in the machine, start it
            warn("Starting machine...")
            MutationMachineManager.UI.UpdateStats("Starting mutation")

            local Uuid, pdata = next(Mutation_SubmitPet)
            if Uuid then
                MutationMachineManager.SavePetUUID(Uuid)
            end

            MutationMachineManager.StartMachine();
            Mutation_SubmitPet = {}
            task.wait(1)
            MutationMachineManager.UI.UpdateStats("Machine has started")
            UpdatePetData()
            task.wait(3)
            continue
        end
    end

    MutationMachineManager.is_running = false
    mutation_thread = nil
    FOtherSettings.mut_was_running = false
    SaveDataOther()
end




MutationMachineManager.StartThread = function()
    if mutation_thread then
        Library:Notify("Already running..")
        return
    end

    if main_thread or petmut_thread or custom_team_system_thread then
        Library:Notify("Unable to start, other systems are active.")
        return
    end


    MutationMachineManager.is_running = true
    mutation_thread = task.spawn(MutationMachineManager.MachineLoop)

    FOtherSettings.mut_was_running = true
    SaveDataOther()

    Library:Notify("Mutation Machine is now running...")
end


MutationMachineManager.StopThread = function()
    if not mutation_thread then
        Library:Notify("Not running...")
        return
    end
    MutationMachineManager.is_running = false
    task.cancel(mutation_thread)
    mutation_thread = nil
    Library:Notify("Mutation Machine stopped...")
    FOtherSettings.mut_was_running = false
    SaveDataOther()
end



--  Make ui
--  Create dropdowns
Varz.GetTextUserHubPower = function()
    local title = _S.AppName
    local isPremium = Varz.is_pro

    if isPremium then
        return string.format(
            "<font color='#FFE075'>%s</font> <font color='#FF00C8'>PRO</font>",
            title
        )
    else
        return string.format(
            "%s",
            title
        )
    end
end

Varz.StartHatchingSystem = function()
    if main_thread then
        Library:Notify("Already running", 3)
        return
    end

    if petmut_thread or mutation_thread or custom_team_system_thread then
        Library:Notify("Unable to start hatching system. Other systems are running.", 3)
        return
    end

    FSettings.is_running = true
    FSettings.is_auto_rejoin = true
    Varz.is_forced_stop = false
    main_thread = task.spawn(SessionLoop);
    SaveData()
end

Varz.StopHatchingSystem = function()
    FSettings.is_running = false
    FSettings.is_auto_rejoin = false
    Varz.is_forced_stop = true
    SaveData()
    task.cancel(main_thread);
    main_thread = nil
    Library:Notify("Hatching stopped.", 3)
    UPDATE_LABELS_FUNC.UpdateSetLblStats("Stopped By User")
end


local Window = Library:CreateWindow({
    Title = Varz.GetTextUserHubPower(),
    Footer = _S.CurentV,
    ToggleKeybind = Enum.KeyCode.RightControl,
    Center = true,
    AutoShow = true
})
-- Now, add this line to make the background block clicks
if Library.ScreenGui.Main.Active then
    Library.ScreenGui.Main.Active = true
end

-- #homeui
-- HomeDashboardUi =======================================
local function HomeDashboardUi()
    local sv = GetServerVersion()
    local MainTab = Window:AddTab({
        Name = "Home",
        Description = "Game Server Version: " .. sv,
        Icon = "house"
    })

    -- Add a groupbox to the left side
    local GroupAutoFarm = MainTab:AddLeftGroupbox("Auto Hatch", "calendar-sync", false)
    local gpSystem = MainTab:AddRightGroupbox("System", "monitor-cog", false)
    local GroupFarmDetails = MainTab:AddRightGroupbox("Farm Details", "tent-tree", false)

    --=====================================
    -- Pause All Systems
    --=====================================
    UpdatePetData()
    if gpSystem then
        gpSystem:AddLabel({
            Text =
            "<font color='#FFA500'>â¸ï¸ Pause all systems.</font>\n<font color='#CCCCCC'>This does NOT pause hatching or mutation.</font>",
            DoesWrap = true
        })


        gpSystem:AddToggle("pausetoggleallsystems", {
            Text = "<font color='#FF5555'>â¸ï¸ Pause All Systems</font>",
            Default = FSettings.pause_systems,
            Tooltip = "Pause every system except hatching and mutation.",
            Callback = function(Value)
                FSettings.pause_systems = Value
                if Library then
                    local msg = Value
                        and "<font color='#FF5555'>â¸ï¸ All systems paused</font>"
                        or "<font color='#55FF55'>â–¶ï¸ All systems resumed</font>"

                    Library:Notify(msg, 3)
                end
                SaveData()
            end
        })
    end
    --------========================
    -- End Pause Systems
    --------========================




    --- Farm Details
    UI_LABELS.lbl_farm_plants_counts = GroupFarmDetails:AddLabel({
        Text = "-",
        DoesWrap = true
    })


    -- Text for stats
    UI_LABELS.lbl_stats = GroupAutoFarm:AddLabel({
        Text = "Stopped",
        DoesWrap = true
    })

    GroupAutoFarm:AddDivider()

    UI_LABELS.lbl_home_info = GroupAutoFarm:AddLabel({
        Text = "-",
        DoesWrap = true
    })

    GroupAutoFarm:AddLabel({
        Text =
        "<font color='#FF3B3B'>âš ï¸ [Warning] Do not trade, unfavourite or gift while the hatching system is active!</font>",
        DoesWrap = true
    })

    local StartAutoFarmButton = GroupAutoFarm:AddButton({
        Text = "ðŸŸ¢ Start Auto Hatching",
        Func = function()
            Varz.StartHatchingSystem()
        end,
    })


    local StopAutoFarmButton = GroupAutoFarm:AddButton({
        Text = "ðŸ”´ Stop Farming",
        Func = function()
            Varz.StopHatchingSystem()
        end,
    })

    GroupAutoFarm:AddDivider()

    GroupAutoFarm:AddButton({
        Text = "ðŸ¤– Unequip Team",
        Func = function()
            UnEquipAllPets()
        end,
    })
    GroupAutoFarm:AddDivider()

    GroupAutoFarm:AddToggle("MyMiddleToggle1", {
        Text = "ðŸ“ Spawn Middle",
        Default = FSettings.char_farm_middle,
        Tooltip = "Place your character in the centre of the farm when you join.",
        Callback = function(Value)
            FSettings.char_farm_middle = Value
            SaveData()
        end
    })

    GroupAutoFarm:AddDivider()
    local MyToggle = GroupAutoFarm:AddToggle("MyToggle1", {
        Text = "Test Mode",
        Default = FSettings.is_test,
        Tooltip = "Enable or disable testing",
        Callback = function(Value)
            FSettings.is_test = Value
            print("Toggle changed to:", Value)
            SaveData()
        end
    })



    local btnRejoin = GroupAutoFarm:AddButton({
        Text = "ðŸš¨ Rejoin Server",
        Func = function()
            rejoinS()
        end,
    })

    -- GroupAutoFarm:AddDivider();
    -- GroupAutoFarm:AddButton({
    --     Text = "ðŸ¥š Place Eggs",
    --     Func = function()
    --         _Helper.PlaceEggsForHatching()
    --     end,
    -- })
end
HomeDashboardUi();

-- END of HomeDashboardUi


-- ===========================================================================================
-- Pet Teams Tab #hatchui
Varz.PetTeamsUi = function()
    local TeamsTab = Window:AddTab({
        Name = "<font color='#FF3F00'>Hatching</font> Teams",
        Description = "<font color='#FFFFCC'>Manage teams used for hatching pets efficiently.</font>",
        Icon = "cat"
    })

    --- peacock
    local GroupBoxEggReductionTeam = TeamsTab:AddLeftGroupbox("Egg Reduction [<font color='#00CED1'>Peacock</font>]",
        "timer-reset")
    -- Koi
    local GroupBoxHatchingTeam = TeamsTab:AddRightGroupbox("Hatch Egg [<font color='#FF4500'>Koi</font>]", "egg")

    local GroupBoxSellingTeam = TeamsTab:AddRightGroupbox("Sell Egg [<font color='#1E90FF'>Seal</font>]",
        "badge-dollar-sign")


    local GroupBoxEggPetSizeTeam = TeamsTab:AddLeftGroupbox("Pet Size [<font color='#32CD32'>Bronto</font>]", "turtle")



    -- options
    local OptionsGroup = TeamsTab:AddLeftGroupbox("Options", "circle-ellipsis")
    local AutojoinGroup = TeamsTab:AddRightGroupbox("Auto Rejoin", "list-restart")

    local PetOverridesGroup = TeamsTab:AddRightGroupbox("Pet Overrides", "atom")
    local pickplaceGroup = TeamsTab:AddLeftGroupbox("ðŸ”„ Pick Place", "vault")

    local gExperiments = TeamsTab:AddRightGroupbox("<b><font color='#7CF4A8'>ðŸ§ª Experiments</font></b>",
        "test-tube-diagonal")



    -- ===============================================
    ---Experiments
    -- ===============================================

    if gExperiments then
        if Varz.GetCheckIfPro() then
            gExperiments:AddLabel({
                Text = "<b>ðŸ’¡ <font color='#8EEA8E'>Experiments</font></b>\n" ..
                    "<font color='#FFD65A'>These features are experimental.</font> " ..
                    "<font color='#FF6B6B'>They may workâ€¦ or may not!</font>",
                DoesWrap = true
            })


            -- // 1. Helper Functions for the Animation //
            local function toHex(color)
                return string.format("#%02X%02X%02X", color.R * 255, color.G * 255, color.B * 255)
            end

            local txt_enhance = gExperiments:AddToggle("gExperimentstoggle", {
                Text = "ðŸ¥š <font color='#6ECBFF'>Enhance Egg Returns</font>",
                Default = FSettings.fav_fruit_enhancer,
                Tooltip = "May improve egg drops from hatching.",
                Callback = function(Value)
                    FSettings.fav_fruit_enhancer = Value
                    SaveData()
                end
            })


            -- // 3. Run the Rainbow Loop //
            task.spawn(function()
                while task.wait(0.03) do -- Fast update for smoothness (30fps)
                    if txt_enhance then
                        -- tick() is time, * 0.5 is speed (higher = faster), % 1 loops it 0-1
                        local hue = tick() * 0.5 % 1
                        local rainbowColor = Color3.fromHSV(hue, 1, 1) -- (Hue, Saturation, Value)
                        local hex = toHex(rainbowColor)

                        -- Construct the Rich Text string
                        local newText = string.format("ðŸ¥š <font color='%s'><b>Enhance Egg Returns</b></font>", hex)

                        -- Update the UI
                        if txt_enhance.SetText then
                            txt_enhance:SetText(newText)
                        end
                    else
                        break -- Stop if toggle is destroyed
                    end
                end
            end)

            -- gExperiments:AddToggle("gExperimentstogglesell", {
            --     Text = "ðŸ§° <font color='#6ECBFF'>Allow Backpack Sell.</font>",
            --     Default = FSettings.fav_fruit_enhance_sell,
            --     Tooltip = "Allows the enhancer to delete some fruits. does not sell fav fruits.",
            --     Callback = function(Value)
            --         FSettings.fav_fruit_enhance_sell = Value
            --         SaveData()
            --     end
            -- })

            gExperiments:AddLabel({
                Text = "-------------------------------",
                DoesWrap = true
            })
            gExperiments:AddLabel({
                Text =
                "â™»ï¸ If RNG is bad it will try to reconnect if you have rejoin enabled.",
                DoesWrap = true
            })
            -- #rng
            gExperiments:AddToggle("gExperimentsrngtoggle", {
                Text = "ðŸ›¡ï¸ <font color='#6ECBFF'>RNG Protection</font>",
                Default = FSettings.rng_use_system,
                Tooltip = "Activates the rng watcher system.",
                Callback = function(Value)
                    FSettings.rng_use_system = Value
                    SaveData()
                end
            })

            gExperiments:AddToggle("gExperimentsrngtoggleauto", {
                Text = "ðŸ”„ <font color='#F52765'>RNG Auto Re-Join</font>",
                Default = FSettings.rng_auto_rejoin,
                Tooltip = "If bad rng is detected, auto rejoin will take place.",
                Callback = function(Value)
                    FSettings.rng_auto_rejoin = Value
                    SaveData()
                end
            })



            gExperiments:AddLabel({
                Text = "--------------------------",
                DoesWrap = false
            })





            gExperiments:AddLabel({
                Text =
                "ðŸ”¥ <font color='#FFD700'>Automatically places eggs</font> as soon as they hatch. <font color='#A0A0A0'>Reduces delay.</font>",
                DoesWrap = true
            })

            gExperiments:AddToggle("gExperimenteggstoggle", {
                Text = "âœ¨ <font color='#6ECBFF'>Fast Egg Placement</font>",
                Default = FSettings.fast_egg_placement,
                Tooltip =
                "<font color='#DADADA'>When enabled, missing eggs are placed <font color='#7CFF6E'>immediately</font> after hatching.</font>",
                Callback = function(Value)
                    FSettings.fast_egg_placement = Value
                    SaveData()
                end
            })

            gExperiments:AddLabel({
                Text = "--------------------------",
                DoesWrap = false
            })
        else
            -- Not Pro
            gExperiments:AddLabel({
                Text = Varz.GetProMessage(),
                DoesWrap = true
            })
        end
    end


    -- ===============================================
    --- End Experiments
    -- ===============================================


    -- ===============================================
    --- Pick Place #pickplaceui
    -- ===============================================
    if pickplaceGroup then
        if Varz.GetCheckIfPro() then
            pickplaceGroup:AddLabel({
                Text =
                "ðŸ’¡ When a pet is about to cast, or has just cast, a skill â€” unequip and re-equip it. This can benefit certain pets.",
                DoesWrap = true
            })
            local dpPickPlaceUnits = pickplaceGroup:AddDropdown("dpPickPlaceUnits", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 10,
                Text = "ðŸ”„ Pick Place",
                Callback = function(Values)
                    if Values == nil then
                        return
                    end
                    FSettings.pet_pickplacehatchingstage = Values
                    SaveData()
                end
            })

            dpPickPlaceUnits:SetValues(Varz.all_pets_names_list)
            dpPickPlaceUnits:SetValue(FSettings.pet_pickplacehatchingstage)


            local function GetPickPlaceTimeText()
                local displayickpalce = string.format("âŒ› Timer <font color='#7CFC00'>%s</font>s",
                    FSettings.pet_pickplace_cooldownsecs)
                return displayickpalce
            end

            local time_input_pickplace
            time_input_pickplace = pickplaceGroup:AddInput("time_input_pickplace", {
                Text = GetPickPlaceTimeText(),
                Default = FSettings.pet_pickplace_cooldownsecs,
                Numeric = true,
                AllowEmpty = true,
                Finished = true,
                ClearTextOnFocus = false,
                Placeholder = "1s",
                Tooltip = "Picks when pet skill is under x secs",
                Callback = function(Value)
                    local num = ParseWeightNumber(Value)

                    if num and num > 0 then
                        -- Update time if valid
                        FSettings.pet_pickplace_cooldownsecs = num
                        SaveData()
                        time_input_pickplace:SetText(GetPickPlaceTimeText())
                    else
                        Library:Notify("Invalid time: " .. Value, 3)
                        time_input_pickplace:SetValue(tostring(FSettings.pet_pickplace_cooldownsecs))
                    end
                end
            })


            local function GetPickPlaceActiveTimeText()
                local displayickpalce1 = string.format("ðŸ’¥ Delay B4 Unequip <b><font color='#FF00D7'>%s/s</font></b>",
                    FSettings.pet_pickplace_activactiondelay)
                return displayickpalce1
            end

            local time_input_activedelay
            time_input_activedelay = pickplaceGroup:AddInput("time_input_activedelay", {
                Text = GetPickPlaceActiveTimeText(),
                Default = FSettings.pet_pickplace_activactiondelay,
                Numeric = true,
                AllowEmpty = true,
                Finished = true,
                ClearTextOnFocus = false,
                Placeholder = "0.32",
                Tooltip = "Delay before unequip is called.",
                Callback = function(Value)
                    local num = ParseWeightNumber(Value)

                    if num and num > 0 then
                        -- Update time if valid
                        FSettings.pet_pickplace_activactiondelay = num
                        SaveData()
                        time_input_activedelay:SetText(GetPickPlaceActiveTimeText())
                    else
                        Library:Notify("Invalid time: " .. Value, 3)
                        time_input_activedelay:SetValue(tostring(FSettings.pet_pickplace_activactiondelay))
                    end
                end
            })



            local function GetPickPlaceEquipeTimeText()
                local displayickpalce2 = string.format("ðŸŽ¯ Delay B4 Equip <b><font color='#FFEE00'>%s/s</font></b>",
                    FSettings.pet_pickplace_equipe_delay)
                return displayickpalce2
            end
            local time_equipe_delaypp
            time_equipe_delaypp = pickplaceGroup:AddInput("time_equipe_delaypp", {
                Text = GetPickPlaceEquipeTimeText(),
                Default = FSettings.pet_pickplace_equipe_delay,
                Numeric = true,
                AllowEmpty = true,
                Finished = true,
                ClearTextOnFocus = false,
                Placeholder = "0.12",
                Tooltip = "Delay before equip is called.",
                Callback = function(Value)
                    local num = ParseWeightNumber(Value)

                    if num and num > 0 then
                        -- Update time if valid
                        FSettings.pet_pickplace_equipe_delay = num
                        SaveData()
                        time_equipe_delaypp:SetText(GetPickPlaceEquipeTimeText())
                    else
                        Library:Notify("Invalid time: " .. Value, 3)
                        time_equipe_delaypp:SetValue(tostring(FSettings.pet_pickplace_equipe_delay))
                    end
                end
            })

            pickplaceGroup:AddToggle("enableautopick", {
                Text = "âš¡ Enable Pick/Place",
                Default = FSettings.pet_pickplace_enabled,
                Tooltip = "When enabled your pets will be unequipped and equipped again. if hatching system is running.",
                Callback = function(Value)
                    FSettings.pet_pickplace_enabled = Value
                    SaveData()
                end
            })


            pickplaceGroup:AddToggle("enableautopickAnywhere", {
                Text = "âš ï¸ Work Anywhere",
                Default = FSettings.pet_pickplace_anywhere,
                Tooltip = "When enabled this will apply everywhere",
                Callback = function(Value)
                    FSettings.pet_pickplace_anywhere = Value
                    SaveData()
                end
            })


            pickplaceGroup:AddToggle("enableautopickThreading", {
                Text = "ðŸš€ Enable Threading",
                Default = FSettings.pet_pickplace_threading,
                Tooltip = "When enabled pets are picked/placed simultaneously.",
                Callback = function(Value)
                    FSettings.pet_pickplace_threading = Value
                    SaveData()
                end
            })

            pickplaceGroup:AddToggle("ranenableautopickUnequip", {
                Text = "â™»ï¸ Random Unequip Delay",
                Default = FSettings.pet_pickplace_random,
                Tooltip = "When enabled it will random your before unequip value. (-+ 10%)",
                Callback = function(Value)
                    FSettings.pet_pickplace_random = Value
                    SaveData()
                end
            })

            pickplaceGroup:AddToggle("ranenableautopickxxequip", {
                Text = "ðŸ”„ Random Equip Delay",
                Default = FSettings.pet_pickplace_random_equip,
                Tooltip = "When enabled it will random your before equip value. (-+ 10%)",
                Callback = function(Value)
                    FSettings.pet_pickplace_random_equip = Value
                    SaveData()
                end
            })
        else
            -- #pro
            pickplaceGroup:AddLabel({
                Text = Varz.GetProMessage(),
                DoesWrap = true
            })
        end


        pickplaceGroup:AddSpacer(200)
    end

    -- ===============================================
    --- End Pick Place #pickplaceui
    -- ===============================================



    -- #hatchui

    -- Pet Overrides
    if PetOverridesGroup then
        PetOverridesGroup:AddLabel({
            Text =
            "âš ï¸ Override pets, anything set here is applied everywhere teams are placed. Selected pets will be placed after a delay when team placement is called. Usedful for pets: [Ruby Squid]",
            DoesWrap = true
        })

        local dpPetOverrideDelay = PetOverridesGroup:AddDropdown("dpPetOverrideDelay", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ“¡ Delay Pets",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                FSettings.overridepets.selected_pets = Values
                SaveData()
            end
        })

        dpPetOverrideDelay:SetValues(Varz.all_pets_names_list)
        dpPetOverrideDelay:SetValue(FSettings.overridepets.selected_pets)


        local function GetTextDelayamountx()
            local ud = tonumber(FSettings.overridepets.delay_amount) or 2.5
            return string.format(
                "â° <font color='#FFFFFF'><b>Current Delay</b></font><stroke color='#6B5E0A' th='2' tr='0.5' joins='round' sizing='fixed'><font color='#E7E734'><b> %s</b></font>s</stroke>",
                ud
            )
        end

        local input_overridepets_delay_am
        input_overridepets_delay_am = PetOverridesGroup:AddInput("input_overridepets_delay_am", {
            Text = GetTextDelayamountx(),
            Default = FSettings.overridepets.delay_amount,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 0.5",
            Tooltip =
            "Input delay for these pets. Press Enter to see",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if num and num > 0 then
                    FSettings.overridepets.delay_amount = num
                    SaveData()
                    input_overridepets_delay_am:SetText(GetTextDelayamountx())
                else
                    Library:Notify("Invalid " .. Value, 3)
                    input_overridepets_delay_am:SetValue(tostring(FSettings.overridepets.delay_amount))
                end
            end
        })


        PetOverridesGroup:AddToggle("togglepetdelay", {
            Text = "ðŸ¤– Enable Pet Delay",
            Default = FSettings.overridepets.is_enabled,
            Tooltip = "When enabled, Selected pets will be placed with a delay.",
            Callback = function(Value)
                FSettings.overridepets.is_enabled = Value
                SaveData()
            end
        })


        PetOverridesGroup:AddSpacer(200)
    end

    -- Pet Overrides ends


    --=========== Auto Rejoin
    AutojoinGroup:AddLabel({
        Text = "âš ï¸ Auto rejoin after set options.",
        DoesWrap = true
    })

    local function UpdateRejoinCount()
        local ud = tonumber(FSettings.auto_rejoin_after_hatchcount)
        return string.format(
            "âœ¨ <font color='#FFFFFF'><b>Rejoin Hatch Count</b></font><stroke color='#6B5E0A' th='2' tr='0.5' joins='round' sizing='fixed'><font color='#E7E734'><b> %s</b></font></stroke>",
            ud
        )
    end

    local input_hatchcount
    input_hatchcount = AutojoinGroup:AddInput("input_hatchcount", {
        Text = UpdateRejoinCount(),
        Default = FSettings.auto_rejoin_after_hatchcount,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "e.g. 4",
        Tooltip =
        "Enter when the system should rejoin server. When hatch count meets this requirement the game will try to rejoin.",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)

            if num and num >= 1 then
                FSettings.auto_rejoin_after_hatchcount = num
                SaveData()
                input_hatchcount:SetText(UpdateRejoinCount())
            else
                --Library:Notify("Invalid ".. Value, 3)
                input_hatchcount:SetValue(tostring(FSettings.auto_rejoin_after_hatchcount))
            end
        end
    })


    AutojoinGroup:AddToggle("toggleAutoREjoin", {
        Text = "ðŸ”„ Enable Auto Rejoin",
        Default = FSettings.auto_restartjoin_server,
        Tooltip = "When enabled, it will rejoin following the settings set.",
        Callback = function(Value)
            if Value then
                Varz.rejoin_hatch_count = 0 -- reset the delay so it starts from beginning
            end
            FSettings.auto_restartjoin_server = Value
            SaveData()
        end
    })







    -- #options
    --=========== Options ========-----




    OptionsGroup:AddDivider()
    -- Always capture the reference returned by AddToggle
    OptionsGroup:AddLabel({
        Text =
        "âš ï¸ Speeds up timers by over 90%. Use with caution, System stability is not guaranteed. Use at your own risk. âš ï¸",
        DoesWrap = true
    })
    local toggleExtremeMode = OptionsGroup:AddToggle("toggleExtremeMode", {
        Text = "<b><stroke color='#000000' thickness='2'><font color='#FF6A00'>ðŸ”¥ OVERDRIVE MODE ðŸ”¥</font></stroke></b>",
        Default = FSettings.hatch_fast_mode,
        Tooltip =
        "Pushes the system to its limits for a <b><font color='#FFFF00'>90% hatch speed boost!</font></b><br/><br/><i><font color='#FF0000'><b>âš ï¸ WARNING:</b> System stability is not guaranteed. Use at your own risk.</font></i>",
        Callback = function(Value)
            FSettings.hatch_fast_mode = Value
            SaveData()
        end
    })

    OptionsGroup:AddDivider()
    OptionsGroup:AddToggle("toggleslowMode", {
        Text = "<b><stroke color='#000000' thickness='2'><font color='#F40FFF'>â†”ï¸ SLOW MODE</font></stroke></b>",
        Default = FSettings.hatch_slow_mode,
        Tooltip =
        "Slow mode for hatching.",
        Callback = function(Value)
            FSettings.hatch_slow_mode = Value
            SaveData()
        end
    })

    OptionsGroup:AddDivider()
    -- Only sell when max inventory
    local togglesellmaxinv = OptionsGroup:AddToggle("togglesellmaxinv", {
        Text = "ðŸš¨ Max Inventory Sell",
        Default = FSettings.hatch_sell_delayed,
        Tooltip =
        "Only sells if you are going to exceed inventory limit for next hatch. Has no effect if [Only Sell Hatched Pets ðŸ›¡ï¸] is enabled.",
        Callback = function(Value)
            FSettings.hatch_sell_delayed = Value
            SaveData()
        end
    })

    OptionsGroup:AddDivider()
    -- Always capture the reference returned by AddToggle
    local MyToggle1 = OptionsGroup:AddToggle("toverridebackpack", {
        Text = "Only Sell Hatched Pets ðŸ›¡ï¸",
        Default = FSettings.is_sell_only_hatch_pet,
        Tooltip = "Enable this to only sell hatched pets; all other backpack pets will be auto-favourited.",
        Callback = function(Value)
            FSettings.is_sell_only_hatch_pet = Value
            SaveData()
        end
    })

    OptionsGroup:AddDivider()

    local tooglegm = OptionsGroup:AddToggle("tooglegm", {
        Text = "ðŸš¿ Grandmaster Sprinkler",
        Default = FOtherSettings.is_auto_place_sprinkler_hatch,
        Tooltip = "Global: Auto places Grandmaster Sprinkler if you don't have one on the farm.",
        Callback = function(Value)
            FOtherSettings.is_auto_place_sprinkler_hatch = Value
            SaveDataOther()
        end
    })

    OptionsGroup:AddDivider()

    local togHatchReport = OptionsGroup:AddToggle("toggleBatchHatch", {
        Text = "Batch Hatching",
        Default = FSettings.is_hatch_in_batch,
        Tooltip = "Hatch all the eggs together when they are ready.",
        Callback = function(Value)
            FSettings.is_hatch_in_batch = Value
            SaveData()
            Library:Notify("Updated", 3)
        end
    })

    OptionsGroup:AddDivider()
    -- Egg Esp
    local toggleEggView = OptionsGroup:AddToggle("toggleEggView", {
        Text = "Egg Esp",
        Default = FSettings.is_egg_esp,
        Tooltip = "Show/Hide Egg Info",
        Callback = function(Value)
            FSettings.is_egg_esp = Value
            SaveData()
            Library:Notify("Updated", 3)
        end
    })


    OptionsGroup:AddDivider()
    -- Egg Esp
    OptionsGroup:AddToggle("toggleAlwaysActive", {
        Text = "ðŸš€ Always Active Boosts",
        Default = FSettings.always_active_boosts,
        Tooltip = "If enabled, hatching and mutation try to apply boosts every 10s",
        Callback = function(Value)
            FSettings.always_active_boosts = Value
            SaveData()
        end
    })

    OptionsGroup:AddDivider()
    -- reload pet teams
    local ButtonReloadPetTeam = OptionsGroup:AddButton({
        Text = "â™»ï¸ Reload Pet Team",
        Func = function()
            UpdatePetData()
            Library:Notify("Reloaded Pets", 1)
        end
    })




    ------------ END Options -----------




    GroupBoxEggReductionTeam:AddLabel({
        Text =
        "â­ Speeds up egg timer. Pets: <font color='#FFD700'>Mimics</font>, <font color='#00CED1'>Peacock</font>, <font color='#A52A2A'>Bald Eagles</font>",
        DoesWrap = true
    })

    GroupBoxSellingTeam:AddLabel({
        Text = "â­ Placed before selling. Pets: <font color='#1E90FF'>Seal</font> max 50%",
        DoesWrap = true
    })

    GroupBoxHatchingTeam:AddLabel({
        Text = "â­ Placed before hatching eggs. Pets: <font color='#FF4500'>Koi</font> max 50%",
        DoesWrap = true
    })

    GroupBoxEggPetSizeTeam:AddLabel({
        Text = "â­ For bigger pet hatch. Pets: <font color='#32CD32'>Brontosaurus</font> max 30%",
        DoesWrap = true
    })

    UI_LABELS.lbl_selected_team1_count = GroupBoxSellingTeam:AddLabel("-")
    UI_LABELS.lbl_selected_team2_count = GroupBoxHatchingTeam:AddLabel("-")
    UI_LABELS.lbl_selected_team3_count = GroupBoxEggReductionTeam:AddLabel("-")
    UI_LABELS.lbl_selected_team4_count = GroupBoxEggPetSizeTeam:AddLabel("-")

    UpdateUITeamCount()

    -- Team 1 , selling team
    --- print("pets: ", _S.HttpService:JSONEncode(petCache));
    UI_LABELS.MultiDropdownSellTeam = GroupBoxSellingTeam:AddDropdown("dropdownSellTeam", {
        Values = GetPetsCacheAsTable(),
        Default = {}, -- Default selected values for multi-select
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ’° Sell Team",
        Callback = function(Values)
            local tmp_tbl = {}
            for Value, Selected in pairs(Values) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(tmp_tbl, _uuid)
                    end
                end
                -- loop ends
            end

            local count_vals = #tmp_tbl
            if count_vals > GetMaxPetCapacity() then
                Library:Notify("Team size maxed", 2)
            else
                FSettings.team1 = tmp_tbl
                SaveData()
                UpdateUITeamCount()
                Library:Notify("Sell Team Updated", 2)
            end
        end
    })



    GroupBoxSellingTeam:AddDivider()

    local ButtonPalceTeam1 = GroupBoxSellingTeam:AddButton({
        Text = "Equip",
        Func = function()
            if #FSettings.team1 == 0 then
                Library:Notify("Team is empty", 2)
            else
                EquipPets(FSettings.team1)
            end
        end
    })

    -- Unequip
    ButtonPalceTeam1:AddButton({
        Text = "<font color='#FF0000'>UnEquip</font>",
        Func = function()
            UnEquipAllPets()
        end
    })

    -- Reload
    ButtonPalceTeam1:AddButton({
        Text = "<font color='#00FF04'>Reload</font>",
        Func = function()
            UpdatePetData()
            task.wait(0.3)
        end
    })



    -- Boosts for this team
    local _ddBoostTeam1 = GroupBoxSellingTeam:AddDropdown("_ddBoostTeam1", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 6,
        Text = "ðŸ’Š Pet Boosts",
        Tooltip = "Boosts are applied when team is placed by the system.",
        Callback = function(Values)
            FSettings.hatch_boost_seal_team = {}
            for key, value in pairs(Values) do
                FSettings.hatch_boost_seal_team[key] = value
            end

            SaveData()
        end
    })


    _ddBoostTeam1:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
    _ddBoostTeam1:SetValue(FSettings.hatch_boost_seal_team)

    GroupBoxSellingTeam:AddToggle("enable_ddBoostTeam1", {
        Text = "ðŸš€ Enable Boosts",
        Default = FSettings.hatch_boost_seal_enabled,
        Tooltip = "If enabled boosts will be applied when team is placed.",
        Callback = function(Value)
            FSettings.hatch_boost_seal_enabled = Value
            SaveData()
        end
    })



    GroupBoxSellingTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })
    local ToggleTeam1Disable = GroupBoxSellingTeam:AddToggle("ToggleTeam1Disable", {
        Text = "â›” Don't use",
        Default = FSettings.disable_team1,
        Tooltip = "If enabled, this team will <font color='#FF00FF'>NOT</font> be used.",
        Callback = function(Value)
            if Value then
                FSettings.disable_team1 = Value
                SaveData()
                Library:Notify("Team Disabled", 2)
            else
                FSettings.disable_team1 = Value
                SaveData()
                Library:Notify("Team Enabled", 2)
            end
        end
    })
    GroupBoxSellingTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })

    GroupBoxSellingTeam:AddSpacer(30)

    --============================  TEAM 1 END


    -- Team 2, hatching team
    UI_LABELS.MultiDropdownHatchTeam = GroupBoxHatchingTeam:AddDropdown("dropdownHatchTeam", {
        Values = GetPetsCacheAsTable(),
        Default = {}, -- Default selected values for multi-select
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ£ Hatch Team",
        Callback = function(Values)
            local tmp_tbl = {}
            for Value, Selected in pairs(Values) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(tmp_tbl, _uuid)
                    end
                end
                -- loop ends
            end

            local count_vals = #tmp_tbl
            if count_vals > GetMaxPetCapacity() then
                Library:Notify("Team size maxed", 2)
            else
                warn("Saved Team 2 called")

                FSettings.team2 = tmp_tbl
                SaveData()
                UpdateUITeamCount()
                Library:Notify("Hatch Team Updated", 2)
            end
        end
    })

    GroupBoxHatchingTeam:AddDivider()

    local ButtonHatchTeam1 = GroupBoxHatchingTeam:AddButton({
        Text = "Equip",
        Func = function()
            if #FSettings.team2 == 0 then
                Library:Notify("Team is empty", 2)
            else
                EquipPets(FSettings.team2)
            end
        end
    })

    -- Unequip
    ButtonHatchTeam1:AddButton({
        Text = "<font color='#FF0000'>UnEquip</font>",
        Func = function()
            UnEquipAllPets()
        end
    })

    -- Reload
    ButtonHatchTeam1:AddButton({
        Text = "<font color='#00FF04'>Reload</font>",
        Func = function()
            UpdatePetData()
            task.wait(0.3)
        end
    })




    GroupBoxHatchingTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })
    local ToggleTeam2Disable = GroupBoxHatchingTeam:AddToggle("ToggleTeam2Disable", {
        Text = "â›” Don't use",
        Default = FSettings.disable_team2,
        Tooltip = "If enabled, this team will <font color='#FF00FF'>NOT</font> be used.",
        Callback = function(Value)
            if Value then
                FSettings.disable_team2 = Value
                SaveData()
                Library:Notify("Team Disabled", 2)
            else
                FSettings.disable_team2 = Value
                SaveData()
                Library:Notify("Team Enabled", 2)
            end
        end
    })
    GroupBoxHatchingTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })
    -- Boosts for this team
    local dropdownBoostKoi = GroupBoxHatchingTeam:AddDropdown("dropdownHatchTeamBoosts", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 6,
        Text = "ðŸ’Š Pet Boosts",
        Tooltip = "Boosts are applied when team is placed by the auto hatching system.",
        Callback = function(Values)
            FOtherSettings.boost_koi_team_list = {}
            for key, value in pairs(Values) do
                FOtherSettings.boost_koi_team_list[key] = value
            end

            SaveDataOther()
        end
    })

    dropdownBoostKoi:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
    dropdownBoostKoi:SetValue(FOtherSettings.boost_koi_team_list)

    GroupBoxHatchingTeam:AddDivider();

    -- Unequip
    GroupBoxHatchingTeam:AddButton({
        Text = "âš¡ Apply Now [Active Pets]",
        Func = function()
            local active_pets = FarmManager:GetActivePetsUUIDS()
            if active_pets then
                MonsterBoostManager.ApplyBoostHeldKoi()
            end
        end
    })

    GroupBoxHatchingTeam:AddToggle("ToggleTeam2Boost", {
        Text = "â™»ï¸ Auto Boost [Placed]",
        Default = FOtherSettings.boost_auto_team_placed_koi,
        Tooltip = "Applies boosts when this team is placed by the hatching system.",
        Callback = function(Value)
            FOtherSettings.boost_auto_team_placed_koi = Value
            SaveDataOther()
        end
    })

    GroupBoxHatchingTeam:AddToggle("ToggleTeam2BoostGrandmaster", {
        Text = "ðŸ”« Grandmaster Sprinkler [Place]",
        Default = FOtherSettings.boost_sprinkler_koi_team,
        Tooltip = "If enabled then it places a Grandmaster Sprinkler if farm has none.",
        Callback = function(Value)
            FOtherSettings.boost_sprinkler_koi_team = Value
            SaveDataOther()
        end
    })




    GroupBoxHatchingTeam:AddSpacer(30)

    -- End Koi team

















    -- =================== TEAM 3 - Egg Time Reduction Team
    -- #hatch

    --- Texts

    -- Team 3, egg time reduction team
    UI_LABELS.MultiDropdownEggReductionTeam = GroupBoxEggReductionTeam:AddDropdown("dropdownEggReductionTeam", {
        Values = GetPetsCacheAsTable(),
        Default = {}, -- Default selected values for multi-select
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ£â³ Egg Reduction Team",
        Callback = function(Values)
            local tmp_tbl = {}
            for Value, Selected in pairs(Values) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(tmp_tbl, _uuid)
                    end
                end
                -- loop ends
            end

            local count_vals = #tmp_tbl
            if count_vals > GetMaxPetCapacity() then
                Library:Notify("Team size maxed", 2)
            else
                --warn("Saved Team 3 called", _S.HttpService:JSONEncode(Values))

                FSettings.team3 = tmp_tbl
                SaveData()
                UpdateUITeamCount()
                Library:Notify("Egg Reduction Team Updated", 2)
            end
        end
    })

    GroupBoxEggReductionTeam:AddDivider()

    local ButtonEqiupTeam3 = GroupBoxEggReductionTeam:AddButton({
        Text = "Equip",
        Func = function()
            if #FSettings.team3 == 0 then
                Library:Notify("Team is empty", 2)
            else
                EquipPets(FSettings.team3)
            end
        end
    })

    -- Unequip
    ButtonEqiupTeam3:AddButton({
        Text = "<font color='#FF0000'>UnEquip</font>",
        Func = function()
            UnEquipAllPets()
        end
    })

    -- Reload
    ButtonEqiupTeam3:AddButton({
        Text = "<font color='#00FF04'>Reload</font>",
        Func = function()
            UpdatePetData()
            task.wait(0.3)
        end
    })



    -- Boosts for this team
    local _ddBoostTeam3 = GroupBoxEggReductionTeam:AddDropdown("_ddBoostTeam3", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 6,
        Text = "ðŸ’Š Pet Boosts",
        Tooltip = "Boosts are applied when team is placed by the system.",
        Callback = function(Values)
            FSettings.hatch_boost_eggcd_team = {}
            for key, value in pairs(Values) do
                FSettings.hatch_boost_eggcd_team[key] = value
            end

            SaveData()
        end
    })


    _ddBoostTeam3:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
    _ddBoostTeam3:SetValue(FSettings.hatch_boost_eggcd_team)


    local hatchteamTargetBoost = GroupBoxEggReductionTeam:AddDropdown("hatchteamTargetBoost", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ¤– Boost Selected Pets",
        Tooltip = "Select pets to target, if nothing is selected then it applies to all active pets",
        Callback = function(Values)
            if Values == nil then
                return
            end
            FSettings.hatch_team_boost_targets = Values
            SaveData()
        end
    })

    hatchteamTargetBoost:SetValues(Varz.all_pets_names_list)
    hatchteamTargetBoost:SetValue(FSettings.hatch_team_boost_targets)

    GroupBoxEggReductionTeam:AddToggle("enable_ddBoostTeam3", {
        Text = "ðŸš€ Enable Boosts",
        Default = FSettings.hatch_boost_eggcd_enabled,
        Tooltip = "If enabled boosts will be applied when team is placed.",
        Callback = function(Value)
            FSettings.hatch_boost_eggcd_enabled = Value
            SaveData()
        end
    })

    GroupBoxEggReductionTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })
    local ToggleTeam3Disable = GroupBoxEggReductionTeam:AddToggle("ToggleTeam3Disable", {
        Text = "â›” Don't use",
        Default = FSettings.disable_team3,
        Tooltip = "If enabled, this team will <font color='#FF00FF'>NOT</font> be used.",
        Callback = function(Value)
            if Value then
                FSettings.disable_team3 = Value
                SaveData()
                Library:Notify("Team Disabled", 2)
            else
                FSettings.disable_team3 = Value
                SaveData()
                Library:Notify("Team Enabled", 2)
            end
        end
    })

    GroupBoxEggReductionTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })



    --======== Advanced options

    local advanced_reduction_options = Varz.GetCheckIfPro()

    GroupBoxEggReductionTeam:AddLabel({
        Text =
        "<font color='#ffd700'><b>â” PREMIUM OPTIONS â”</b></font>",
        DoesWrap = true
    })

    if not advanced_reduction_options then
        local msgp = Varz.GetProMessage()
        GroupBoxEggReductionTeam:AddLabel({
            Text =
                msgp,
            DoesWrap = true
        })
    end


    if advanced_reduction_options then
        GroupBoxEggReductionTeam:AddLabel({
            Text =
                "<font color='#ffcc00'>âš ï¸ How it works</font>\n" ..
                "<font color='#ffffff'>â€¢ Pick pets for your main team and keep empty slots for the extra teams.\n" ..
                "â€¢ Feature will not run if your main team is full or extra teams are empty.\n" ..
                "â€¢ When enabled, hatching can use multiple teams.\n" ..
                "â€¢ Extra teams fill missing pets; the first team is swapped out after a short delay.\n\n" ..
                "<font color='#a0ffb0'>Best combo:</font> Mimics + Spider for webs â†’ auto-switch to Bald Eagle for faster hatching.</font>",
            DoesWrap = true
        })

        -- texts

        local GetText_TeamsTextFirst = function()
            local current_selected = #FSettings.team_reduction_placefirst
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#FF00B7"><b>ðŸ¤– Place First</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )
            return txt
        end

        local GetText_TeamsTextLast = function()
            local current_selected = #FSettings.team_reduction_placeafter
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#00FF3C"><b>ðŸŸ¢ Place After</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )
            return txt
        end


        --- =========== Team First
        UI_Dropdown.dd_reduction_teamfirst = GroupBoxEggReductionTeam:AddDropdown("dd_reduction_teamfirst", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_TeamsTextFirst(),
            Tooltip = "Select pets to place along side main team.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}

                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end


                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dd_reduction_teamfirst:SetValue(ConvertUUIDToPetNamesPairs(FSettings
                        .team_reduction_placefirst))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.team_reduction_placefirst = tmp_tbl
                    SaveData()
                    UI_Dropdown.dd_reduction_teamfirst:SetText(GetText_TeamsTextFirst())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })


        --- =========== Team After
        UI_Dropdown.dd_reduction_teamafter = GroupBoxEggReductionTeam:AddDropdown("dd_reduction_teamafter", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_TeamsTextLast(),
            Tooltip = "Select pets to be placed after.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}

                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end


                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dd_reduction_teamafter:SetValue(ConvertUUIDToPetNamesPairs(FSettings
                        .team_reduction_placeafter))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.team_reduction_placeafter = tmp_tbl
                    SaveData()
                    UI_Dropdown.dd_reduction_teamafter:SetText(GetText_TeamsTextLast())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })



        GroupBoxEggReductionTeam:AddDivider()

        local function GetTextDelayPhaseTeams()
            local level = FSettings.team_reduction_timer or 16.5
            local str = string.format(
                "<b><font color='#7327F5'>â³ Timer</font></b><font color='#00FFFF'>%s</font>/s", level)
            return str
        end

        local input_timerdelay_phases
        input_timerdelay_phases = GroupBoxEggReductionTeam:AddInput("input_timerdelay_phases", {
            Text = GetTextDelayPhaseTeams(),
            Default = FSettings.team_reduction_timer,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 16",
            Tooltip = "Enter delay, must be more than 0",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Timer: " .. Value, 3)
                    input_timerdelay_phases:SetValue(tostring(FSettings.team_reduction_timer))
                    return
                end

                if num > 0 then
                    FSettings.team_reduction_timer = num
                    SaveData()
                    input_timerdelay_phases:SetText(GetTextDelayPhaseTeams())
                end
            end
        })
        GroupBoxEggReductionTeam:AddDivider()

        GroupBoxEggReductionTeam:AddToggle("hatchingreductionteamsg", {
            Text = "â™»ï¸ Enable Teams",
            Default = FSettings.team_reduction_enabled_teams,
            Tooltip = "When enabled, this will work with main egg reduction team to place pets.",
            Callback = function(Value)
                FSettings.team_reduction_enabled_teams = Value
                SaveData()
            end
        })
    end





    GroupBoxEggReductionTeam:AddSpacer(100)
    -- End Egg reduction team








    -- ===================== BIG PET TEAM
    -- Team 4 , pet size team
    UI_LABELS.MultiDropdownEggPetSizeTeam = GroupBoxEggPetSizeTeam:AddDropdown("dropdownSellTeam", {
        Values = GetPetsCacheAsTable(),
        Default = {}, -- Default selected values for multi-select
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ² PetSize Team Selection",
        Callback = function(Values)
            local tmp_tbl = {}
            for Value, Selected in pairs(Values) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(tmp_tbl, _uuid)
                    end
                end
                -- loop ends
            end

            local count_vals = #tmp_tbl
            if count_vals > GetMaxPetCapacity() then
                Library:Notify("Team size maxed", 2)
            else
                FSettings.team4 = tmp_tbl
                SaveData()
                UpdateUITeamCount()
                Library:Notify("PetSize Team Updated", 2)
            end
        end
    })


    GroupBoxEggPetSizeTeam:AddDivider()

    local ButtonPalceTeam1 = GroupBoxEggPetSizeTeam:AddButton({
        Text = "Equip",
        Func = function()
            if #FSettings.team4 == 0 then
                Library:Notify("Team is empty", 2)
            else
                EquipPets(FSettings.team4)
            end
        end
    })

    -- Unequip
    ButtonPalceTeam1:AddButton({
        Text = "<font color='#FF0000'>UnEquip</font>",
        Func = function()
            UnEquipAllPets()
        end
    })


    -- Reload
    ButtonPalceTeam1:AddButton({
        Text = "<font color='#00FF04'>Reload</font>",
        Func = function()
            UpdatePetData()
            task.wait(0.3)
        end
    })



    -- Boosts for this team
    local _ddBoostTeam4 = GroupBoxEggPetSizeTeam:AddDropdown("_ddBoostTeam4", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 6,
        Text = "ðŸ’Š Pet Boosts",
        Tooltip = "Boosts are applied when team is placed by the system.",
        Callback = function(Values)
            FSettings.hatch_boost_bron_team = {}
            for key, value in pairs(Values) do
                FSettings.hatch_boost_bron_team[key] = value
            end

            SaveData()
        end
    })


    _ddBoostTeam4:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
    _ddBoostTeam4:SetValue(FSettings.hatch_boost_bron_team)

    GroupBoxEggPetSizeTeam:AddToggle("enable_ddBoostTeam4", {
        Text = "ðŸš€ Enable Boosts",
        Default = FSettings.hatch_boost_bron_enabled,
        Tooltip = "If enabled boosts will be applied when team is placed.",
        Callback = function(Value)
            FSettings.hatch_boost_bron_enabled = Value
            SaveData()
        end
    })


    GroupBoxEggPetSizeTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })

    local ToggleTeam4Disable = GroupBoxEggPetSizeTeam:AddToggle("ToggleTeam4Disable", {
        Text = "â›” Don't use",
        Default = FSettings.disable_team4,
        Tooltip = "If enabled, this team will <font color='#FF00FF'>NOT</font> be used.",
        Callback = function(Value)
            FSettings.disable_team4 = Value
            if Value then
                SaveData()
                Library:Notify("Team Disabled", 2)
            else
                SaveData()
                Library:Notify("Team Enabled", 2)
            end
        end
    })
    GroupBoxEggPetSizeTeam:AddLabel({
        Text = "<font color='#FF0000'>------------------------------</font>",
        DoesWrap = false
    })
    -- override, prevent hatching of big pets.

    GroupBoxEggPetSizeTeam:AddToggle("ToggleTeam4Prevent", {
        Text = "âš ï¸ Allow Big Pet Hatch?",
        Default = FSettings.auto_hatch_big_pets,
        Tooltip = "Disable to keep big pets in the egg and never hatch them. Can be used for manual hatching.",
        Callback = function(Value)
            FSettings.auto_hatch_big_pets = Value
            if Value then
                SaveData()
                Library:Notify("Auto Hatch Big Pet Enabled", 2)
            else
                SaveData()
                Library:Notify("Auto Hatch Big Pet Disabled", 2)
            end
        end
    })

    GroupBoxEggPetSizeTeam:AddToggle("ToggleTeam4RareHatch", {
        Text = "ðŸ’Ž Hatch Rare/Excluded Sell List",
        Default = FOtherSettings.hatch_rare_withbigsizetm,
        Tooltip = "Enable this to hatch pets that are rare and not included in your sell list.",
        Callback = function(Value)
            FOtherSettings.hatch_rare_withbigsizetm = Value
            if Value then
                Library:Notify("Enabled", 2)
            else
                Library:Notify("Disabled", 2)
            end

            SaveDataOther()
        end
    })

    GroupBoxEggPetSizeTeam:AddSpacer(30)

    --============================  TEAM 4 END




    -- reset it and update and visuals
end

-- call it
Varz.PetTeamsUi()




-- End of Pets Team ==========================================================================


-- Egg Priority
local function MEggUi()
    -- Create the new "Eggs" Tab
    local max_order = 100
    local UIEggTab = Window:AddTab({
        Name = "Eggs Priority",
        Description = "Manage Egg hatching priority",
        Icon = "egg"
    })

    -- Create a groupbox to hold the egg settings
    local GroupBoxEggs = UIEggTab:AddLeftGroupbox("Egg Priority & Settings", "list-ordered")
    local eggSettingsGroup = UIEggTab:AddRightGroupbox("Egg Options", "egg")

    ---====== Egg settings
    eggSettingsGroup:AddLabel({
        Text = "â„¹ï¸ Max eggs to place, Put 0 to disable. Press Enter to save",
        DoesWrap = true
    })


    local function UpdateEggCount()
        local ud = tonumber(FOtherSettings.max_eggs_to_place)

        local str = "x" .. ud
        if ud == 0 then
            str = "MAX!";
        end

        return string.format(
            "âœ¨ <font color='#FFFFFF'><b>Max Eggs</b></font><stroke color='#6B5E0A' th='2' tr='0.5' joins='round' sizing='scaled'><font color='#E7E734'><b> %s</b></font></stroke>",
            str
        )
    end

    local input_egg_limit
    input_egg_limit = eggSettingsGroup:AddInput("input_egg_limit", {
        Text = UpdateEggCount(),
        Default = FOtherSettings.max_eggs_to_place,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "e.g. 4",
        Tooltip = "Enter 0 to turn this off.",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)

            if num and num >= 0 then
                FOtherSettings.max_eggs_to_place = num
                SaveDataOther()
                input_egg_limit:SetText(UpdateEggCount())
            else
                --Library:Notify("Invalid ".. Value, 3)
                input_egg_limit:SetValue(tostring(FOtherSettings.max_eggs_to_place))
            end
        end
    })




    -- Add an informational label
    GroupBoxEggs:AddLabel({
        Text = "Enable or disable eggs and set their hatching priority. higher numbers are higher priority.",
        DoesWrap = true
    })
    GroupBoxEggs:AddDivider()

    -- 1. Create a temporary table to sort the eggs by their order for display
    local sortedEggs = {}
    -- Reference the array from FSettings now
    for name, data in pairs(FSettings.eggs_to_place_array) do
        table.insert(sortedEggs, { name = name, order = data.order })
    end

    table.sort(sortedEggs, function(a, b)
        return a.order > b.order
    end)

    -- 2. Loop through the sorted table to create the UI elements in order
    for _, eggInfo in ipairs(sortedEggs) do
        local eggName = eggInfo.name
        -- Get the initial data from the FSettings table
        local eggData = FSettings.eggs_to_place_array[eggName]

        -- Create a Toggle for enabling/disabling the egg and store it in a variable
        local eggToggle = GroupBoxEggs:AddToggle(eggName .. "_toggle", {
            Text = eggName,
            Default = eggData.enabled,
            Tooltip = "Enable/Disable hatching for " .. eggName,
            Callback = function(Value)
                -- Update the value directly in the FSettings table
                FSettings.eggs_to_place_array[eggName].enabled = Value
                SaveData() -- Save the settings
                Library:Notify(eggName .. (Value and " Enabled" or " Disabled"), 1)
            end
        })

        --[[
            NEW CHANGE: Check for and apply the custom color
        ]]
        if eggData.color then
            eggToggle.TextLabel.TextColor3 = eggData.color
        end

        -- Create a Slider to set the priority order
        GroupBoxEggs:AddSlider(eggName .. "_slider", {
            Text = "Priority Order [Higher = First]",
            Default = eggData.order,
            Min = 1,
            Max = max_order, -- Max priority is the total number of eggs
            Rounding = 0,    -- Use whole numbers for priority
            Callback = function(Value)
                -- Update the value directly in the FSettings table
                FSettings.eggs_to_place_array[eggName].order = Value
                SaveData() -- Save the settings
                --Library:Notify(eggName .. " priority set to " .. Value, 1)
            end
        })

        GroupBoxEggs:AddDivider()
    end
end


-- Call the new function to create the UI
MEggUi()



-- ===========================================================================================
-- Pet Sell Settings UI
local function PetSellSettingsUi()
    local SellTab = Window:AddTab({
        Name = "Pet Sell Settings",
        Description = "Configure pet selling",
        Icon = "coins"
    })

    local GroupBoxSell = SellTab:AddLeftGroupbox("Pet Sell List", "gavel")
    local GroupBoxSellWeight = SellTab:AddRightGroupbox("Pet Sell Weight", "weight")



    GroupBoxSellWeight:AddLabel({
        Text =
        "<font color='#FFD700'><b>âš–ï¸ Global Default Pet Weight</b></font>\n Any pet with a weight greater than this will be marked as <font color='#00FF7F'><b>Big </b></font> and automatically set as a <font color='#1E90FF'><b>Favourite â­</b></font>.\nðŸ“¦ This rule applies to all pets in your backpack that are not already favourited.\nâœ¨ Make sure to <font color='#FF69B4'><b>favourite your pets</b></font> before starting the <font color='#FFA500'><b>Hatching System</b></font>.\n <font color='#FF4500'><b>âš ï¸ If you override any petâ€™s weight, this rule will be ignored.</b></font>"
        ,
        DoesWrap = true
    })

    GroupBoxSellWeight:AddDivider()

    local max_default_text = "âš–ï¸ <font color='#00B200'>Keep</font> Pets Above Weight [KG]"
    local InputMax
    InputMax = GroupBoxSellWeight:AddInput("sellpetaboveweight", {
        Text = max_default_text,
        Default = FSettings.sell_weight,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Tooltip = "Pets with size bigger or equal to this weight are considered big, huge etc",
        Placeholder = "Global default weight",
        Callback = function(Value)
            local num = ParseWeightNumber(Value)

            if not num then
                Library:Notify("Invalid number : " .. Value, 3)
                InputMax:SetValue(tostring(FSettings.sell_weight))
                return
            end

            if num <= 0 then
                Library:Notify("Enter value more than 0", 3)
                InputMax:SetValue(tostring(FSettings.sell_weight))
                return
            end

            FSettings.sell_weight = num
            SaveData()

            InputMax:SetText("âœ… <font color='#00FF00'>Pets Weight Updated</font>")
            task.wait(1.5)
            InputMax:SetText(max_default_text)
        end
    })


    GroupBoxSell:AddLabel({
        Text =
        "ðŸ”€ <font color='#00FF7F'><b>Toggle ON</b></font> to <font color='#FF4500'><b>auto-sell</b></font> a pet.\nðŸ”• <font color='#1E90FF'><b>Toggle OFF</b></font> to keep it.",
        DoesWrap = true
    })

    GroupBoxSell:AddDivider()

    local sortedEggNames = {}
    for eggName, _ in pairs(FSettings.sell_pets) do
        table.insert(sortedEggNames, eggName)
    end
    table.sort(sortedEggNames)

    for _, eggName in ipairs(sortedEggNames) do
        local petList = FSettings.sell_pets[eggName]

        GroupBoxSell:AddLabel({ Text = "<font color='#00B200'>ã€â– ðŸ¥š <b>" .. eggName .. "</b> â–ã€‘</font>", DoesWrap = false })

        local sortedPetNames = {}
        for petName, _ in pairs(petList) do
            table.insert(sortedPetNames, petName)
        end
        table.sort(sortedPetNames)

        for _, petName in ipairs(sortedPetNames) do
            -- This is the main toggle to enable or disable selling for the pet.
            local pet_n = GroupBoxSell:AddToggle(petName, {
                Text = petName,
                Default = petList[petName], -- Get current setting
                Callback = function(Value)
                    FSettings.sell_pets[eggName][petName] = Value
                    SaveData()
                    Library:Notify("Updated " .. petName, 3)
                end
            })

            -------------------------------------------------
            local override_enabled = false
            local override_weight = FSettings.sell_weight
            local is_big_pet = false
            -------------------------------------------------


            -------------------------------------------------
            -- NEW: Get or create the override settings for this pet
            if not FOtherSettings.pet_override_weight[petName] then
                FOtherSettings.pet_override_weight[petName] = {
                    override = override_enabled,
                    weight = override_weight,
                    is_big = is_big_pet,
                }
            end
            local petOverrideData = FOtherSettings.pet_override_weight[petName]

            -- add any missing data | important
            if not petOverrideData.is_big then
                petOverrideData.is_big = is_big_pet
            end

            -------------------------------------------------


            local depoverridebox = GroupBoxSell:AddDependencyBox()
            depoverridebox:SetupDependencies({
                { pet_n, true } -- Shows when the overrideToggle above is ON
            })
            --[[ 2. NEW: The "Override weight" checkbox for this pet ]]

            local overrideToggle = depoverridebox:AddCheckbox(petName .. "_override", {
                Text = " âš–ï¸ Override Weight ",
                Default = petOverrideData.override,
                Tooltip = "Override global default weight for " .. petName,
                Callback = function(Value)
                    -- This is where you would save the override_enabled state
                    petOverrideData.override = Value
                    SaveDataOther();
                end
            })

            --[[ 3. NEW: The dependency box linked to the override checkbox ]]
            local depBox = GroupBoxSell:AddDependencyBox()
            depBox:SetupDependencies({
                { pet_n,          true },
                { overrideToggle, true }
            })

            --[[ 4. NEW: The weight input that appears when the box is checked ]]
            local weightInput
            weightInput = depBox:AddInput(petName .. "_weight_input", {
                Text = "  â”” Keep Weight <font color='#FF00FF'>Above</font> [KG]",
                Default = tostring(petOverrideData.weight),
                Placeholder = "e.g., 1.25",
                Finished = true,
                Numeric = false,
                ClearTextOnFocus = false,
                AllowEmpty = true,
                Tooltip = petName .. " will not be sold if over this weight! Max 2.20 KG",

                Callback = function(Value)
                    local num = ParseWeightNumber(Value)
                    local was_corrected = false
                    if num then
                        local limit_zi = 20
                        if num > limit_zi then
                            -- Library:Notify("Max weight is 2.199 KG, try again.", 3)
                            -- return
                            num = limit_zi
                            was_corrected = true
                        end
                    end


                    if num and num > 0 then
                        -- This is where you would save the override_weight
                        if petOverrideData.weight == num and was_corrected == false then
                            return
                        end
                        petOverrideData.weight = num
                        SaveDataOther();
                        Library:Notify(petName .. " Weight Override " .. num .. " KG", 2)
                        weightInput:SetValue(tostring(petOverrideData.weight))
                    else
                        Library:Notify("Invalid weight for " .. petName, 3)
                        weightInput:SetValue(tostring(petOverrideData.weight))
                    end
                end
            })


            local overrideBigPet = depBox:AddCheckbox(petName .. "_bigoverride", {
                Text = "ðŸ’ª Mark Big Pet ",
                Default = petOverrideData.is_big,
                Tooltip = "When enabled, " .. petName .. " will hatch with the Big Pets team. If big pets team is set.",
                Callback = function(Value)
                    -- This is where you would save the override_enabled state
                    petOverrideData.is_big = Value
                    SaveDataOther();
                end
            })

            GroupBoxSell:AddDivider()
        end

        GroupBoxSell:AddLabel({ Text = "______________________________________", DoesWrap = false })
    end
end
-- ===========================================================================================
-- End of Sell Settings UI
-- ===========================================================================================
PetSellSettingsUi()





---------------------------------------------------
------ #plant
---------------------------------------------------


-- Create the UI for Selling backpack etc
local function M_UI_PLANTS()
    -- Create the new "Mutations" Tab
    local UISellTab = Window:AddTab({
        Name = "<font color='#7CFC00'>Plants</font> & <font color='#C700FF'>Packs</font>",
        Description = "<font color='#ADFF2F'>ðŸŒ¿ Automate planting, harvesting, and more with ease.</font>",
        Icon = "leaf"
    })


    ---------------------------------------------------
    -- ## Groupboxes
    ---------------------------------------------------
    local SeedPlacerGroup = UISellTab:AddLeftGroupbox('<font color="#32CD32">ðŸŒ± Seed Placement</font>', "leaf")
    local TrowelGroup = UISellTab:AddLeftGroupbox('<font color="#1E90FF">ðŸ› ï¸ Trowel Plants</font>', "pickaxe")

    local WaterGroup = UISellTab:AddRightGroupbox("ðŸŒ¿ <font color='#3CB371'>Water Plants</font>")
    local DestroyGroup = UISellTab:AddRightGroupbox('<font color="#DC143C">ðŸ›‘ Shovel Plants âš ï¸</font>', "skull")


    local SprinklerGroup = UISellTab:AddLeftGroupbox('Auto Sprinklers', "milk")
    local SeedPackGroup = UISellTab:AddRightGroupbox('Packs & Chests', "package-open")

    local reclaimGroup = UISellTab:AddLeftGroupbox('Reclaimer', "shredder")

    local performanceGroup = UISellTab:AddRightGroupbox('Performance', "chart-no-axes-column")

    local FavouriteGroupx = UISellTab:AddLeftGroupbox('Favourite Inventory', "heart")



    --====================================================
    -- ðŸŒ¸ Favourite #fav
    --====================================================

    if FavouriteGroupx then
        FavouriteGroupx:AddLabel({
            Text =
            "ðŸ’¡ Favourite or UnFavourite fruits.",
            DoesWrap = true
        })


        FavouriteGroupx:AddButton({
            Text = "<font color='#00FF00'>Favourite All</font>",
            Tooltip = "â¤ï¸ Favourite all fruits in backpack",
            Func = function()
                InventoryManager.FavAllFruitsInBackpack(true, true)
                Library:Notify("Success Favourite", 2)
            end
        })

        FavouriteGroupx:AddButton({
            Text = "<font color='#ED2A00'>UnFavourite All</font>",
            Tooltip = "âŒ UnFavourite all fruits in backpack",
            Func = function()
                InventoryManager.FavAllFruitsInBackpack(false, true)
                Library:Notify("Success UnFavourite All", 2)
            end
        })
        FavouriteGroupx:AddDivider()
    end








    --====================================================
    -- ðŸŒ¸ Delete plants #delete
    --====================================================

    if performanceGroup then
        performanceGroup:AddLabel({
            Text =
            "ðŸ’¡Deletes fruits and plants. May increase performance. Disable and rejoin to restore back to normal.",
            DoesWrap = true
        })
        performanceGroup:AddToggle("toogledeleteplants", {
            Text = "ðŸŒ± Delete Plants",
            Default = FSessionDx.farm.delete_plants,
            Tooltip = "Delete plants textures.",
            Callback = function(Value)
                FSessionDx.farm.delete_plants = Value
                SaveManager.SaveSessionSettings.SaveFile()
            end
        })

        performanceGroup:AddToggle("toogledeletefruits", {
            Text = "ðŸŒ¸ Delete Fruits",
            Default = FSessionDx.farm.delete_fruits,
            Tooltip = "Delete fruit textures.",
            Callback = function(Value)
                FSessionDx.farm.delete_fruits = Value
                SaveManager.SaveSessionSettings.SaveFile()
            end
        })
        performanceGroup:AddDivider()
        performanceGroup:AddLabel({
            Text =
            "ðŸ’¡Reload game after changing this setting.",
            DoesWrap = true
        })
        performanceGroup:AddToggle("toogledeletOutside", {
            Text = "ðŸ”„ Parent Outside",
            Default = FSessionDx.farm.change_parent,
            Tooltip = "Parents to it outside of the farm. Some features may stop working.",
            Callback = function(Value)
                FSessionDx.farm.change_parent = Value
                SaveManager.SaveSessionSettings.SaveFile()
            end
        })

        performanceGroup:AddDivider()
        performanceGroup:AddToggle("toggle_enable_delete_fruits", {
            Text = "âš¡ Enable Task",
            Default = FSessionDx.farm.enable_delete_fruits,
            Tooltip = "When enabled it will slowly keep deleting your fruits and plants.",
            Callback = function(Value)
                FSessionDx.farm.enable_delete_fruits = Value
                SaveManager.SaveSessionSettings.SaveFile()
            end
        })
        performanceGroup:AddDivider()
    end


    --====================================================
    -- ðŸŒ¸ Reclaimer #claimui
    --====================================================
    if reclaimGroup then
        UI_LABELS.lbl_reclaimer_stats = reclaimGroup:AddLabel({
            Text =
            "ðŸ’¡ Not Running",
            DoesWrap = true
        })
        local ddreclaimer = reclaimGroup:AddDropdown("ddreclaimer", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸŒ» Plants",
            Tooltip = "Select plants.. Converts plants into seeds",
            Changed = function(newSelection)
                if not newSelection then
                    return
                end
                FSettings.reclaim.plants = newSelection
                SaveData()
            end
        })
        ddreclaimer:SetValues(GetKeyMutListUsingDir(all_plants_list))
        ddreclaimer:SetValue(FSettings.reclaim.plants)



        local selectall_plants_reclaim = reclaimGroup:AddButton({
            Text = "Select All",
            Tooltip = "Selects all plants on the list.",
            Func = function()
                local pseedslist = GetKeyMutListUsingDir(all_plants_list)
                if #pseedslist > 0 then
                    FSettings.reclaim.plants = {}
                end
                for _, value in ipairs(pseedslist) do
                    FSettings.reclaim.plants[value] = true
                end
                ddreclaimer:SetValue(FSettings.reclaim.plants, true)
                SaveData()
            end
        })

        selectall_plants_reclaim:AddButton({
            Text = "<font color='#ED2A00'>DeSelect All</font>",
            Tooltip = "Deselects all the plants on the list",
            Func = function()
                FSettings.reclaim.plants = {}
                ddreclaimer:SetValue(FSettings.reclaim.plants, true)
                SaveData()
            end
        })



        local function TextKeepAmountReclaimer()
            local _am = FSettings.reclaim.keep_amount
            local _txt = string.format("âš ï¸ Keep Amount<font color='#3CB371'>(%s)</font>", _am)
            return _txt
        end

        local input_reclaim_limit
        input_reclaim_limit = reclaimGroup:AddInput("input_reclaim_limitx", {
            Text = TextKeepAmountReclaimer(),
            Default = FSettings.reclaim.keep_amount,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 3",
            Tooltip = "How many to keep?",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)
                if num and num >= 0 then
                    FSettings.reclaim.keep_amount = num
                    input_reclaim_limit:SetText(TextKeepAmountReclaimer())
                    SaveData()
                else
                    Library:Notify("Invalid " .. Value, 3)
                    input_reclaim_limit:SetValue(tostring(FSettings.reclaim.keep_amount))
                end
            end
        })



        reclaimGroup:AddDivider()


        reclaimGroup:AddButton({
            Text = "<font color='#00FF7F'>ðŸŸ¢ Start Reclaimer</font>",
            Tooltip = "Starts to claim plants",
            Func = function()
                TaskManager.StartReclaimer()
            end
        })

        reclaimGroup:AddButton({
            Text = "<font color='#FF2424'>ðŸ”´ Stop Reclaimer</font>",
            Tooltip = "Stops the reclaimer.",
            Func = function()
                TaskManager.StopReclaimer()
            end
        })
        reclaimGroup:AddDivider()
        reclaimGroup:AddSpacer(200)
    end




    --====================================================
    -- âš ï¸ SeedPacks
    --====================================================
    do
        SeedPackGroup:AddLabel({
            Text =
            "ðŸ’¡ Select packs to open",
            DoesWrap = true
        })

        local ddseedpacksselect = SeedPackGroup:AddDropdown("ddseedpacksselect", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ§° Select Packs",
            Tooltip = "Select packs to open",
            Changed = function(newSelection)
                if not newSelection then
                    return
                end
                FSettings.seedpack.selected_packs = {}
                for key, value in pairs(newSelection) do
                    FSettings.seedpack.selected_packs[key] = value
                end

                SaveData()
            end
        })
        ddseedpacksselect:SetValues(Varz.all_seed_pack_names)
        ddseedpacksselect:SetValue(FSettings.seedpack.selected_packs)

        SeedPackGroup:AddToggle("togglepacksWithout", {
            Text = "ðŸš¨ Open Without UI",
            Default = FSettings.seedpack.openwithoutui,
            Tooltip = "Destroys the ui and keeps opening the packs. to get ui back disable this and reload.",
            Callback = function(Value)
                FSettings.seedpack.openwithoutui = Value
                SaveData()
            end
        })

        SeedPackGroup:AddDivider()

        SeedPackGroup:AddToggle("togglepacksopen", {
            Text = "âš¡ Open Packs",
            Default = FSettings.seedpack.is_active,
            Tooltip = "Automatically opens any selected packs.",
            Callback = function(Value)
                FSettings.seedpack.is_active = Value
                SaveData()
            end
        })

        SeedPackGroup:AddSpacer(200)
    end


    --====================================================
    -- âš ï¸ Sprinklers
    --====================================================

    do
        SprinklerGroup:AddLabel({
            Text =
            "ðŸ’¡ <font color='#FFD700'>Automatically removes</font> any <font color='#00BFFF'>selected sprinklers</font> that have been placed. It <font color='#FF4500'>wont delete</font> while you are <font color='#ADFF2F'>holding a sprinkler manually</font> â€” it will <font color='#00FF7F'>resume</font> once unequipped. <font color='#FFA500'>Pauses</font> whenever other <font color='#FF69B4'>tasks or events</font> are running.",
            DoesWrap = true
        })


        local dropdowndeleteSprinklers = SprinklerGroup:AddDropdown("dropdowndeleteSprinklers", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ”ª Delete Sprinklers",
            Tooltip = "Select sprinklers to delete when they are placed.",
            Changed = function(newSelection)
                if not newSelection then
                    return
                end
                FSettings.auto_remove_sp_list = {}
                for key, value in pairs(newSelection) do
                    FSettings.auto_remove_sp_list[key] = value
                end

                SaveData()
            end
        })
        dropdowndeleteSprinklers:SetValues(InventoryManager.Gear.GetAllSprinklers())
        dropdowndeleteSprinklers:SetValue(FSettings.auto_remove_sp_list);


        SprinklerGroup:AddToggle("toggledeleteSprinklers", {
            Text = "âš¡ Enable Auto Delete",
            Default = FSettings.auto_remove_sprinklers,
            Tooltip = "Automatically deletes placed sprinklers",
            Callback = function(Value)
                FSettings.auto_remove_sprinklers = Value
                SaveData()
            end
        })
    end

    -- End Sprinklers








    --====================================================
    -- âš ï¸ Water plants
    --====================================================
    do
        WaterGroup:AddLabel({
            Text = "ðŸ’§ Waters plants, Pauses automatically if any other task are in progress. Skips fully grown plants.",
            DoesWrap = true
        })


        UI_LABELS.lbl_watering_stats = WaterGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        UI_LABELS.lbl_watering_information = WaterGroup:AddLabel({
            Text = "",
            DoesWrap = true
        })
        WaterGroup:AddDivider()
        local dropdownPlantsWater = WaterGroup:AddDropdown("waterplantslist", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ’§ Plants To Water",
            Tooltip = "Choose one or multiple plants that should be automatically watered.",
            Changed = function(newSelection)
                FOtherSettings.watering_list_plants = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.watering_list_plants[key] = value
                end

                SaveDataOther()
            end
        })
        dropdownPlantsWater:SetValues(GetKeyMutListUsingDir(all_plants_list))
        dropdownPlantsWater:SetValue(FOtherSettings.watering_list_plants);
        WaterGroup:AddDivider()



        local input_cans_per_plant
        local text_water_cycle_per_plant = "ðŸ’§ Watering Can Per <font color='#3CB371'>Plant</font>"
        input_cans_per_plant = WaterGroup:AddInput("inputwateringcanspercycle", {
            Text = text_water_cycle_per_plant,
            Default = FOtherSettings.watering_amount_to_water,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 3",
            Tooltip = "Set how many watering cans are used for each plant.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if num and num > 0 then
                    FOtherSettings.watering_amount_to_water = num
                    SaveDataOther()
                    input_cans_per_plant:SetText("âœ… <font color='#00FF00'>Updated</font>")
                    task.wait(1)
                    input_cans_per_plant:SetText(text_water_cycle_per_plant)
                else
                    Library:Notify("Invalid " .. Value, 3)
                    input_cans_per_plant:SetValue(tostring(FOtherSettings.watering_amount_to_water))
                end
            end
        })


        local inputCansSpeed
        local textSpeedWateringCan = "âš¡ Watering <font color='#3CB371'>Speed</font>"
        inputCansSpeed = WaterGroup:AddInput("inputwateringcanspercyclexx", {
            Text = textSpeedWateringCan,
            Default = FOtherSettings.watering_speed_time,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "Seconds (e.g. 2.5)",
            Tooltip = "Adjust the time interval (in seconds) between each watering action.",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if num and num > 0 then
                    FOtherSettings.watering_speed_time = num
                    SaveDataOther()
                    inputCansSpeed:SetText("âœ… <font color='#00FF00'>Updated</font>")
                    task.wait(1)
                    inputCansSpeed:SetText(textSpeedWateringCan)
                else
                    Library:Notify("Invalid " .. Value, 3)
                    inputCansSpeed:SetValue(tostring(FOtherSettings.watering_speed_time))
                end
            end
        })

        WaterGroup:AddDivider()

        WaterGroup:AddToggle("toogleEnableWatering", {
            Text = "âš¡Water Plants",
            Default = FOtherSettings.watering_is_auto,
            Tooltip = "Automatically waters plants that are not grown.",
            Callback = function(Value)
                FOtherSettings.watering_is_auto = Value
                SaveDataOther()
                if Value then
                    Library:Notify("âœ… Enabled", 1)
                else
                    Library:Notify("â¸ï¸ Disabled", 1)
                end
            end
        })






        WaterGroup:AddSpacer(20)
    end









    --====================================================
    -- âš ï¸ Trowel plants
    --====================================================
    do
        TrowelGroup:AddLabel({
            Text =
            "ðŸ“ Select plants to trowel (move) \nðŸŸ¢ Set your position if you change farm locations \nðŸ› ï¸ Changing tools will stop the process\nðŸ¥š Pauses automatically if hatching is in progress",
            DoesWrap = true
        })


        UI_LABELS.lbl_trowel_stats = TrowelGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        TrowelGroup:AddDivider()
        local trowelPlantsListDropdown
        trowelPlantsListDropdown = TrowelGroup:AddDropdown("trowelPlantsListDropdown", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "â›ï¸ Select Plants To Trowel",
            Tooltip = "Select plants to move to a new position. If you don't select any then all plants will be moved.",
            Changed = function(newSelection)
                FOtherSettings.trowel_plants_list = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.trowel_plants_list[key] = value
                end

                SaveDataOther()
            end
        })

        trowelPlantsListDropdown:SetValues(GetKeyMutListUsingDir(all_plants_list))
        trowelPlantsListDropdown:SetValue(FOtherSettings.trowel_plants_list);

        local selectall_plants = TrowelGroup:AddButton({
            Text = "Select All",
            Tooltip = "Selects all plants on the list.",
            Func = function()
                local pseedslist = GetKeyMutListUsingDir(all_plants_list)
                if #pseedslist > 0 then
                    FOtherSettings.trowel_plants_list = {}
                end
                for _, value in ipairs(pseedslist) do
                    FOtherSettings.trowel_plants_list[value] = true
                end
                trowelPlantsListDropdown:SetValue(FOtherSettings.trowel_plants_list, true)
                SaveDataOther()
            end
        })

        selectall_plants:AddButton({
            Text = "<font color='#ED2A00'>DeSelect All</font>",
            Tooltip = "Deselects all the plants on the list",
            Func = function()
                FOtherSettings.trowel_plants_list = {}
                trowelPlantsListDropdown:SetValue(FOtherSettings.trowel_plants_list, true)
                SaveDataOther()
            end
        })

        TrowelGroup:AddDivider()

        --- current c frame
        UI_LABELS.lbl_trowel_cframe = TrowelGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        UI_LABELS.lbl_trowel_progress = TrowelGroup:AddLabel({
            Text = "",
            DoesWrap = true
        })
        TrowelGroup:AddDivider()
        _PlantsManager.UpdateTrowelCframe("ðŸ“Current Position: " .. tostring(FOtherSettings.trowel_saved_cframe))

        -- copy cframe
        local btnCframe = TrowelGroup:AddButton({
            Text = "ðŸ—ºï¸ Copy Player Position",
            Tooltip = "Please stand where you want to move the Plants.",
            Func = function()
                local px = _PlantsManager.GetCurrentCFrameFromPlayerString()
                --warn("px", tostring(px))
                if not px then
                    Library:Notify("Failed to save", 3)
                    return
                end

                local new_pos = _PlantsManager.StringToVector3(px)
                local center = FarmManager.mFarm.Center_Point.Position

                if _PlantsManager.IsWithinRangeOfFarm(center, new_pos) then
                    Library:Notify("Failed, Please be inside your farm.", 3)
                    --_PlantsManager.UpdateTrowelCframe("ðŸ“New Position: " .. FOtherSettings.trowel_saved_cframe)
                    return
                end

                FOtherSettings.trowel_saved_cframe = px
                _PlantsManager.UpdateTrowelCframe("ðŸ“New Position: " .. FOtherSettings.trowel_saved_cframe)
                Library:Notify("Position saved", 3)
                SaveDataOther()
            end
        })

        local ButtonTrowel = TrowelGroup:AddButton({
            Text = "â–¶ï¸ Start Trowel",
            Func = function()
                if _PlantsManager.trowel_is_running then
                    return
                end
                _PlantsManager.trowel_is_running = true
                Library:Notify("Trowel started", 3)
            end
        })

        local ButtonStopTrowel = ButtonTrowel:AddButton({
            Text = "ðŸ”´ Stop Trowel",
            Func = function()
                if not _PlantsManager.trowel_is_running then
                    return
                end

                _PlantsManager.trowel_is_running = false
                Library:Notify("Trowel stopped", 3)
            end
        })



        TrowelGroup:AddSpacer(20)
    end




    --====================================================
    -- ðŸ›‘ Shovel System
    --====================================================
    do
        DestroyGroup:AddLabel({
            Text = "ðŸª“ Auto-shovel system: select plants to remove <font color='#e81416'>(will be destroyed)</font>",
            DoesWrap = true
        })

        DestroyGroup:AddDivider()
        UI_LABELS.lbl_shovel_status = DestroyGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })
        DestroyGroup:AddDivider()
        UI_LABELS.lbl_shovel_information = DestroyGroup:AddLabel({
            Text = "",
            DoesWrap = true
        })

        DestroyGroup:AddDivider()
        UI_Dropdown.ShovelDropDown = DestroyGroup:AddDropdown("dropdownShovel", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "âš ï¸ Loading please wait...",
            Tooltip = "Choose the plants you want to shovel",
            Changed = function(newSelection)
                if type(newSelection) ~= "table" then
                    warn("Invalid dropdown selection:", newSelection)
                    return
                end
                FOtherSettings.shovel_plants_list = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.shovel_plants_list[key] = value
                end

                SaveDataOther()
            end
        })


        DestroyGroup:AddButton({
            Text = "â™»ï¸ Reload Plants",
            Func = function()
                if not FarmManager.IsDataFullyLoaded or not FarmManager.IsFarmFullyLoaded() then
                    Library:Notify("Farm is still loading...")
                    return
                end
                ShovelManager.UpdateCurrentPlantsInFarm()
                Library:Notify("Reloaded")
            end
        })



        DestroyGroup:AddDivider()

        local inputmaxkeep
        local maxseed_default_text = "ðŸŒ± Max <font color='#F54927'>Plants</font> to keep"
        inputmaxkeep = DestroyGroup:AddInput("shovel_seedcount", {
            Text = maxseed_default_text,
            Default = FOtherSettings.shovel_keep_amount,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "Enter number of plants to keep",
            Tooltip =
            "Specify how many plants to keep when shovelling. Enter 0 to remove all. Each type of plant will follow this limit.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num < 0 then
                    Library:Notify("Invalid Seed Count: " .. Value, 3)
                    inputmaxkeep:SetValue(tostring(FOtherSettings.shovel_keep_amount))
                    return
                end

                if num >= 0 then
                    -- Update
                    FOtherSettings.shovel_keep_amount = num
                    SaveDataOther()
                    inputmaxkeep:SetText("âœ… <font color='#00FF00'>Plant Count Updated</font>")
                    task.wait(1)
                    inputmaxkeep:SetText(maxseed_default_text)
                end
            end
        })




        DestroyGroup:AddButton({
            Text = "â–¶ï¸ Start Shovel",
            Func = function()
                if ShovelManager.IsActive then
                    Library:Notify("Already running", 3)
                    return
                end
                ShovelManager.IsActive = true
                Library:Notify("Shovel started", 3)
                SaveDataOther()
            end
        })

        DestroyGroup:AddButton({
            Text = "ðŸ”´ Stop Shovel",
            Func = function()
                if not ShovelManager.IsActive then
                    Library:Notify("Already stopped", 3)
                    return
                end

                ShovelManager.IsActive = false
                Library:Notify("Shovel stopped", 3)
                SaveDataOther()
            end
        })
        DestroyGroup:AddDivider()

        DestroyGroup:AddLabel({
            Text =
            "â™»ï¸ Auto-Shovel: Continuously removes plants that exceed your set limit. ðŸŒ± Please select which plants to filter.",
            DoesWrap = true
        })

        DestroyGroup:AddToggle("toggleshovelalwayson", {
            Text = "âš¡ Always On",
            Default = FOtherSettings.is_auto_shovel,
            Tooltip = "Automatically removes any plants that go beyond your set maximum.",
            Callback = function(Value)
                FOtherSettings.is_auto_shovel = Value
                SaveDataOther()
                if Value then
                    Library:Notify("âœ… Auto-Shovel Enabled", 1)
                else
                    Library:Notify("â¸ï¸ Auto-Shovel Disabled", 1)
                end
            end
        })

        DestroyGroup:AddSpacer(20)
    end







    --====================================================
    -- ðŸŒ± Seed Placement System
    --====================================================
    do
        SeedPlacerGroup:AddLabel({
            Text =
            "ðŸŒ± Seed Placement System: select seeds to plant <font color='#32CD32'>(will be automatically placed)</font>",
            DoesWrap = true
        })



        SeedPlacerGroup:AddDivider()
        UI_LABELS.lbl_seed_status = SeedPlacerGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })
        SeedPlacerGroup:AddDivider()
        UI_LABELS.lbl_seed_information = SeedPlacerGroup:AddLabel({
            Text = "",
            DoesWrap = true
        })

        SeedPlacerGroup:AddDivider()
        local seedDropDown
        seedDropDown = SeedPlacerGroup:AddDropdown("dropdownSave", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸŒ¾ Seeds to Plant",
            Tooltip = "Choose which seeds you want to plant automatically",
            Changed = function(newSelection)
                if type(newSelection) ~= "table" then
                    warn("Invalid dropdown selection:", newSelection)
                    return
                end
                FOtherSettings.seed_placement_list = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.seed_placement_list[key] = value
                end

                SaveDataOther()
            end
        })




        -- #seed
        seedDropDown:SetValues(GetKeyMutListUsingDir(all_plants_list))
        seedDropDown:SetValue(FOtherSettings.seed_placement_list)

        local selectall_seeds = SeedPlacerGroup:AddButton({
            Text = "Select All",
            Tooltip = "Selects all seeds on the list.",
            Func = function()
                local seedslist = GetKeyMutListUsingDir(all_plants_list)
                if #seedslist > 0 then
                    FOtherSettings.seed_placement_list = {}
                end
                for _, value in ipairs(seedslist) do
                    FOtherSettings.seed_placement_list[value] = true
                end
                seedDropDown:SetValue(FOtherSettings.seed_placement_list, true)
                SaveDataOther()
            end
        })

        selectall_seeds:AddButton({
            Text = "<font color='#ED2A00'>DeSelect All</font>",
            Tooltip = "Deselects all the seeds on the list",
            Func = function()
                FOtherSettings.seed_placement_list = {}
                seedDropDown:SetValue(FOtherSettings.seed_placement_list, true)
                SaveDataOther()
            end
        })


        SeedPlacerGroup:AddDivider()

        local inputMaxKeep
        local maxSeedDefaultText = "ðŸŒ± Max <font color='#32CD32'>Seeds</font> to keep"
        inputMaxKeep = SeedPlacerGroup:AddInput("seed_keepcount", {
            Text = maxSeedDefaultText,
            Default = FOtherSettings.seed_keep_amount,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "Enter maximum seeds per type",
            Tooltip = "Specify how many seeds can be planted per type at once.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Seed Count: " .. Value, 3)
                    inputMaxKeep:SetValue(tostring(FOtherSettings.seed_keep_amount))
                    return
                end

                FOtherSettings.seed_keep_amount = num
                SaveDataOther()
                inputMaxKeep:SetText("âœ… <font color='#00FF00'>Seed Count Updated</font>")
                task.wait(1)
                inputMaxKeep:SetText(maxSeedDefaultText)
            end
        })


        -- Speed
        SeedPlacerGroup:AddDivider()

        local max_default_text = "âš¡ <font color='#FF9E1F'>Seed Placement Speed</font>"

        local InputTimer
        InputTimer = SeedPlacerGroup:AddInput("inputspeedtimer", {
            Text = max_default_text,
            Default = FOtherSettings.seed_speed_timer1,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "Enter placement speed (lower = faster)",
            Tooltip = "Set how fast seeds are automatically placed. Smaller numbers mean faster placement.",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if not num then
                    Library:Notify("âŒ Invalid number: " .. tostring(Value), 3)
                    InputTimer:SetValue(tostring(FOtherSettings.seed_speed_timer1))
                    return
                end

                if num <= 0 then
                    Library:Notify("âš ï¸ Please enter a number greater than 0", 3)
                    InputTimer:SetValue(tostring(FOtherSettings.seed_speed_timer1))
                    return
                end

                -- Save new speed
                FOtherSettings.seed_speed_timer1 = num
                SaveDataOther()

                -- Show temporary confirmation
                InputTimer:SetText("âœ… <font color='#00FF00'>Placement Speed Updated</font>")
                task.wait(1.5)
                InputTimer:SetText(max_default_text)
            end
        })



        -- CFrame
        --- current c frame
        UI_LABELS.lbl_seed_location = SeedPlacerGroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })
        SeedPlacerGroup:AddDivider()
        SeedManager.Labels.updateLocation("ðŸ“Current Position: " .. tostring(FOtherSettings.seed_location_vector))

        -- copy cframe
        local btnlocationseed = SeedPlacerGroup:AddButton({
            Text = "ðŸ—ºï¸ Copy Player Position",
            Tooltip = "Please stand where you want to plant the Seeds.",
            Func = function()
                local px = _PlantsManager.GetCurrentCFrameFromPlayerString()
                --warn("px", tostring(px))
                if not px then
                    Library:Notify("Failed to save", 3)
                    return
                end

                local new_pos = _PlantsManager.StringToVector3(px)
                local center = FarmManager.mFarm.Center_Point.Position

                if _PlantsManager.IsWithinRangeOfFarm(center, new_pos) then
                    Library:Notify("Failed, Please be inside your farm.", 3)
                    --_PlantsManager.UpdateTrowelCframe("ðŸ“New Position: " .. FOtherSettings.seed_location_vector)
                    return
                end

                FOtherSettings.seed_location_vector = px
                SeedManager.Labels.updateLocation("ðŸ“New Position: " .. FOtherSettings.seed_location_vector)
                Library:Notify("Position saved", 3)
                SaveDataOther()
            end
        })



        SeedPlacerGroup:AddToggle("toggleRandomPos", {
            Text = "ðŸŽ² Random Placement",
            Default = FOtherSettings.is_seed_random,
            Tooltip = "Automatically plants seeds at random positions.",
            Callback = function(Value)
                FOtherSettings.is_seed_random = Value
                SaveDataOther()
                if Value then
                    Library:Notify("âœ… Random Placement Enabled", 1)
                else
                    Library:Notify("â¸ï¸ Random Placement Disabled", 1)
                end
            end
        })

        SeedPlacerGroup:AddButton({
            Text = "â–¶ï¸ Start Placement",
            Func = function()
                if SeedManager.IsActive then
                    Library:Notify("Already running", 3)
                    return
                end
                SeedManager.IsActive = true
                Library:Notify("Seed placement started", 3)
                SaveDataOther()
            end
        })

        SeedPlacerGroup:AddButton({
            Text = "ðŸ”´ Stop Placement",
            Func = function()
                if not SeedManager.IsActive then
                    Library:Notify("Already stopped", 3)
                    return
                end

                SeedManager.IsActive = false
                Library:Notify("Seed placement stopped", 3)
                SaveDataOther()
            end
        })
        SeedPlacerGroup:AddDivider()

        SeedPlacerGroup:AddLabel({
            Text = "â™»ï¸ Auto-Placement: Continuously plants seeds according to your selected types.",
            DoesWrap = true
        })

        SeedPlacerGroup:AddToggle("toggleseedalwayson", {
            Text = "âš¡ Always On",
            Default = FOtherSettings.is_auto_seed,
            Tooltip = "Automatically plants seeds continuously according to your limits.",
            Callback = function(Value)
                FOtherSettings.is_auto_seed = Value
                SaveDataOther()
                if Value then
                    Library:Notify("âœ… Auto-Placement Enabled", 1)
                else
                    Library:Notify("â¸ï¸ Auto-Placement Disabled", 1)
                end
            end
        })

        SeedPlacerGroup:AddSpacer(20)
    end

    ----------================== end seeds




    -- end function
end

-- Call the function to build the UI
M_UI_PLANTS()









-- #eventui
-- Events UI Function #UiEvent
local function MEventsUi()
    -- 1. Create the new "Events" Tab
    local UIEventsTab = Window:AddTab({
        Name =
        "<b><stroke color='#000000' thickness='1.5'><font color='#FF6347'>Event</font> <font color='#FFFFFF'>&</font> <font color='#00FFFF'>Mutation</font></stroke></b>",
        Description = "Manage game events and pet mutations.",
        Icon = "calendar-heart"
    })

    local type_fruit_event_name = "Christmas Event ðŸŽ…" -- ðŸ¥¬ <font color='#ff00ff'>Fall Market Event</font> ðŸ¥•

    -- Groups
    --local eventJungle = UIEventsTab:AddLeftGroupbox("ðŸŒ´ <font color='#228B22'>Jungle Event</font> ðŸ‚", "tree")

    local gFallEvent = UIEventsTab:AddLeftGroupbox(type_fruit_event_name, "snowflake")
    --local FallQuestui = UIEventsTab:AddLeftGroupbox("ðŸ‚ <font color='#FFD700'>Fall Activities</font> ðŸŒ½", "tasks")
    local GroupBoxAutoAscension = UIEventsTab:AddRightGroupbox("AutoAscension", "calendar-sync")
    local gPetMutationMachine = UIEventsTab:AddRightGroupbox("Pet Mutation Machine", "blocks")

    local title =
        "ðŸŽƒ <stroke color='#FFD8A8' sizing='fixed' thickness='0.3' transparency='0.3' joins='round'>"
        .. "<b><font color='#FF4E1C'>Horseman</font> & <font color='#FFB833'>Elephant</font></b>"
        .. "</stroke> ðŸ˜"
    local gMutOnFarm = UIEventsTab:AddLeftGroupbox(title)
    local gRecommended = UIEventsTab:AddRightGroupbox("<uc>Event Category</uc>", "sun-moon")
    local gDataReader = UIEventsTab:AddRightGroupbox("<uc>Data</uc>", "blocks")

    local gDig = UIEventsTab:AddLeftGroupbox("[â›] Dig Event", "shovel")

    --local gSmithMan = UIEventsTab:AddLeftGroupbox("ðŸ”¨ Smith Man", "speech")


    local titleagebreak =
        "ðŸ’¥ <stroke color='#000055' thickness='1.5' joins='round'>" ..
        "<b><font color='#00FFFF'>PET</font> <font color='#FFFFFF'>AGE</font> <font color='#FF00FF'>MACHINE</font></b>" ..
        "</stroke>"

    local gAgeBreakUI = UIEventsTab:AddLeftGroupbox(titleagebreak)


    --local gTradeEvent = UIEventsTab:AddLeftGroupbox("ðŸ’° Trade Event", "store")



    local titlecustomteams =
        "ðŸ”„ <stroke color='#000055' thickness='1.5' joins='round'>" ..
        "<b><font color='#FFFFFF'>Custom</font> <font color='#F52727'>Teams</font></b>" ..
        "</stroke>"

    local gCustomTeams = UIEventsTab:AddLeftGroupbox(titlecustomteams)

    ----------------------------------------------
    -------- ===== Trade event #trade
    ----------------------------------------------
    if gTradeEvent then
        gTradeEvent:AddLabel({
            Text =
            "ðŸ’¡ Automatically submits to trade event.",
            DoesWrap = true
        })

        UI_LABELS.lbl_tradeevent_status = gTradeEvent:AddLabel({
            Text = "Status: ",
            DoesWrap = true
        })

        -- Auto collect fruit toggle
        gTradeEvent:AddDivider()
        gTradeEvent:AddToggle("gTradeEventbtncraftautofruitsx", {
            Text = "ðŸ’ Auto-Collect Fruits",
            Default = FSettings.tradeevent.fruit_collect,
            Tooltip = "Automatically collects required fruits for crafting.",
            Callback = function(Value)
                FSettings.tradeevent.fruit_collect = Value
                SaveData()
                local status = Value and "ðŸ’ Auto-Collect Enabled" or "ðŸ’ Auto-Collect Disabled"
                Library:Notify(status, 2)
            end
        })

        gTradeEvent:AddDivider()
        -- Auto plants if no plant found
        gTradeEvent:AddToggle("gTradeEventtogglesdjksdjksdx", {
            Text = "ðŸŒ± Auto-Place Plants",
            Default = FSettings.tradeevent.seed_place,
            Tooltip = "Automatically plants seeds when if no plants found.",
            Callback = function(Value)
                FSettings.tradeevent.seed_place = Value
                SaveData()
                local status = Value and "ðŸŒ± Auto-Plant Enabled" or "ðŸŒ± Auto-Plant Disabled"
                Library:Notify(status, 2)
            end
        })

        gTradeEvent:AddToggle("toggleenabletradeevent", {
            Text = "âš¡ Enable Trade Event",
            Default = FSettings.tradeevent.enable_trade_event,
            Tooltip = "Automatically submits requirements to trade event.",
            Callback = function(Value)
                FSettings.tradeevent.enable_trade_event = Value
                SaveData()
            end
        })
    end


    -- END trade end




    ----------------------------------------------
    -------- ===== Teams Systems  #teams
    ----------------------------------------------

    if gCustomTeams then
        gCustomTeams:AddLabel({
            Text =
            "ðŸ’¡ Custom teams, can be used for some setups.",
            DoesWrap = true
        })

        local GetText_CustomTeams1Text = function()
            local current_selected = #FSettings.customteams_team1
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#00FF3C"><b>ðŸ¤– Team 1</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )
            return txt
        end


        --- =========== Team 1

        UI_Dropdown.customteams_team1 = gCustomTeams:AddDropdown("customteams_team1", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_CustomTeams1Text(),
            Tooltip = "Select pets for this team.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}

                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end


                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.customteams_team1:SetValue(ConvertUUIDToPetNamesPairs(FSettings.customteams_team1))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.customteams_team1 = tmp_tbl
                    SaveData()
                    UI_Dropdown.customteams_team1:SetText(GetText_CustomTeams1Text())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        gCustomTeams:AddButton({
            Text = "ðŸŸ¢ Start Teams",
            Func = function()
                PetMutation.StartCustomTeams()
            end
        })

        gCustomTeams:AddButton({
            Text = "ðŸ”´ Stop Teams",
            Func = function()
                PetMutation.StopCustomTeams()
            end
        })

        gCustomTeams:AddSpacer(100)
    end

    ----------------------------------------------
    -------- ===== End Teams
    ----------------------------------------------







    ----------------------------------------------
    -------- ===== Age Break #age #break #agebreak
    ----------------------------------------------
    if gAgeBreakUI then
        gAgeBreakUI:AddLabel({
            Text =
            "ðŸ’¡ Automatically level up pets using the Pet Age Machine.",
            DoesWrap = true
        })

        UI_LABELS.lbl_agebreak_status = gAgeBreakUI:AddLabel({
            Text = "Waiting...",
            DoesWrap = true
        })

        -- Texts

        local GetText_AgebreakTargetTeam = function()
            local current_selected = #FSettings.agebreak.target_team
            local max_allowed = 99

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#00FF3C"><b>â™»ï¸ Target Pets</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )
            return txt
        end

        local GetText_AgebreakDupTeam = function()
            local current_selected = #FSettings.agebreak.dup_team
            local max_allowed = 125

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#FF0066"><b>ðŸ”· Duplicates</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )

            return txt
        end

        --- =========== Target Pets

        UI_Dropdown.agebreaktarget_team = gAgeBreakUI:AddDropdown("agebreaktarget_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_AgebreakTargetTeam(),
            Tooltip = "Select pets to level",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end
                if not _allowed then
                    UI_Dropdown.agebreaktarget_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.agebreak.target_team))
                    Library:Notify(
                        "This pet is in your pet mutation (Elephant/Horseman) teams, please remove it from there.")
                    return
                end

                local max_allowed = 99
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.agebreaktarget_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.agebreak.target_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.agebreak.target_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.agebreaktarget_team:SetText(GetText_AgebreakTargetTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        --- =========== Dup Pets

        UI_Dropdown.agebreakdup_team = gAgeBreakUI:AddDropdown("agebreakdup_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_AgebreakDupTeam(),
            Tooltip =
            "Select pets that will be used to level up your pets, these wil be consumed by the system 1 per level. You must add same type of pet. e.g. For Butterfly select butterflys",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end
                if not _allowed then
                    UI_Dropdown.agebreakdup_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.agebreak.dup_team))
                    Library:Notify(
                        "This pet is in your pet mutation (Elephant/Horseman) teams, please remove it from there.")
                    return
                end

                local max_allowed = 125
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.agebreakdup_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.agebreak.dup_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.agebreak.dup_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.agebreakdup_team:SetText(GetText_AgebreakDupTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        gAgeBreakUI:AddLabel({
            Text = "---------------",
            DoesWrap = false
        })
        gAgeBreakUI:AddToggle("baseweightlimitagebreak", {
            Text = "ðŸ”´BaseWeight Limit",
            Default = FSettings.agebreak.avoid_weight_filter,
            Tooltip = "If enabled, any pets with baseweight more than 3.5 KG will be ignored.",
            Callback = function(Value)
                FSettings.agebreak.avoid_weight_filter = Value
                SaveData()
            end
        })

        gAgeBreakUI:AddToggle("levellimitagebreak", {
            Text = "ðŸŸ¡Level Limit",
            Default = FSettings.agebreak.avoid_age_filter,
            Tooltip = "If enabled, any pet over the age of 99 will be ignored.",
            Callback = function(Value)
                FSettings.agebreak.avoid_age_filter = Value
                SaveData()
            end
        })

        gAgeBreakUI:AddLabel({
            Text = "---------------",
            DoesWrap = false
        })

        gAgeBreakUI:AddDivider()

        local function GetAgeBreakMaxLevelCustom()
            local level = FSettings.agebreak.max_level
            local str = string.format(
                "<b><font color='#7327F5'>ðŸŽ¯ Target Lv.</font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        local inputageMaxLevelCustom
        inputageMaxLevelCustom = gAgeBreakUI:AddInput("inputageMaxLevelCustom", {
            Text = GetAgeBreakMaxLevelCustom(),
            Default = FSettings.agebreak.max_level,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 101",
            Tooltip = "Enter level, must be over 100",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 100 then
                    Library:Notify("Invalid Level: " .. Value, 3)
                    inputageMaxLevelCustom:SetValue(tostring(FSettings.agebreak.max_level))
                    return
                end
                if num > 125 then
                    Library:Notify("Max level can't exceed 125: " .. Value, 3)
                    inputageMaxLevelCustom:SetValue(tostring(FSettings.agebreak.max_level))
                    return
                end

                if num > 0 then
                    FSettings.agebreak.max_level = num
                    SaveData()
                    inputageMaxLevelCustom:SetText(GetAgeBreakMaxLevelCustom())
                end
            end
        })
        gAgeBreakUI:AddDivider()

        gAgeBreakUI:AddToggle("eAgeBreak", {
            Text = "âš¡ Enable Age Break",
            Default = FSettings.agebreak.is_active_agebreak,
            Tooltip = "Enables the Age Break System.",
            Callback = function(Value)
                FSettings.agebreak.is_active_agebreak = Value
                SaveData()
            end
        })

        gAgeBreakUI:AddDivider()
        gAgeBreakUI:AddButton({
            Text = "<font color='#00FF04'>â™»ï¸ Reload Teams</font>",
            Func = function()
                UpdatePetData()
            end
        })


        gAgeBreakUI:AddSpacer(200)
    end
    ----------------------------------------------
    -------- ===== End Age Break
    ----------------------------------------------





    ----------------------------------------------
    -------- ===== Smith Man #smith
    ----------------------------------------------
    if gSmithMan then
        gSmithMan:AddLabel({
            Text =
            "ðŸ’¡ Automatically submits items to the Smith Man. Auto collects fruits if none found.",
            DoesWrap = true
        })

        UI_LABELS.lbl_smithman_status = gSmithMan:AddLabel({
            Text = "Status: ",
            DoesWrap = true
        })


        -- List Eggs
        local egglist_event_smith = gSmithMan:AddDropdown("dd_egglistsmithman", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "Select <font color='#32CD32'>Eggs</font>",
            Tooltip = "Select eggs to submit.",
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.craftevent.egg_list = newSelection
                SaveData()
            end
        })
        egglist_event_smith:SetValues(_Helper.AllEggNamesList)
        egglist_event_smith:SetValue(FSettings.craftevent.egg_list)

        -- List Gear
        local gearlist_event_smith = gSmithMan:AddDropdown("gearlist_event_smith", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "Select <font color='#32CD32'>Gear</font>",
            Tooltip = "Select gears to submit.",
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.craftevent.gear_list = newSelection
                SaveData()
            end
        })
        local geardatals = InventoryManager.Gear.GetAllGearData()
        gearlist_event_smith:SetValues(geardatals)
        gearlist_event_smith:SetValue(FSettings.craftevent.gear_list)


        -- List fruit
        local fruitlist_event_smith = gSmithMan:AddDropdown("fruitlist_event_smith", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "Select <font color='#32CD32'>Fruits</font>",
            Tooltip = "Select fruits to submit. If nothing is selected then random fruit will be submitted.",
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.craftevent.fruit_list = newSelection
                SaveData()
            end
        })
        fruitlist_event_smith:SetValues(GetKeyValuesFromList(all_plants_list))
        fruitlist_event_smith:SetValue(FSettings.craftevent.fruit_list)


        gSmithMan:AddToggle("autosmithman", {
            Text = "âš¡ Enable Smith Man",
            Default = FSettings.craftevent.smith_auto,
            Tooltip = "Automatically submits items to smith man",
            Callback = function(Value)
                FSettings.craftevent.smith_auto = Value
                SaveData()
            end
        })
    end


    -- END smith man

    ----------------------------------------------
    -------- ===== Dig Event #dig
    ----------------------------------------------

    if gDig then
        gDig:AddLabel({
            Text =
            "[â›] Digging Event â€” when enabled, it will automatically dig and automatically use your <font color='#FFD93B'>Dig Trinkets</font> if available.",
            DoesWrap = true
        })

        gDig:AddDivider()

        gDig:AddToggle("autoDig", {
            Text = "ðŸª£ Enable Auto Dig",
            Default = FSettings.halloween.auto_dig,
            Tooltip = "Automatically digs whenever you have available digs.",
            Callback = function(Value)
                FSettings.halloween.auto_dig = Value
                SaveData()
            end
        })

        gDig:AddDivider()
    end



    ----------------------------------------------
    -- ============= END DIG Event
    ----------------------------------------------





    ---========== Event category fruits #seedui
    if gRecommended then
        local function reload_seeds()
            local dataseeds = Varz.GetEfficientEventFruits()
            local placeseeds = Varz.GetSeedsToPlaceBalanced(dataseeds)

            Varz.event_seeding_list = placeseeds

            -- Build rich text string
            local rtext = "<b><font color='#FFD700'>Recommended Seeds</font></b>\n\n"

            for seedName, data in pairs(placeseeds) do
                -- Use color and bold for seed names, normal for count
                rtext = rtext ..
                    string.format("<b><font color='#00FF00'>%s</font></b>: %d\n", seedName, data.placeamount)
            end

            local _txt = string.format("%s \n %s", Varz.BuildEventSeedText(dataseeds), rtext)
            return _txt
        end


        local lvl_re = gRecommended:AddLabel({
            Text = "Click reload button to get recommended seeds for placement.",
            DoesWrap = true
        })

        -- Start seeding
        gRecommended:AddButton({
            Text = "Reload Seed Data",
            Func = function()
                Library:Notify("Reload", 3)

                lvl_re:SetText(reload_seeds())
            end
        })


        -- Start seeding
        gRecommended:AddButton({
            Text = "<font color='#F6FF00'>Place These Seeds</font>",
            Func = function()
                if Varz.event_seeding_active then
                    Library:Notify("Already running", 3)
                    return
                end
                Library:Notify("Started", 3)
                Varz.event_seeding_active = true
            end
        })

        -- Stop seeding
        gRecommended:AddButton({
            Text = "<font color='#FF0F0F'>Stop seed placement</font>",
            Func = function()
                if not Varz.event_seeding_active then
                    Library:Notify("Not running", 3)
                    return
                end
                Library:Notify("Stopped", 3)
                Varz.event_seeding_active = false
            end
        })
    end


    ---========== Data read


    local _mdata_lbl = nil
    local ddDatalist = gDataReader:AddDropdown("ddDatalistsds", {
        Values = {},
        Default = {},
        Multi = false,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸ”’ Select Key",
        Tooltip = "Reads data based on key",
        Callback = function(Values)
            if Values == nil then
                return
            end

            local datax = VulnManager.GetBigDataUsingKey(Values)

            local jx = _S.HttpService:JSONEncode(datax)
            if _mdata_lbl then
                _mdata_lbl:SetText(jx)
            end
        end
    })

    _mdata_lbl = gDataReader:AddLabel({
        Text = "--",
        DoesWrap = true
    })

    ddDatalist:SetValues(VulnManager.AllBigDataKeys)

    --    gMutOnFarm:AddButton({
    --         Text = "ðŸŸ¢ Start Pet Mutation",
    --         Func = function()
    --             FSettings.mut_system.is_ruuning = true
    --             PetMutation.StartThread()
    --         end
    --     })



    ----------------------------------------------
    -------- Mutation Pet #mutui
    ----------------------------------------------
    do
        UI_LABELS.lbl_pet_mutation_status = gMutOnFarm:AddLabel({
            Text = "ðŸ”´ Stopped",
            DoesWrap = true
        })


        gMutOnFarm:AddLabel({
            Text =
            "ðŸ’¥ [Headless Horseman and Elephant] Mutation System. <font color='#00BFFF'><b>â„¹ï¸ Select mutations you want to apply to your pets.</b></font> Auto uses Cleansing Pet Shard if pets have a none matching mutation. (Only Target pet mutations are cleaned.) ",
            DoesWrap = true
        })

        gMutOnFarm:AddDivider()


        ---=========== MAX LEVELING TEAM
        UI_Dropdown.dropdown_petmutation_maxlevelteam = gMutOnFarm:AddDropdown("dropdown_petmut_maxlevelteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = PetMutation.mut_ui.GetText_MaxLevelTeam(),
            Tooltip = "Select max leveling team when pet has the required mutation. Will use xp team if this is empty.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end


                if not _allowed then
                    UI_Dropdown.dropdown_petmutation_maxlevelteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings
                        .mut_system
                        .maxlevel_team))
                    Library:Notify("This pet is already selected in your other target team.")
                    return
                end

                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_petmutation_maxlevelteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings
                        .mut_system
                        .maxlevel_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.maxlevel_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_petmutation_maxlevelteam:SetText(PetMutation.mut_ui.GetText_MaxLevelTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        ----============================ XP Team
        UI_Dropdown.dropdown_petmut_xpteam = gMutOnFarm:AddDropdown("dropdown_petmut_xpteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = PetMutation.mut_ui.GetText_XpTeam(),
            Tooltip = "XP Team, this team will level your pets to the set level set by you.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end


                if not _allowed then
                    UI_Dropdown.dropdown_petmut_xpteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.xpteam))
                    Library:Notify("This pet is already selected in your other target team.")
                    return
                end

                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_petmut_xpteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system.xpteam))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.xpteam = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_petmut_xpteam:SetText(PetMutation.mut_ui.GetText_XpTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        ----============================  END XP Team


        ----============================ Target Team
        UI_Dropdown.dropdown_pettargetteam = gMutOnFarm:AddDropdown("dropdown_pettargetteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Tooltip = "Select pets you want to mutate!",
            Text = PetMutation.mut_ui.GetText_TargetTeam(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if _uuid then
                            if PetMutation.mut.IsAllowedPet(_uuid) then
                                table.insert(tmp_tbl, _uuid)
                            else
                                _allowed = false
                            end
                        end
                    end
                    -- loop ends
                end

                if not _allowed then
                    UI_Dropdown.dropdown_pettargetteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .targetteam))
                    Library:Notify("This pet is already selected in your other mutation teams.")
                    return
                end

                local max_allowed = 99
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_pettargetteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .targetteam))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.targetteam = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_pettargetteam:SetText(PetMutation.mut_ui.GetText_TargetTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        gMutOnFarm:AddButton({
            Text = "<font color='#ED2A00'>DeSelect All Pets</font>",
            Tooltip = "Deselects all from list",
            Func = function()
                FSettings.mut_system.targetteam = {}
                UI_Dropdown.dropdown_pettargetteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                    .targetteam))
                SaveData()
            end
        })

        -- Boosts for this team
        local ddPetMutXpTeamBoosts = gMutOnFarm:AddDropdown("ddPetMutXpTeamBoosts", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ’Š Pet Boosts",
            Tooltip = "Boosts will be applied when these teams are placed.",
            Callback = function(Values)
                FSettings.pet_mut_xpteam_boosts = {}
                for key, value in pairs(Values) do
                    FSettings.pet_mut_xpteam_boosts[key] = value
                end
                SaveData()
            end
        })


        ddPetMutXpTeamBoosts:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
        ddPetMutXpTeamBoosts:SetValue(FSettings.pet_mut_xpteam_boosts)



        local teamPetXp = gMutOnFarm:AddDropdown("_ddBoostMutpetteamwl", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ¤– Boost Selected Pets",
            Tooltip = "Select pets to target, if nothing is selected then it applies to all active pets",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                FSettings.pet_mut_xpteam_petlist = Values
                SaveData()
            end
        })

        teamPetXp:SetValues(Varz.all_pets_names_list)
        teamPetXp:SetValue(FSettings.pet_mut_xpteam_petlist)

        gMutOnFarm:AddToggle("_ddBoostMutpetxpteamtoggle", {
            Text = "ðŸš€ Enable Boosts",
            Default = FSettings.pet_mut_xpteam_boost_enabled,
            Tooltip = "If enabled boosts will be applied when teams are placed.",
            Callback = function(Value)
                FSettings.pet_mut_xpteam_boost_enabled = Value
                SaveData()
            end
        })


        local btn_reloadteamsmut = gMutOnFarm:AddButton({
            Text = "<font color='#00FF04'>â™»ï¸ Reload Teams</font>",
            Func = function()
                UpdatePetData()
                task.wait(0.3)
            end
        })

        -- Unequip
        btn_reloadteamsmut:AddButton({
            Text = "<font color='#FF0000'>UnEquip</font>",
            Func = function()
                UnEquipAllPets()
            end
        })



        gMutOnFarm:AddLabel({
            Text = "<font color='#ffff11'>------------------------------</font>",
            DoesWrap = false
        })

        ----============================  END Target Team


        ----============================ Pet Mutation Team
        UI_Dropdown.dropdown_petmutationteam = gMutOnFarm:AddDropdown("dropdown_petmutationteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = PetMutation.mut_ui.GetText_PetMutation(),
            Tooltip = "Select team that will apply mutation to your pets. Select headless horseman here. ",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end

                if not _allowed then
                    UI_Dropdown.dropdown_petmutationteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .mut_team))
                    Library:Notify("This pet is already selected in your target team.")
                    return
                end

                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_petmutationteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .mut_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.mut_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_petmutationteam:SetText(PetMutation.mut_ui.GetText_PetMutation())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })


        ---======================= Pet BaseWeight Team
        UI_Dropdown.dropdown_petbaseweightteam = gMutOnFarm:AddDropdown("dropdown_petbaseweightteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = PetMutation.mut_ui.GetText_PetBaseWeightTeam(),
            Tooltip = "Select team that will increase base weight for your pets. Select elephants here. ",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end

                if not _allowed then
                    UI_Dropdown.dropdown_petbaseweightteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .baseweight_team))
                    Library:Notify("This pet is already selected in your target team.")
                    return
                end

                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_petbaseweightteam:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .baseweight_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.baseweight_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_petbaseweightteam:SetText(PetMutation.mut_ui.GetText_PetBaseWeightTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })





        -- Boosts for this team #mutation
        local _ddBoostMutpetteam = gMutOnFarm:AddDropdown("_ddBoostMutpetteam", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ’Š Pet Boosts",
            Tooltip = "Boosts will be applied when this team is placed.",
            Callback = function(Values)
                FSettings.pet_mutation_boost_list = {}
                for key, value in pairs(Values) do
                    FSettings.pet_mutation_boost_list[key] = value
                end
                SaveData()
            end
        })


        _ddBoostMutpetteam:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
        _ddBoostMutpetteam:SetValue(FSettings.pet_mutation_boost_list)



        local teamPetmutation = gMutOnFarm:AddDropdown("_ddBoostMutpetteamwl", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "ðŸ¤– Select Pets",
            Tooltip = "Select pets to target, if nothing is selected then it applies to all active pets",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                FSettings.pet_mutation_team_list = Values
                SaveData()
            end
        })

        teamPetmutation:SetValues(Varz.all_pets_names_list)
        teamPetmutation:SetValue(FSettings.pet_mutation_team_list)

        gMutOnFarm:AddToggle("_ddBoostMutpetteamtoggle", {
            Text = "ðŸš€ Enable Boosts",
            Default = FSettings.pet_mutation_team_boost_enabled,
            Tooltip = "If enabled boosts will be applied when team is placed.",
            Callback = function(Value)
                FSettings.pet_mutation_team_boost_enabled = Value
                SaveData()
            end
        })


        --------    Put mutation team #wanted


        ----============================ Wanted Mutations

        local function _GetWantedMutationsText()
            local countw = _Helper.CountTable(FSettings.mut_system.wanted)
            local str = string.format("<font color='#F7C400'><b>ðŸ§ª Wanted Mutations</b></font>(%s)",
                countw);
            return str
        end
        gMutOnFarm:AddDivider()

        local dd_required_mut
        dd_required_mut = gMutOnFarm:AddDropdown("dd_required_mut", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = _GetWantedMutationsText(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                FSettings.mut_system.wanted = Values
                dd_required_mut:SetText(_GetWantedMutationsText())
                SaveData()
            end
        })
        -- setup values
        dd_required_mut:SetValues(GetKeyMutListUsingDir(MutationMachineManager.GetAllMutationAsKeyPair()))
        dd_required_mut:SetValue(FSettings.mut_system.wanted)

        gMutOnFarm:AddDivider()

        local function _GetTextMaxLevel()
            local str = string.format("<font color='#FF00A6'>ðŸŽHorseman LVL</font> <b>%s</b>",
                FSettings.mut_system.level);
            return str
        end

        local function _GetTextMaxLevelBaseWeight()
            local level = FSettings.mut_system.lvl_baseweight
            local str = string.format(
                "<b><font color='#FFD700'>ðŸ˜Elephant LVL </font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        local function _GetTextMaxWeightBaseWeight()
            local level = FSettings.mut_system.required_weight
            local str = string.format(
                "<b><font color='#FF00A6'>ðŸ˜Elephant Weight </font></b><font color='#00FFFF'>%s KG</font>", level)
            return str
        end

        local function GetTextMutMaxLevelCustom()
            local level = FSettings.mut_system.custom_max_level
            local str = string.format(
                "<b><font color='#7327F5'>â­MAX Lv.</font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        local inputMaxLevelCustom
        inputMaxLevelCustom = gMutOnFarm:AddInput("inputMaxLevelCustom", {
            Text = GetTextMutMaxLevelCustom(),
            Default = FSettings.mut_system.custom_max_level,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 100",
            Tooltip = "Max level override for max leveling team. Only override if needed.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Level: " .. Value, 3)
                    inputMaxLevelCustom:SetValue(tostring(FSettings.mut_system.custom_max_level))
                    return
                end

                if num > 0 then
                    FSettings.mut_system.custom_max_level = num
                    SaveData()

                    inputMaxLevelCustom:SetText(GetTextMutMaxLevelCustom())
                end
            end
        })



        local inputMaxLevel
        inputMaxLevel = gMutOnFarm:AddInput("ssinputMaxLevel", {
            Text = _GetTextMaxLevel(),
            Default = FSettings.mut_system.level,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 40",
            Tooltip = "Enter a level you want your pets before mutation.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Level: " .. Value, 3)
                    inputMaxLevel:SetValue(tostring(FSettings.mut_system.level))
                    return
                end

                if num > 0 then
                    FSettings.mut_system.level = num
                    SaveData()

                    inputMaxLevel:SetText(_GetTextMaxLevel())
                end
            end
        })


        -- Base Weight max level
        local inputMaxLevelBaseWeight
        inputMaxLevelBaseWeight = gMutOnFarm:AddInput("inputMaxLevelBaseWeight", {
            Text = _GetTextMaxLevelBaseWeight(),
            Default = FSettings.mut_system.lvl_baseweight,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 40",
            Tooltip = "Enter a level you want your pets before base weight team is added.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Level: " .. Value, 3)
                    inputMaxLevelBaseWeight:SetValue(tostring(FSettings.mut_system.lvl_baseweight))
                    return
                end

                if num > 0 then
                    FSettings.mut_system.lvl_baseweight = num
                    SaveData()

                    inputMaxLevelBaseWeight:SetText(_GetTextMaxLevelBaseWeight())
                end
            end
        })


        -- Base Weight max weight
        local inputMaxBaseWeight
        inputMaxBaseWeight = gMutOnFarm:AddInput("inputMaxBaseWeight", {
            Text = _GetTextMaxWeightBaseWeight(),
            Default = FSettings.mut_system.required_weight,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 40",
            Tooltip = "Enter a level you want your pets before base weight team is added.",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Weight: " .. Value, 3)
                    inputMaxBaseWeight:SetValue(tostring(FSettings.mut_system.required_weight))
                    return
                end

                if num > 0 then
                    FSettings.mut_system.required_weight = num
                    SaveData()

                    inputMaxBaseWeight:SetText(_GetTextMaxWeightBaseWeight())
                end
            end
        })

        gMutOnFarm:AddDivider()
        gMutOnFarm:AddToggle("togglelevelonlymode", {
            Text =
            "<b><stroke color='#008F27' thickness='1'>â¬†ï¸ <font color='#00FF3C'>Level Only Mode</font></stroke></b>",
            Default = FSettings.mut_system.only_level_mode,
            Tooltip = "Ignores all the requirements and puts system into leveling mode for any targets selected.",
            Callback = function(Value)
                FSettings.mut_system.only_level_mode = Value
                SaveData()
            end
        })
        gMutOnFarm:AddDivider()

        gMutOnFarm:AddToggle("lvlmaxmutatedpetsss", {
            Text =
            "<b><stroke color='#000000' thickness='1'>âœ¨ <font color='#00FFFF'>Max Level</font> <font color='#FF69B4'>Mutated</font></stroke></b>",
            Default = FSettings.mut_system.max_level_enable,
            Tooltip = "Levels up any pet âœ¨ that gets the mutations you wanted, <b>automatically</b>!",
            Callback = function(Value)
                FSettings.mut_system.max_level_enable = Value
                SaveData()
            end
        })

        gMutOnFarm:AddToggle("lvlmaxmutatedpetsssbatch", {
            Text =
            "<b><stroke color='#000000' thickness='1'>âš ï¸ <font color='#00FFFF'>Max Level</font> <font color='#17FFD1'>Batch</font></stroke></b>",
            Default = FSettings.mut_system.max_lvl_batch,
            Tooltip =
            "If max leveling is enabled then it uses batch mode to level. If all the pets have reached required mutations and are not max leveled.",
            Callback = function(Value)
                FSettings.mut_system.max_lvl_batch = Value
                SaveData()
            end
        })


        gMutOnFarm:AddToggle("enable_continuous_mutation", {
            Text =
            "<b><stroke color='#000000' thickness='1'>â™»ï¸ <font color='#00FFFF'>Continuous</font> <font color='#17FFD1'>Mutation</font></stroke></b>",
            Default = FSettings.mut_system.continue_enable,
            Tooltip =
            "If enabled then the loop will not restart instead pick and place new pets right away.",
            Callback = function(Value)
                FSettings.mut_system.continue_enable = Value
                SaveData()
            end
        })

        gMutOnFarm:AddToggle("singleunitmutation", {
            Text =
            "<b><stroke color='#000000' thickness='1'>ðŸ§¬ <font color='#00FFFF'>Single Pet</font> <font color='#17FFD1'>Limit</font></stroke></b>",
            Default = FSettings.mut_system.single_unit_allowed,
            Tooltip = "Limits mutations to just one pet at a time, regardless of available farm slots.",
            Callback = function(Value)
                FSettings.mut_system.single_unit_allowed = Value
                SaveData()
            end
        })

        gMutOnFarm:AddToggle("baseweight_mode", {
            Text =
            "<b><stroke color='#000000' thickness='1'>ðŸ˜ <font color='#00FFFF'>Elephant</font> <font color='#17FFD1'>Mode</font></stroke></b>",
            Default = FSettings.mut_system.is_baseweight_mode,
            Tooltip = "If enabled the system will also increase the base weight if mutation is successful.",
            Callback = function(Value)
                FSettings.mut_system.is_baseweight_mode = Value
                SaveData()
            end
        })


        gMutOnFarm:AddToggle("elephant_hot_swap", {
            Text =
            "<b><stroke color='#000000' thickness='1'>â™»ï¸ <font color='#00FFFF'>Elephant</font> <font color='#17FFD1'>Hot Swap</font></stroke></b>",
            Default = FSettings.mut_system.elephant_hotswap,
            Tooltip =
            "If enabled pets are hot swapped right away while base weight mutation is active",
            Callback = function(Value)
                FSettings.mut_system.elephant_hotswap = Value
                SaveData()
            end
        })


        gMutOnFarm:AddButton({
            Text = "ðŸŸ¢ Start Pet Mutation",
            Func = function()
                FSettings.mut_system.is_ruuning = true
                PetMutation.StartThread()
            end
        })

        gMutOnFarm:AddButton({
            Text = "ðŸ”´ Stop Pet Mutation",
            Func = function()
                PetMutation.StopThread()
            end
        })

        gMutOnFarm:AddDivider()
        gMutOnFarm:AddButton({
            Text = "âŒ Clear All Team Selections",
            Func = function()
                PetMutation.StopThread()
                FSettings.mut_system.mut_team = {}
                FSettings.mut_system.targetteam = {}
                FSettings.mut_system.xpteam = {}
                FSettings.mut_system.baseweight_team = {}
                FSettings.mut_system.maxlevel_team = {}
                SaveData()
                PetMutation.mut_ui.UpdateTeamsDropdowns()
            end
        })

        gMutOnFarm:AddDivider()
        gMutOnFarm:AddDivider()
        --== Experiments section
        local function _GetTextTurboLevelInputText()
            local level = FSettings.mut_system.turbo_max_level
            local str = string.format(
                "<b><font color='#00D7FF'>Minimum Level: </font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        gMutOnFarm:AddLabel({
            Text = "--- <b><font color='#FF00A6'>ðŸ§ª Experiments</font> <font color='#17FFD1'>Lab ðŸ§¬</font></b> ---",
            DoesWrap = false
        })

        gMutOnFarm:AddLabel({
            Text =
                "ðŸ’¡ Intelligent team switching:\n" ..
                "âš¡ XP team below minimum level, max-level team above.\n" ..
                "ðŸš€ Speeds up leveling efficiently.\n" ..
                "ðŸ”¹ Works with Horseman & Elephant requirements.",
            DoesWrap = true
        })


        -- Base Weight max weight
        local inputMinimumTurboLevel
        inputMinimumTurboLevel = gMutOnFarm:AddInput("inputMinimumTurboLevel", {
            Text = _GetTextTurboLevelInputText(),
            Default = FSettings.mut_system.turbo_max_level,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 40",
            Tooltip = "Set the level at which the system switches from XP team to max-level team.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Level: " .. Value, 3)
                    inputMinimumTurboLevel:SetValue(tostring(FSettings.mut_system.turbo_max_level))
                    return
                end

                if num > 0 then
                    FSettings.mut_system.turbo_max_level = num
                    SaveData()

                    inputMinimumTurboLevel:SetText(_GetTextTurboLevelInputText())
                end
            end
        })


        gMutOnFarm:AddToggle("intelligentteams", {
            Text =
                "<b><stroke color='#000000' thickness='1'>ðŸ§ª <font color='#00FFFF'>Enable</font> " ..
                "<font color='#17FFD1'>Intelligent Teams</font></stroke></b>",
            Default = FSettings.mut_system.turbo_xp_teams,
            Tooltip =
            "Enable to let the system intelligently boost leveling and increase base weight when mutations succeed.",
            Callback = function(Value)
                FSettings.mut_system.turbo_xp_teams = Value
                SaveData()
            end
        })


        gMutOnFarm:AddDivider()

        ----============================ Filler Team #fill
        UI_Dropdown.dropdown_petfiller_team = gMutOnFarm:AddDropdown("dropdown_petfiller_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = PetMutation.mut_ui.GetText_FillerTeam(),
            Tooltip =
            "Filler Team, Any pets selected here will be used to fill in any missing slots in your teams.Won't work with Continuous Mode, Won't work if single mode active, won't work on mutation stages. Only works for XP and Max leveling.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)

                        if PetMutation.mut.IsNotInTargetTeamPet(_uuid) then
                            table.insert(tmp_tbl, _uuid)
                        else
                            _allowed = false
                        end
                    end
                    -- loop ends
                end


                if not _allowed then
                    UI_Dropdown.dropdown_petfiller_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .filler_team))
                    Library:Notify("This pet is already selected in your other target team.")
                    return
                end

                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_petfiller_team:SetValue(ConvertUUIDToPetNamesPairs(FSettings.mut_system
                        .filler_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.mut_system.filler_team = tmp_tbl
                    SaveData()
                    UI_Dropdown.dropdown_petfiller_team:SetText(PetMutation.mut_ui.GetText_FillerTeam())
                end
            end
        })

        ----============================  END Filler Team
        gMutOnFarm:AddDivider()

        gMutOnFarm:AddSpacer(300)
    end
    ---------------------------------------------------
    -------- Mutation Pet End
    ---------------------------------------------------






    ---------------------------------------------------
    -------- Jungle Event
    ---------------------------------------------------
    if eventJungle then
        local event_name1 = "Seed Stages Event"
        UI_LABELS.lbl_jungle_stats = eventJungle:AddLabel({
            Text = "â³ Waiting for stats...",
            DoesWrap = true
        })

        eventJungle:AddDivider()
        -- Progress
        UI_LABELS.lbl_jungle_information = eventJungle:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        -- info
        eventJungle:AddLabel({
            Text = "â„¹ï¸ " ..
                event_name1 ..
                " <font color='#FFD700'>Skips Ascension-required items. Pausing as a other events occur. </font>",
            DoesWrap = true
        })
        eventJungle:AddDivider()
        -- Enable or disable
        eventJungle:AddToggle("seedstagesevent", {
            Text = "âš¡ " .. event_name1,
            Default = FOtherSettings.is_auto_jungle,
            Tooltip = "Auto submits and collects fruits.",
            Callback = function(Value)
                FOtherSettings.is_auto_jungle = Value
                SaveDataOther()
                Library:Notify(event_name1 .. " " .. (Value and "Enabled" or "Disabled"), 2)
            end
        })



        -- Auto Submit Plants
        local jungle_autosubmitPlants = eventJungle:AddDropdown("auto_submitplants", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "Seed Stages <font color='#32CD32'>Seeds</font>",
            Tooltip = "Select plants to submit or collect.",
            Changed = function(newSelection)
                FOtherSettings.jungle_auto_plants_list = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.jungle_auto_plants_list[key] = value
                end
                SaveDataOther()
            end
        })



        local filter_plants = GetKeyValuesFromList(all_plants_list)
        local plants_filtered = {}
        for _, _pName in ipairs(filter_plants) do
            if string.find(_pName, "Evo", 1, true) then
                table.insert(plants_filtered, _pName)
            end
        end
        jungle_autosubmitPlants:SetValues(plants_filtered)
        jungle_autosubmitPlants:SetValue(FOtherSettings.jungle_auto_plants_list)

        eventJungle:AddDivider()

        eventJungle:AddLabel({
            Text = "ðŸ›’ <b>Shops</b>",
            DoesWrap = true
        })


        -- Seed Shop
        local jungle_seed_shop = eventJungle:AddDropdown("jungle_seed_shop", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = "Seed <font color='#32CD32'>Stages</font>",
            Tooltip = "Select Items to buy",
            Changed = function(newSelection)
                FOtherSettings.jungle_seed_stages1 = {}
                for key, value in pairs(newSelection) do
                    FOtherSettings.jungle_seed_stages1[key] = value
                end
                SaveDataOther()
            end
        })




        jungle_seed_shop:SetValues(GetKeyValuesFromList(Varz.JungleSeedStage1))
        jungle_seed_shop:SetValue(FOtherSettings.jungle_seed_stages1)

        eventJungle:AddDivider()
        eventJungle:AddDivider()
        eventJungle:AddDivider()
        eventJungle:AddDivider()
        eventJungle:AddDivider()
        eventJungle:AddDivider()
    end



    ---------------------------------------------------
    -------- END Jungle Event
    ---------------------------------------------------





    ----------------------------------------------
    -------- Mutation Machine #mutui
    ----------------------------------------------
    do
        UI_LABELS.lbl_mutation_machine_status = gPetMutationMachine:AddLabel({
            Text = "ðŸ”´ Stopped",
            DoesWrap = true
        })




        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddLabel({
            Text = "<font color='#ffff11'>------------------------------</font>",
            DoesWrap = false
        })
        ----============================ Support Team
        UI_Dropdown.dropdown_support_team = gPetMutationMachine:AddDropdown("mut_support_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = MutationMachineManager.UI.GetText_LevelingTeam(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if _uuid then
                            table.insert(tmp_tbl, _uuid)
                        end
                    end
                    -- loop ends
                end
                local max_allowed = GetMaxPetCapacity() - 1
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_support_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings
                        .mut_support_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FOtherSettings.mut_support_team = tmp_tbl
                    SaveDataOther()
                    UI_Dropdown.dropdown_support_team:SetText(MutationMachineManager.UI.GetText_LevelingTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })

        ----============================  END Support Team


        ----============================ Target Team
        UI_Dropdown.dropdown_target_team = gPetMutationMachine:AddDropdown("dropdown_target_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = MutationMachineManager.UI.GetText_TargetTeam(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if _uuid then
                            if MutationMachineManager.IsAllowedTargetTeamPet(_uuid) then
                                table.insert(tmp_tbl, _uuid)
                            else
                                _allowed = false
                            end
                        end
                    end
                    -- loop ends
                end

                if not _allowed then
                    UI_Dropdown.dropdown_target_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings
                        .mut_target_pets_uuid))
                    Library:Notify("This pet is already selected in your other mutation teams.")
                    return
                end

                local max_allowed = 99
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_target_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings
                        .mut_target_pets_uuid))
                    Library:Notify("Team size maxed", 2)
                else
                    FOtherSettings.mut_target_pets_uuid = tmp_tbl
                    SaveDataOther()
                    UI_Dropdown.dropdown_target_team:SetText(MutationMachineManager.UI.GetText_TargetTeam())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })


        -- Boosts for this team
        local _ddBoostleveling = gPetMutationMachine:AddDropdown("_ddBoostleveling", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 6,
            Text = "ðŸ’Š Pet Boosts",
            Tooltip = "Boosts are applied to both teams (Leveling, Target) when teams is placed by the system.",
            Callback = function(Values)
                FSettings.mutation_boost_level_team = {}
                for key, value in pairs(Values) do
                    FSettings.mutation_boost_level_team[key] = value
                end

                SaveData()
            end
        })


        _ddBoostleveling:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
        _ddBoostleveling:SetValue(FSettings.mutation_boost_level_team)

        gPetMutationMachine:AddToggle("boostleveltargetteammut", {
            Text = "ðŸš€ Enable Boosts",
            Default = FSettings.mutation_boost_level_team_enabled,
            Tooltip = "If enabled boosts will be applied when team is placed.",
            Callback = function(Value)
                FSettings.mutation_boost_level_team_enabled = Value
                SaveData()
            end
        })

        gPetMutationMachine:AddLabel({
            Text = "<font color='#ffff11'>------------------------------</font>",
            DoesWrap = false
        })

        ----============================  END Target Team




        ----============================ Mutation cooldown Team
        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddLabel({
            Text =
            '<font color="#FFFFFF"><b>â„¹ï¸ Cooldown Team:</b></font> <font color="#DDDDDD">This team will be placed when the machine is running to reduce its cooldown timer. [Ignored if empty]</font>',
            DoesWrap = true
        })
        UI_Dropdown.dropdown_mut_cd_team = gPetMutationMachine:AddDropdown("dropdown_mut_cd_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = MutationMachineManager.UI.GetText_TeamCooldown(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if _uuid then
                            table.insert(tmp_tbl, _uuid)
                        end
                    end
                    -- loop ends
                end
                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_mut_cd_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings
                        .mut_mutation_machineteam))
                    Library:Notify("Team size maxed", 2)
                else
                    FOtherSettings.mut_mutation_machineteam = tmp_tbl
                    SaveDataOther()
                    UI_Dropdown.dropdown_mut_cd_team:SetText(MutationMachineManager.UI.GetText_TeamCooldown())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })


        -- Boosts for this team
        local _ddBoostMachineCd = gPetMutationMachine:AddDropdown("_ddBoostMachineCd", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 6,
            Text = "ðŸ’Š Pet Boosts",
            Tooltip = "Boosts are applied when teams is placed by the system.",
            Callback = function(Values)
                FSettings.mutation_boost_cd_team = {}
                for key, value in pairs(Values) do
                    FSettings.mutation_boost_cd_team[key] = value
                end

                SaveData()
            end
        })


        _ddBoostMachineCd:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
        _ddBoostMachineCd:SetValue(FSettings.mutation_boost_cd_team)

        gPetMutationMachine:AddToggle("boostteamtteammutcd", {
            Text = "ðŸš€ Enable Boosts",
            Default = FSettings.mutation_boost_cd_team_enabled,
            Tooltip = "If enabled boosts will be applied when team is placed.",
            Callback = function(Value)
                FSettings.mutation_boost_cd_team_enabled = Value
                SaveData()
            end
        })


        ----============================  END Mutation cooldown Team

        ----============================ Mutation Claim Pet Team
        gPetMutationMachine:AddLabel({
            Text = "<font color='#ffff11'>------------------------------</font>",
            DoesWrap = false
        })
        gPetMutationMachine:AddLabel({
            Text =
            '<font color="#FFFFFF"><b>â„¹ï¸ Pre-Claim Team:</b></font> <font color="#DDDDDD">This team will be placed just before the system claims the pet. [Ignored if empty]</font>',
            DoesWrap = true
        })
        UI_Dropdown.dropdown_claimpet_team = gPetMutationMachine:AddDropdown("dropdown_claimpet_team", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = MutationMachineManager.UI.GetText_TeamClaimPet(),
            Callback = function(Values)
                warn("Updated called dropdown_claimpet_team")
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        if _uuid then
                            table.insert(tmp_tbl, _uuid)
                        end
                    end
                    -- loop ends
                end
                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.dropdown_claimpet_team:SetValue(ConvertUUIDToPetNamesPairs(FOtherSettings
                        .mut_claimpet_team))
                    Library:Notify("Team size maxed", 2)
                else
                    FOtherSettings.mut_claimpet_team = tmp_tbl
                    SaveDataOther()
                    UI_Dropdown.dropdown_claimpet_team:SetText(MutationMachineManager.UI.GetText_TeamClaimPet())
                    --Library:Notify("Team Updated", 2)
                end
            end
        })



        -- Boosts for this team
        local _ddClaimBoost = gPetMutationMachine:AddDropdown("_ddClaimBoost", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 6,
            Text = "ðŸ’Š Pet Boosts",
            Tooltip = "Boosts are applied when team is placed by the system.",
            Callback = function(Values)
                FSettings.mutation_boost_team_claim = {}
                for key, value in pairs(Values) do
                    FSettings.mutation_boost_team_claim[key] = value
                end

                SaveData()
            end
        })

        _ddClaimBoost:SetValues(GetKeyValuesFromList(MonsterBoostManager.boosts_list))
        _ddClaimBoost:SetValue(FSettings.mutation_boost_team_claim)

        gPetMutationMachine:AddToggle("boostclaimteammut", {
            Text = "ðŸš€ Enable Boosts",
            Default = FSettings.mutation_boost_claim_enabled,
            Tooltip = "If enabled boosts will be applied when team is placed.",
            Callback = function(Value)
                FSettings.mutation_boost_claim_enabled = Value
                SaveData()
            end
        })

        gPetMutationMachine:AddLabel({
            Text = "<font color='#ffff11'>------------------------------</font>",
            DoesWrap = false
        })



        gPetMutationMachine:AddDivider();



        ----============================  END Mutation Claim Pet Team

        -- Apply defaults
        MutationMachineManager.UI.UpdateTeamsDropdowns()




        ----============================ Wanted Mutations
        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddLabel({
            Text = "<font color='#00BFFF'><b>â„¹ï¸ Select mutations you want to apply to your pets.</b></font>",
            DoesWrap = true
        })
        local dropdown_target_mutations_list
        dropdown_target_mutations_list = gPetMutationMachine:AddDropdown("dropdown_target_mutations_list", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = MutationMachineManager.UI.GetText_MutationList(),
            Callback = function(Values)
                if Values == nil then
                    return
                end
                FOtherSettings.mut_target_mutations = {}
                for Value, Selected in pairs(Values) do
                    FOtherSettings.mut_target_mutations[Value] = true
                end
                dropdown_target_mutations_list:SetText(MutationMachineManager.UI.GetText_MutationList())
                SaveDataOther()
            end
        })
        -- setup values
        dropdown_target_mutations_list:SetValues(GetKeyMutListUsingDir(MutationMachineManager.AllMutationsList))
        dropdown_target_mutations_list:SetValue(FOtherSettings.mut_target_mutations)

        gPetMutationMachine:AddDivider()

        gPetMutationMachine:AddToggle("leveltomaxmutation", {
            Text =
            "<b><stroke color='#000000' thickness='1'>ðŸŒˆ <font color='#00FFFF'>Max Level</font> <font color='#FF69B4'>Mutated</font></stroke></b>",
            Default = FOtherSettings.mut_max_level_successfulpets,
            Tooltip = "Levels up any pet âœ¨ that gets the mutations you wanted, <b>automatically</b>!",
            Callback = function(Value)
                FOtherSettings.mut_max_level_successfulpets = Value
                SaveDataOther()
            end
        })

        gPetMutationMachine:AddToggle("batch_leveling_mode", {
            Text =
            "<b><stroke color='#000000' thickness='1'>ðŸ”„ <font color='#87CEEB'>Batch</font> <font color='#90EE90'>Leveling</font></stroke></b>",
            Default = FOtherSettings.mut_batch_process_enable,
            Tooltip =
            "When enabled, levels a full team of pets. The process will restart to pick a new pet each time one reaches the required level.",
            Callback = function(Value)
                FOtherSettings.mut_batch_process_enable = Value
                SaveDataOther()
            end
        })



        ----============================  END Mutation Claim Pet Team




        gPetMutationMachine:AddButton({
            Text = "ðŸŸ¢ Start Mutation System",
            Func = function()
                MutationMachineManager.StartThread()
            end
        })

        gPetMutationMachine:AddButton({
            Text = "ðŸ”´ Stop Mutation System",
            Func = function()
                MutationMachineManager.StopThread()
            end
        })




        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddDivider()
        gPetMutationMachine:AddDivider()



        local Button1 = gPetMutationMachine:AddButton({
            Text = "Submit Held Pet",
            Func = function()
                MutationMachineManager.SubmitHeldPet()
            end
        })

        local Button3 = gPetMutationMachine:AddButton({
            Text = "Claim Mutated Pet",
            Func = function()
                MutationMachineManager.ClaimMutatedPet()
            end
        })

        local Button2 = gPetMutationMachine:AddButton({
            Text = "Start Machine",
            Func = function()
                MutationMachineManager.StartMachine()
            end
        })

        gPetMutationMachine:AddSpacer(30)
    end
    ---------------------------------------------------
    -------- Mutation Machine End
    ---------------------------------------------------




    ---------------------------------------------------
    -------- FALL Event
    ---------------------------------------------------
    local hasShops = false
    if gFallEvent then
        local event_name1 = "Christmas Event"
        UI_LABELS.lbl_fallevent_stats = gFallEvent:AddLabel({
            Text = "â³ Waiting to start with delay.",
            DoesWrap = true
        })

        gFallEvent:AddDivider()
        -- Progress
        UI_LABELS.lbl_fallevent_progress = gFallEvent:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        -- Required fruits
        UI_LABELS.lbl_fallevent_required_fruits = gFallEvent:AddLabel({
            Text = "-",
            DoesWrap = true
        })


        -- total submits
        UI_LABELS.lbl_fallevent_fall_bloom = gFallEvent:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        -- info
        gFallEvent:AddLabel({
            Text = "â„¹ï¸ " ..
                event_name1 ..
                " <font color='#FFD700'>Skips Ascension-required items. Pausing as a hatch is about to occur. </font>",
            DoesWrap = true
        })
        gFallEvent:AddDivider()
        -- Enable or disable Fall market event

        gFallEvent:AddToggle("fastcollect", {
            Text = "âœ¨ <font color='#E60086'>Fast Collect</font>",
            Default = FOtherSettings.is_fall_event_fastmode,
            Tooltip = "If enabled Collects fruits really fast.",
            Callback = function(Value)
                FOtherSettings.is_fall_event_fastmode = Value
                SaveDataOther()
            end
        })
        gFallEvent:AddDivider()
        gFallEvent:AddToggle("tEventFall", {
            Text = "âš¡ " .. event_name1,
            Default = FOtherSettings.is_fall_event_running,
            Tooltip = "Enable or Disable event",
            Callback = function(Value)
                FOtherSettings.is_fall_event_running = Value
                SaveDataOther()
                Library:Notify(event_name1 .. " " .. (Value and "Enabled" or "Disabled"), 2)
            end
        })



        -- gFallEvent:AddToggle("auto_reaper", {
        --     Text = "âœ¨ Auto Ritual Platform",
        --     Default = FSettings.halloween.auto_reaper,
        --     Tooltip = "Ritual Platform, auto submit and collect fruits.",
        --     Callback = function(Value)
        --         FSettings.halloween.auto_reaper = Value
        --         SaveData()
        --     end
        -- })


        gFallEvent:AddDivider()


        -- Shops
        local ev_shops = _EventShops.HalloweenShopData

        gFallEvent:AddLabel({
            Text = "ðŸ›’ " .. event_name1 .. " <b>Shops</b>",
            DoesWrap = true
        })

        for _shopName, shop_items in pairs(ev_shops) do
            -- Fall Festival Cosmetics Shop

            if not string.find(_shopName, "Safari") then
                -- continue
            end

            local colorsx = _Helper.StringToColor3(_shopName)
            local _shopx = gFallEvent:AddDropdown(_shopName .. "shoppinh", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 10,
                Text = "<font color='" .. colorsx .. "'>" .. _shopName .. "</font>",
                Tooltip = "Select Items to buy",
                Changed = function(newSelection)
                    if newSelection == nil then return end
                    FSettings.halloween.shops[_shopName] = newSelection
                    SaveData()
                end
            })

            _shopx:SetValues(shop_items)
            _shopx:SetValue(FSettings.halloween.shops[_shopName] or {})
        end

        -- Shops section
        if hasShops then
            gFallEvent:AddLabel({
                Text = "ðŸ›’ <b>Shops</b>",
                DoesWrap = true
            })
            -- Shops for this event
            -- Fall Festival Pets
            local xfall_pet_shop = gFallEvent:AddDropdown("xfall_pet_shop", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 10,
                Text = "Fall Festival <font color='#FF69B4'>Pets</font>",
                Tooltip = "Select Items to buy",
                Changed = function(newSelection)
                    FOtherSettings.fall_pets_shop = {}
                    for key, value in pairs(newSelection) do
                        FOtherSettings.fall_pets_shop[key] = value
                    end
                    SaveDataOther()
                end
            })

            -- Fall Festival Seeds
            local xfall_seed_shop = gFallEvent:AddDropdown("xfall_seed_shop", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 5,
                Text = "Fall Festival <font color='#32CD32'>Seeds</font>",
                Tooltip = "Select Items to buy",
                Changed = function(newSelection)
                    FOtherSettings.fall_seeds_shop = {}
                    for key, value in pairs(newSelection) do
                        FOtherSettings.fall_seeds_shop[key] = value
                    end
                    SaveDataOther()
                end
            })



            -- Fall Festival Gears Shop
            local xfall_gear_shop = gFallEvent:AddDropdown("xfall_gear_shop", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 6,
                Text = "Fall Festival <font color='#FFA500'>Gears</font>",
                Tooltip = "Select Items to buy",
                Changed = function(newSelection)
                    FOtherSettings.fall_gear_shop = {}
                    for key, value in pairs(newSelection) do
                        FOtherSettings.fall_gear_shop[key] = value
                    end
                    SaveDataOther()
                end
            })


            -- Fall Festival Cosmetics Shop
            local xfall_cosmetic_shop = gFallEvent:AddDropdown("xfall_cosmetic_shop", {
                Values = {},
                Default = {},
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 5,
                Text = "Fall Festival <font color='#8A2BE2'>Cosmetics</font>",
                Tooltip = "Select Items to buy",
                Changed = function(newSelection)
                    FOtherSettings.fall_cosmetic_shop = {}
                    for key, value in pairs(newSelection) do
                        FOtherSettings.fall_cosmetic_shop[key] = value
                    end
                    SaveDataOther()
                end
            })



            xfall_pet_shop:SetValues(GetKeyValuesFromList(Varz.FallEvent_Pet_Shop_ItemList))
            xfall_seed_shop:SetValues(GetKeyValuesFromList(Varz.FallEvent_Seeds_Shop_ItemList))
            xfall_cosmetic_shop:SetValues(GetKeyValuesFromList(Varz.FallEvent_Cosmetic_Shop_ItemList))
            xfall_gear_shop:SetValues(GetKeyValuesFromList(Varz.FallEvent_Gear_Shop_ItemList))

            xfall_pet_shop:SetValue(FOtherSettings.fall_pets_shop)
            xfall_seed_shop:SetValue(FOtherSettings.fall_seeds_shop)
            xfall_cosmetic_shop:SetValue(FOtherSettings.fall_cosmetic_shop)
            xfall_gear_shop:SetValue(FOtherSettings.fall_gear_shop)
        end


        -- total Required Fruits
        UI_LABELS.lbl_fallevent_fruit_ls = gFallEvent:AddLabel({
            Text = "",
            DoesWrap = true
        })

        gFallEvent:AddSpacer(120)
    end
    ---------------------------------------------------
    -------- END FALL Event
    ---------------------------------------------------


    ---------------------------------------------------
    -------- FALL Event Quest Line
    ---------------------------------------------------
    if FallQuestui then
        UI_LABELS.lbl_questline_status = FallQuestui:AddLabel({
            Text = "Not running",
            DoesWrap = true
        })

        FallQuestui:AddDivider()
        -- info
        UI_LABELS.lbl_questline_info = FallQuestui:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        FallQuestui:AddDivider()
        -- info
        FallQuestui:AddLabel({
            Text =
            "â„¹ï¸ Automatically performs most fall activities and pauses if any ongoing tasks are in progress, such as <font color='#00BFFF'>hatching</font>. <font color='#FFD700'>Skips items that require Ascension</font> and pauses <font color='#FF4500'>just before a hatch occurs</font> to avoid conflicts.",
            DoesWrap = true
        })

        local max_reolldrop = FallQuestui:AddDropdown("max_reolldrop", {
            Values = {},
            Default = {},
            Multi = false,
            Text = "ðŸ’° Maximum Reroll Amount",
            Tooltip = "Select the maximum amount to reroll during Fall activities",
            Searchable = true,
            MaxVisibleDropdownItems = 7,
            Changed = function(newSelection)
                if newSelection ~= nil then
                    FOtherSettings.quest_recoll_max_cost = newSelection
                end
                SaveDataOther()
            end
        })


        -- Populate
        max_reolldrop:SetValues(EventQuestsManager.PriceListReroll)
        max_reolldrop:SetValue(FOtherSettings.quest_recoll_max_cost)

        FallQuestui:AddDivider()
        -- Enable or disable Fall market event
        local ftitle1 = "Auto Fall Activity"
        FallQuestui:AddToggle("enablequestlinetogglex", {
            Text = "âš¡ " .. ftitle1,
            Default = FOtherSettings.is_fall_questline_auto,
            Tooltip = "Enable or disable automatic Fall activities",
            Callback = function(Value)
                FOtherSettings.is_fall_questline_auto = Value
                SaveDataOther()
                Library:Notify(ftitle1 .. " " .. (Value and "Enabled" or "Disabled"), 2)
            end
        })

        FallQuestui:AddDivider()
        --reroll
        local ftitle2 = "Auto Reroll"
        FallQuestui:AddToggle("enableautoreolltoggle", {
            Text = "âš¡ðŸ’° " .. ftitle2,
            Default = FOtherSettings.is_fall_questline_reroll,
            Tooltip = "Auto Reroll activities",
            Callback = function(Value)
                FOtherSettings.is_fall_questline_reroll = Value
                SaveDataOther()
                Library:Notify(ftitle2 .. " " .. (Value and "Enabled" or "Disabled"), 2)
            end
        })


        FallQuestui:AddDivider()
        FallQuestui:AddDivider()
        FallQuestui:AddDivider()
        FallQuestui:AddDivider()
        FallQuestui:AddDivider()
        FallQuestui:AddDivider()
    end
    ------------------------ Quest END













    ---------------------------------------------------------
    --- Auto Ascension
    ---------------------------------------------------


    -- label for status
    UI_LABELS.lbl_ascenstats = GroupBoxAutoAscension:AddLabel({
        Text = "Current status",
        DoesWrap = true
    })

    GroupBoxAutoAscension:AddDivider()

    GroupBoxAutoAscension:AddLabel({
        Text =
        "âš ï¸ Auto Ascension: Plants, collects fruits, and claims Ascension for you.\nPauses if hatching is in progress.\nAutomatically removes <font color='#4da6ff'>[Frozen,Tempestuous]</font>, then applies <font color='#3399cc'>[Windstruck]</font> or <font color='#66ccff'>[Chilled]</font> after removing <font color='#4da6ff'>[Frozen]</font>.",
        DoesWrap = true
    })

    -- Current Requirements
    UI_LABELS.lbl_ascen_current_requirement = GroupBoxAutoAscension:AddLabel({
        Text = "",
        DoesWrap = true
    })

    -- cooldown
    UI_LABELS.lbl_ascen_cd = GroupBoxAutoAscension:AddLabel({
        Text = "",
        DoesWrap = true
    })


    if FOtherSettings.auto_ascension then
        UpdateAscenStats("ðŸŸ¢ Ascension is active")
    else
        UpdateAscenStats("âŒ Ascension not active")
    end

    GroupBoxAutoAscension:AddDivider()
    local inputasen_maxseed
    local maxseed_default_text = "ðŸŒ± Max <font color='#7CFC00'>Seeds</font> to place"
    inputasen_maxseed = GroupBoxAutoAscension:AddInput("asen_seedcount", {
        Text = maxseed_default_text,
        Default = FOtherSettings.ascension_max_seeds,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Enter seed count here",
        Tooltip = "Places seeds when you are missing plant.",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)

            if not num or num <= 0 then
                Library:Notify("Invalid Seed Count: " .. Value, 3)
                inputasen_maxseed:SetValue(tostring(FOtherSettings.ascension_max_seeds))
                return
            end

            if num > 0 then
                -- Update time if valid
                FOtherSettings.ascension_max_seeds = num
                SaveDataOther()
                inputasen_maxseed:SetText("âœ… <font color='#00FF00'>Seeds Count Updated</font>")
                task.wait(1)
                inputasen_maxseed:SetText(maxseed_default_text)
            end
        end
    })

    GroupBoxAutoAscension:AddDivider()
    GroupBoxAutoAscension:AddToggle("fastascens", {
        Text = "ðŸ”´ Spam Ascension",
        Default = FSettings.fast_ascen,
        Tooltip = "If enabled. Spams claim button when its ready",
        Callback = function(Value)
            FSettings.fast_ascen = Value
            SaveData()
        end
    })

    GroupBoxAutoAscension:AddDivider()
    GroupBoxAutoAscension:AddToggle("toogleAutoA", {
        Text = "âš¡ Auto Ascension",
        Default = FOtherSettings.auto_ascension,
        Tooltip = "Enable or Disable Ascension",
        Callback = function(Value)
            FOtherSettings.auto_ascension = Value
            SaveDataOther()
            Library:Notify("Auto Ascension " .. (Value and "Enabled" or "Disabled"), 1)
        end
    })
    GroupBoxAutoAscension:AddDivider()


    ---------------------------------------------------------
    --- END Auto Ascension
    ---------------------------------------------------------
end

-- Call the function to build the UI
MEventsUi()
PetMutation.mut_ui.UpdateTeamsDropdowns()


-- Create the Pet System ui
local function UiPetsSideTab()
    local PetsTab = Window:AddTab({
        Name = "<font color='#FFD700'>Pet Manager</font>",                                        -- gold title
        Description = "<font color='#00FFFF'>Feed, grow, and manage your pets with ease.</font>", -- cyan description
        Icon = "rabbit"
    })

    ---------------------------------------------------
    -- ## Pet Feeding UI
    ---------------------------------------------------
    local PetFeedingGroup = PetsTab:AddLeftGroupbox("Pet Feeding System", "hand-platter")
    local petLevelGroup = PetsTab:AddRightGroupbox(
        "<font color='#FFD700'>Pet </font><font color='#00FFFF'>Level-Up</font>", "bone")

    local marmotUI = PetsTab:AddLeftGroupbox("Pet Marmot", "circle-arrow-out-up-right")
    local ChubbyChipmunkUI = PetsTab:AddRightGroupbox("Chubby Chipmunk", "nut")

    local pandaUi = PetsTab:AddLeftGroupbox("Red Panda", "panda")

    local petEleGroup = nil

    -- #unlock feature
    local valid_n = {
        ["BlazeTopUpPet1"] = true,
        ["BlazeTopUpPet2"] = true,
        ["HexaFlame99"] = true,
        ["DobroeUtroOleg"] = true,
        ["topguy713"] = true,
        ["tinybloxi33"] = true,
        ["rizzyt9"] = true,
        ["0SuperAlpha0"] = true,
        ["blazetopup"] = true,
    }
    if valid_n[_S.LocalPlayer.Name] or Varz.GetCheckIfPro() then
        petEleGroup = PetsTab:AddRightGroupbox(
            "<font color='#FF0062'>Elephant </font><font color='#00FFFF'>Boost</font>", "sunrise")
    end

    ---========= Elephant boost #eleui
    if petEleGroup then
        petEleGroup:AddDivider()
        UI_LABELS.lbl_elephant_booster_status = petEleGroup:AddLabel({
            Text = "âšª Status",
            DoesWrap = true
        })


        petEleGroup:AddLabel({
            Text = "ðŸ¦£ <b><font color='#FFD700'>Apply Boost â€” Step by Step</font></b>:\n" ..
                "1. Place the target unit (<font color='#00FFFF'>Age 50</font> â€” or <font color='#FF69B4'>Age 40</font> for <font color='#FFA500'>Premium Elephants</font>).\n" ..
                "2. Place up to <font color='#00FF00'>7 elephants</font> and pick them in Select Pets list! .\n" ..
                "3. Select the <b><font color='#00FFFF'>Chew</font></b> boost.\n" ..
                "4. Set the amount to <b><font color='#FF4500'>2</font></b> (tested to work).\n" ..
                "5. Press the <b><font color='#00FF00'>Apply</font></b> button to activate.\n\n" ..
                "âš ï¸ <font color='#FF5555'><b>Disable pick+place, Events and hatching</b></font> for best results!",
            DoesWrap = true
        })

        local petBoostActiveselectpets = petEleGroup:AddDropdown("petBoostActiveselectpets", {
            Values = {},
            Default = {},
            Multi = true,
            Text = "âš¡ Choose Boost",
            Searchable = true,
            Tooltip = "Select a pet boost to use.",
            MaxVisibleDropdownItems = 10,
            Changed = function(newSelection)
                if not newSelection then
                    return
                end
                FSettings.elephant.boost_list = newSelection
                SaveData()
            end
        })

        -- Get all gear items and add a placeholder at the top
        local boost_lsx = InventoryManager.Gear.GetGearBoosts()

        -- Set dropdown values and default selection
        petBoostActiveselectpets:SetValues(boost_lsx)
        petBoostActiveselectpets:SetValue(FSettings.elephant.boost_list)




        UI_Dropdown.PetBoostSelectDropdown = petEleGroup:AddDropdown("PetBoostSelectDropdown", {
            Values = {},
            Default = {},
            Multi = true,
            Text = "ðŸ¦œ Select Pets",
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.elephant.pet_list = {}

                for Value, Selected in pairs(newSelection) do
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(FSettings.elephant.pet_list, _uuid)
                    end
                end

                SaveData()
            end
        })

        petEleGroup:AddDivider()

        petEleGroup:AddButton("Reload Teams", function()
            UpdatePetData()
        end)


        petEleGroup:AddDivider()

        local function GetTextBoostBeforePick_Text()
            local level = FSettings.elephant.delay_before_unequip
            local str = string.format(
                "<b><font color='#FFD700'>B4 UnEquip </font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        local function GetTextBoostBeforePlace_Text()
            local level = FSettings.elephant.delay_before_place
            local str = string.format(
                "<b><font color='#FFD700'>B4 Equip </font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end

        local function GetTextBoostAmount_Text()
            local level = FSettings.elephant.boost_amount
            local str = string.format(
                "<b><font color='#FFAB00'>Amount Per Pet </font></b><font color='#00FFFF'>%s</font>", level)
            return str
        end


        local inputbefore_pick_boost
        inputbefore_pick_boost = petEleGroup:AddInput("inputbefore_pick_boost", {
            Text = GetTextBoostBeforePick_Text(),
            Default = FSettings.elephant.delay_before_unequip,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 0.1",
            Tooltip = "Delay before pet is unequipped",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Number: " .. Value, 3)
                    inputbefore_pick_boost:SetValue(tostring(FSettings.elephant.delay_before_unequip))
                    return
                end

                if num > 0 then
                    FSettings.elephant.delay_before_unequip = num
                    SaveData()
                    inputbefore_pick_boost:SetText(GetTextBoostBeforePick_Text())
                end
            end
        })


        local inputbefore_place_boost
        inputbefore_place_boost = petEleGroup:AddInput("inputbefore_place_boost", {
            Text = GetTextBoostBeforePlace_Text(),
            Default = FSettings.elephant.delay_before_place,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 0.1",
            Tooltip = "Delay before pet is equipped",
            Callback = function(Value)
                local num = ParseWeightNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Number: " .. Value, 3)
                    inputbefore_place_boost:SetValue(tostring(FSettings.elephant.delay_before_place))
                    return
                end

                if num > 0 then
                    FSettings.elephant.delay_before_place = num
                    SaveData()
                    inputbefore_place_boost:SetText(GetTextBoostBeforePlace_Text())
                end
            end
        })




        local inputbefore_place_boostamount
        inputbefore_place_boostamount = petEleGroup:AddInput("inputbefore_place_boostamount", {
            Text = GetTextBoostAmount_Text(),
            Default = FSettings.elephant.boost_amount,
            Numeric = true,
            AllowEmpty = true,
            Finished = true,
            ClearTextOnFocus = false,
            Placeholder = "e.g. 0.1",
            Tooltip = "Boosts per pet. if you enter 3 it will apply x3 to same pet.",
            Callback = function(Value)
                local num = ParseWholeNumber(Value)

                if not num or num <= 0 then
                    Library:Notify("Invalid Number: " .. Value, 3)
                    inputbefore_place_boostamount:SetValue(tostring(FSettings.elephant.boost_amount))
                    return
                end

                if num > 0 then
                    FSettings.elephant.boost_amount = num
                    SaveData()
                    inputbefore_place_boostamount:SetText(GetTextBoostAmount_Text())
                end
            end
        })

        petEleGroup:AddDivider()
        petEleGroup:AddButton("Start Applying", function()
            MonsterBoostManager.StartBoostingSelectedPetsElephant()
        end)
    end

    --===== Elephant end






    ----======================= Red Panda

    UI_LABELS.lbl_redpanda_information = pandaUi:AddLabel({
        Text = ("Total Restocks: <b><font color='#EF2E92'>%d</font></b>"):format(FSettings.red_panda_restock_total),
        DoesWrap = true
    })

    VulnManager.RedPanda.updateInformation()

    pandaUi:AddDivider()

    pandaUi:AddToggle("toggleRedpandarestock", {
        Text = "âš¡ Auto Record",
        Default = FSettings.red_panda_record_items,
        Tooltip = "Automatically records any restocks from Red Panda",
        Callback = function(Value)
            FSettings.red_panda_record_items = Value
            SaveData()
        end
    })

    pandaUi:AddDivider()
    ----======================= end Red Panda





    ----======================= Chubby Chipmunk

    UI_LABELS.lbl_chubby_chipmunk_information = ChubbyChipmunkUI:AddLabel({
        Text = ("Acorn Collected: <b><font color='#00FF00'>%d</font></b>"):format(FOtherSettings
            .chubby_chipmunk_amount_collected),
        DoesWrap = true
    })

    VulnManager.ChubbyChipmunk.updateInformation()

    ChubbyChipmunkUI:AddDivider()

    ChubbyChipmunkUI:AddToggle("toggleAcornCollect", {
        Text = "âš¡ Auto Acorn",
        Default = FOtherSettings.chubby_chipmunk_auto_collect,
        Tooltip = "Automatically collect Acorn",
        Callback = function(Value)
            FOtherSettings.chubby_chipmunk_auto_collect = Value
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2)
        end
    })

    ChubbyChipmunkUI:AddDivider()
    ----======================= end Chubby Chipmunk








    ----======================= Marmot

    UI_LABELS.lbl_marmot_information = marmotUI:AddLabel({
        Text = ("Marmot Mound Collected: <b><font color='#00FF00'>%d</font></b>"):format(FOtherSettings
            .marmot_amount_collected),
        DoesWrap = true
    })

    VulnManager.Marmot.updateInformation()

    marmotUI:AddDivider()

    marmotUI:AddToggle("toggleMarmotCollect", {
        Text = "âš¡ Auto Marmot Mound",
        Default = FOtherSettings.marmot_auto_collect,
        Tooltip = "Automatically collect Marmot Mound",
        Callback = function(Value)
            FOtherSettings.marmot_auto_collect = Value
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2)
        end
    })

    marmotUI:AddDivider()
    ----======================= end Marmot




    --================ Pet Leveling
    petLevelGroup:AddDivider()
    UI_LABELS.lbl_pet_level_status = petLevelGroup:AddLabel({
        Text = "ðŸ”´ Not running",
        DoesWrap = true
    })

    UI_LABELS.lbl_pet_level_info = petLevelGroup:AddLabel({
        Text = "-",
        DoesWrap = true
    })

    local petlevelBoostsDropdown = petLevelGroup:AddDropdown("petleveldropdown", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "âš¡ Choose Boost", -- clearer English, more vibrant icon
        Searchable = true,
        Tooltip = "Select a pet boost to use. Only one can be active at a time.",
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            if not newSelection then
                return
            end
            FOtherSettings.pet_level_boost_list = newSelection
            SaveDataOther()
        end
    })

    -- Get all gear items and add a placeholder at the top
    local boost_ls = InventoryManager.Gear.GetAllGearItems()
    table.insert(boost_ls, 1, "â€”") -- nicer dash as placeholder

    -- Set dropdown values and default selection
    petlevelBoostsDropdown:SetValues(boost_ls)
    petlevelBoostsDropdown:SetValue(FOtherSettings.pet_level_boost_list)




    UI_Dropdown.PetLevelDropDown = petLevelGroup:AddDropdown("dropdownlevelpetslist", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ¦œ Select Pets To Level",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            if newSelection == nil then
                return
            end
            FOtherSettings.pet_level_selected_pets = {}

            for Value, Selected in pairs(newSelection) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(FOtherSettings.pet_level_selected_pets, _uuid)
                    end
                end
                -- loop ends
            end

            SaveDataOther()
        end
    })

    MonsterManager.LevelSystem.UpdateDropDown()

    petLevelGroup:AddDivider()

    petLevelGroup:AddButton("Reload Teams", function()
        UpdatePetData()
        Library:Notify("Loading...", 2)
    end)


    petLevelGroup:AddDivider()

    local inputMaxLevel
    local default_text_autolevel = "âŒ› <font color='#7CFC00'>Max</font> Level"
    inputMaxLevel = petLevelGroup:AddInput("inputMaxLevel", {
        Text = default_text_autolevel,
        Default = FOtherSettings.pet_auto_level_max,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Max Level",
        Tooltip = "Enter max age to reach.",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)

            if not num or num <= 0 then
                Library:Notify("Invalid Level: " .. Value, 3)
                inputMaxLevel:SetValue(tostring(FOtherSettings.pet_auto_level_max))
                return
            end

            if num > 0 then
                --level
                FOtherSettings.pet_auto_level_max = num
                SaveDataOther()
                inputMaxLevel:SetText("âœ… <font color='#00FF00'>Max Level Updated</font>")
                task.wait(1)
                inputMaxLevel:SetText(default_text_autolevel)
            end
        end
    })




    local inputMinLevel
    local default_text_autominlevel = "âŒ› <font color='#FF4E29'>Min</font> Level"
    inputMinLevel = petLevelGroup:AddInput("inputMinLevel", {
        Text = default_text_autominlevel,
        Default = FOtherSettings.pet_auto_level_min,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Min Level",
        Tooltip = "Enter min age (0 to disable), pets will start leveling if they are over minimum age",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)

            if not num or num < 0 then
                Library:Notify("Invalid Level: " .. Value, 3)
                inputMinLevel:SetValue(tostring(FOtherSettings.pet_auto_level_min))
                return
            end

            if num >= 0 then
                --level
                FOtherSettings.pet_auto_level_min = num
                SaveDataOther()
                inputMinLevel:SetText("âœ… <font color='#00FF00'>Min Level Updated</font>")
                task.wait(1)
                inputMinLevel:SetText(default_text_autominlevel)
            end
        end
    })



    petLevelGroup:AddDivider()

    petLevelGroup:AddToggle("toogleAutoLevel", {
        Text = "âš¡ Auto Level Pets",
        Default = FOtherSettings.pet_auto_level_auto,
        Tooltip = "Automatically level pets",
        Callback = function(Value)
            FOtherSettings.pet_auto_level_auto = Value
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2)
        end
    })

    ------------------------ end pet levels

    -- Status Label
    PetFeedingGroup:AddDivider()
    UI_LABELS.lbl_pet_system_live = PetFeedingGroup:AddLabel({
        Text = "ðŸ”´ Not running",
        DoesWrap = true
    })

    PetFeedingGroup:AddDivider()

    -- Dropdown: Exclude Pets from Feeding
    local ExcludePetsDropdown = PetFeedingGroup:AddDropdown("exclude_pet_list", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ¦œ Exclude Pets",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.feeding_list_pets = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.feeding_list_pets[key] = value
            end
            SaveDataOther()
        end
    })

    -- Populate dropdown with all pet names
    ExcludePetsDropdown:SetValues(GetKeyValuesFromList(_Helper.GetAllPets()))
    ExcludePetsDropdown:SetValue(FOtherSettings.feeding_list_pets)

    PetFeedingGroup:AddDivider()

    PetFeedingGroup:AddLabel({
        Text =
        "âš ï¸ Feeds all active <font color='#FFFACD'>pets</font> with hunger under <font color='#FF4C4C'>70%</font>. Ignores max-level pets and <font color='#FFA07A'>excluded</font> list pets. Paused if hatching is in progress.",
        DoesWrap = true
    })

    local time_input
    local timer_default_text = "âŒ› <font color='#7CFC00'>Time</font> in Seconds"
    time_input = PetFeedingGroup:AddInput("feedingtimeinput", {
        Text = timer_default_text,
        Default = FOtherSettings.feeding_pets_timer,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Enter time here",
        Tooltip = "Feeds every seconds set.",
        Callback = function(Value)
            local num = ParseWeightNumber(Value)

            if not num or num <= 0 then
                Library:Notify("Invalid time: " .. Value, 3)
                time_input:SetValue(tostring(FOtherSettings.feeding_pets_timer))
                return
            end

            if num > 0 then
                -- Update time if valid
                FOtherSettings.feeding_pets_timer = num
                SaveDataOther()
                time_input:SetText("âœ… <font color='#00FF00'>Time Updated</font>")
                task.wait(1)
                time_input:SetText(timer_default_text)
            end
        end
    })



    PetFeedingGroup:AddDivider()

    PetFeedingGroup:AddToggle("autofeddingsystemenable", {
        Text = "âš¡ Auto Feed Pet",
        Default = FOtherSettings.feeding_pets_auto,
        Tooltip = "Automatically feeds and collects fruits when required [if enabled].",
        Callback = function(Value)
            FOtherSettings.feeding_pets_auto = Value
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2)
        end
    })

    PetFeedingGroup:AddDivider()

    PetFeedingGroup:AddLabel({
        Text =
        "âš ï¸ If you run out of <font color='#FFD700'>fruits</font>, the system can automatically collect the <font color='#FFA500'>required fruits</font>. Follows the <font color='#1E90FF'>Fruit Collection</font> settings. Ignores fruits required for <font color='#00FF00'>ascension</font>.",
        DoesWrap = true
    })

    -- Dropdown: Exclude Foods
    local exludefoods = PetFeedingGroup:AddDropdown("exclude_food_list", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ• Exclude Foods",
        Searchable = true,
        Tooltip = "Will not feed these foods.",
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.feeding_exlude_food_list = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.feeding_exlude_food_list[key] = value
            end
            SaveDataOther()
        end
    })

    -- Populate dropdown with all pet names
    local foodlist = InventoryManager.GetFoodCategoryNames()
    exludefoods:SetValues(foodlist)
    exludefoods:SetValue(FOtherSettings.feeding_exlude_food_list)

    PetFeedingGroup:AddToggle("autofeedsys_enfood", {
        Text = "ðŸ• Feed Food",
        Default = FOtherSettings.feed_food_insteadoffruits,
        Tooltip = "If enabled, it will feed food instead of fruits.",
        Callback = function(Value)
            FOtherSettings.feed_food_insteadoffruits = Value
            SaveDataOther()
            local status = Value and "Enabled" or "Disabled"
            Library:Notify(status, 2)
        end
    })

    PetFeedingGroup:AddToggle("autofeedsys_en", {
        Text = "ðŸŽ Auto Fruit Collection",
        Default = FOtherSettings.feeding_auto_collectfruits,
        Tooltip = "Automatically collects fruits when none are available for feeding.",
        Callback = function(Value)
            FOtherSettings.feeding_auto_collectfruits = Value
            SaveDataOther()
            local status = Value and "Enabled" or "Disabled"
            Library:Notify(status, 2)
        end
    })

    PetFeedingGroup:AddToggle("force_feedallpets", {
        Text = "ðŸš¨ Force Feed All Pets",
        Default = FOtherSettings.force_feed_all_pets,
        Tooltip = "âš¡ Feed all pets immediately, even if they are full or at max level",
        Callback = function(Value)
            FOtherSettings.force_feed_all_pets = Value
            SaveDataOther()

            local status = Value and "âœ… Enabled" or "âŒ Disabled"
            Library:Notify("ðŸš¨ Force Feed All Pets: " .. status, 2)
        end
    })



    PetFeedingGroup:AddSpacer(50)
end

-- Call the function to build the UI
UiPetsSideTab()





-- Craft ui
local function UiCraftsideTab()
    local CraftingTab = Window:AddTab({
        Name = "ðŸ”¥ <font color='#F5272A'>Craft</font> and ðŸ‘¨â€ðŸ³ <font color='#00FF00'>Cook</font>",
        Description = "Automatically craft items and manage your workbench",
        Icon = "hammer" -- more appropriate for crafting
    })


    local Cooking_Group = CraftingTab:AddRightGroupbox("ðŸ‘¨â€ðŸ³ <font color='#00FF00'>Cooking Pots</font>", "chef-hat")
    local craftbenchgroup = CraftingTab:AddLeftGroupbox("ðŸ”¥ <font color='#00FF00'>Work Bench(s)</font> ðŸ”¥", "theater")

    local craftTeamsGroups = CraftingTab:AddLeftGroupbox("âš”ï¸ <font color='#A3FFFA'>Craft Teams</font>", "brick-wall-fire")


    ---- ==== Craft Teams #craftui
    if craftTeamsGroups then
        craftTeamsGroups:AddLabel({
            Text =
            'â„¹ï¸ Craft Teams - These teams handle your items before submission and before claiming. ðŸ”´ They will not operate while hatching or mutation systems are active. <font color="#FF0F53">Leave a team empty</font> if you do NOT wish to use it.',
            DoesWrap = true
        })


        UI_LABELS.lbl_craftteams_status = craftTeamsGroups:AddLabel({
            Text = "Waiting...",
            DoesWrap = true
        })

        -- Texts

        local GetText_craftteam_claimteam = function()
            local current_selected = #FSettings.allcraft.team_claim
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#00FF3C"><b>ðŸŽ Claim Team</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )
            return txt
        end

        local GetText_craftteam_submitteam = function()
            local current_selected = #FSettings.allcraft.team_submit
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#FF0066"><b>ðŸŽ€ Submit Team</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )

            return txt
        end


        local GetText_craftteam_idleteam = function()
            local current_selected = #FSettings.allcraft.team_idle
            local max_allowed = GetMaxPetCapacity()

            local ratio_colour = current_selected >= max_allowed and "#FF5555" or "#00FF99"

            local txt = string.format(
                '<font color="#FFAA0F"><b>â³ Idle Team</b></font> ' ..
                '<font color="#DDDDDD">[</font>' ..
                '<font color="%s"><b>%d</b></font>' ..
                '<font color="#FFFFFF">/</font>' ..
                '<font color="#DDDDDD"><b>%d</b></font>' ..
                '<font color="#DDDDDD">]</font>',
                ratio_colour,
                current_selected,
                max_allowed
            )

            return txt
        end

        --- Claim Team
        UI_Dropdown.craftteam_claim = craftTeamsGroups:AddDropdown("craftteam_claimx", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_craftteam_claimteam(),
            Tooltip = "Select pets that will be placed before you claim items.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end

                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.craftteam_claim:SetValue(ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_claim))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.allcraft.team_claim = tmp_tbl
                    SaveData()
                    UI_Dropdown.craftteam_claim:SetText(GetText_craftteam_claimteam())
                end
            end
        })

        --- =========== Submit team
        UI_Dropdown.craftteam_submit = craftTeamsGroups:AddDropdown("craftteam_submitx", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_craftteam_submitteam(),
            Tooltip =
            "This team will be placed when you are about to submit items.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end

                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.craftteam_submit:SetValue(ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_submit))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.allcraft.team_submit = tmp_tbl
                    SaveData()
                    UI_Dropdown.craftteam_submit:SetText(GetText_craftteam_submitteam())
                end
            end
        })



        --- =========== Idle team
        UI_Dropdown.craftteam_idle = craftTeamsGroups:AddDropdown("craftteam_idlex", {
            Values = {},
            Default = {},
            Multi = true,
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Text = GetText_craftteam_idleteam(),
            Tooltip =
            "This team will be used when crafts are not ready.",
            Callback = function(Values)
                if Values == nil then
                    return
                end
                local tmp_tbl = {}
                local _allowed = true
                for Value, Selected in pairs(Values) do
                    if Selected then
                        local _uuid = extractUUIDFromString(Value)
                        table.insert(tmp_tbl, _uuid)
                    end
                    -- loop ends
                end

                local max_allowed = GetMaxPetCapacity()
                local count_vals = #tmp_tbl
                if count_vals > max_allowed then
                    UI_Dropdown.craftteam_idle:SetValue(ConvertUUIDToPetNamesPairs(FSettings.allcraft.team_idle))
                    Library:Notify("Team size maxed", 2)
                else
                    FSettings.allcraft.team_idle = tmp_tbl
                    SaveData()
                    UI_Dropdown.craftteam_idle:SetText(GetText_craftteam_idleteam())
                end
            end
        })


        craftTeamsGroups:AddLabel({
            Text =
            'âš ï¸ When enabled, these teams will operate with the crafting system. Will not work if hatching or mutations are running.',
            DoesWrap = true
        })

        craftTeamsGroups:AddToggle("togglecraftTeamsGroups", {
            Text = "âš¡ Craft Teams",
            Default = FSettings.allcraft.teams_enabled,
            Tooltip = "If enabled, These teams will be used by the crafting system",
            Callback = function(Value)
                FSettings.allcraft.teams_enabled = Value
                SaveData()
            end
        })

        craftTeamsGroups:AddSpacer(200)
    end

    --- end craft teams


    --- ============== All work benches #craftui
    ---------------------------------------------------
    -- ## CraftUI
    ---------------------------------------------------

    local makeBenchUi = function(Name, list)
        -- Dropdown: Select Items to Craft
        local CraftItemsDropdownx = craftbenchgroup:AddDropdown("craft" .. Name, {
            Values = {},
            Default = {},
            Multi = true,
            Text = "ðŸ› ï¸ " .. Name,
            Tooltip = "Choose which items will be automatically crafted.",
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.allcraft.receipe_data[Name] = newSelection
                SaveData()
            end
        })

        -- Populate
        CraftItemsDropdownx:SetValues(GetKeyValuesFromList(list))
        CraftItemsDropdownx:SetValue(FSettings.allcraft.receipe_data[Name])
    end

    if craftbenchgroup then
        craftbenchgroup:AddDivider()
        UI_LABELS.lbl_craftinggear_stats = craftbenchgroup:AddLabel({
            Text = "ðŸ”´ Not running",
            DoesWrap = true
        })

        UI_LABELS.lbl_crafting_timeleft = craftbenchgroup:AddLabel({
            Text = "-",
            DoesWrap = true
        })

        craftbenchgroup:AddDivider()

        craftbenchgroup:AddLabel({
            Text =
            'âš ï¸ Auto-Craft your items automatically. Crafting will be <font color="#FF0000">paused</font> if <font color="#FFA500">hatching is in progress</font>. Items will be crafted only if you have the <font color="#00FF00">required resources</font>, otherwise they will be <font color="#FF0000">skipped</font>.',
            DoesWrap = true
        })

        craftbenchgroup:AddDivider()

        for bName, _Data in pairs(CraftManager.AllReceipeData) do
            local object = CraftManager.GetWorkBenchModelUsingName(bName)
            -- print("Looking: ", bName)
            if not object then
                -- print("not found: ", new_name)
                continue
            end

            makeBenchUi(bName, _Data)
        end

        craftbenchgroup:AddDivider()

        craftbenchgroup:AddToggle("autofeddingsystemenablex", {
            Text = "âš¡ Auto-Craft",
            Default = FSettings.allcraft.auto_craft_event,
            Tooltip = "Automatically craft items when resources are available.",
            Callback = function(Value)
                FSettings.allcraft.auto_craft_event = Value
                SaveData()
                local status = Value and "Auto-Craft Started" or "Auto-Craft Stopped"
                Library:Notify(status, 2)
            end
        })


        -- Auto collect fruit toggle
        craftbenchgroup:AddDivider()
        craftbenchgroup:AddToggle("btncraftautofruitsx", {
            Text = "ðŸ’ Auto-Collect Fruits",
            Default = FOtherSettings.craft_autofruit_workbench,
            Tooltip = "Automatically collects required fruits for crafting.",
            Callback = function(Value)
                FOtherSettings.craft_autofruit_workbench = Value
                SaveDataOther()
                local status = Value and "ðŸ’ Auto-Collect Enabled" or "ðŸ’ Auto-Collect Disabled"
                Library:Notify(status, 2)
            end
        })

        craftbenchgroup:AddDivider()
        -- Auto plants if no plant found
        craftbenchgroup:AddToggle("togglesdjksdjksdx", {
            Text = "ðŸŒ± Auto-Place Plants",
            Default = FOtherSettings.craft_autoplant_workbench,
            Tooltip = "Automatically plants seeds when if no plants found.",
            Callback = function(Value)
                FOtherSettings.craft_autoplant_workbench = Value
                SaveDataOther()
                local status = Value and "ðŸŒ± Auto-Plant Enabled" or "ðŸŒ± Auto-Plant Disabled"
                Library:Notify(status, 2)
            end
        })

        craftbenchgroup:AddSpacer(200)
    end

    --- End All craft





    ----------------------------------------------
    ----============= Cooking section
    --------------------------------------------------

    Cooking_Group:AddDivider()
    UI_LABELS.lbl_cooking_stats = Cooking_Group:AddLabel({
        Text = "ðŸ”´ Not running",
        DoesWrap = true
    })
    Cooking_Group:AddDivider()
    UI_LABELS.lbl_cooking_display_time = Cooking_Group:AddLabel({
        Text = "-",
        DoesWrap = true
    })

    Cooking_Group:AddDivider()
    -- 1
    local cook1Dropdown = Cooking_Group:AddDropdown("cook1Dropdown1", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "ðŸŒ¿ Ingredient 1",
        Tooltip = "Select your first ingredient.",
        Searchable = true,
        MaxVisibleDropdownItems = 7,
        Changed = function(newSelection)
            if newSelection ~= nil then
                FOtherSettings.cook_potone_item1 = newSelection
            else
                FOtherSettings.cook_potone_item1 = "-"
            end
            SaveDataOther()
        end
    })

    -- Populate
    local d1 = GetKeyValuesFromList(all_plants_list)
    table.insert(d1, 1, "-")
    cook1Dropdown:SetValues(d1)
    cook1Dropdown:SetValue(FOtherSettings.cook_potone_item1)

    -- 2
    local cook2Dropdown = Cooking_Group:AddDropdown("cook2Dropdown", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "ðŸ¥• Ingredient 2",
        Tooltip = "Select your second ingredient.",
        Searchable = true,
        MaxVisibleDropdownItems = 7,
        Changed = function(newSelection)
            if newSelection ~= nil then
                FOtherSettings.cook_potone_item2 = newSelection
            else
                FOtherSettings.cook_potone_item2 = "-"
            end
            SaveDataOther()
        end
    })

    -- Populate
    local d2 = GetKeyValuesFromList(all_plants_list)
    table.insert(d2, 1, "-")
    cook2Dropdown:SetValues(d2)
    cook2Dropdown:SetValue(FOtherSettings.cook_potone_item2)


    -- 3
    local cook3Dropdown = Cooking_Group:AddDropdown("cook3Dropdown", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "ðŸ„ Ingredient 3",
        Tooltip = "Select your third ingredient.",
        Searchable = true,
        MaxVisibleDropdownItems = 7,
        Changed = function(newSelection)
            if newSelection ~= nil then
                FOtherSettings.cook_potone_item3 = newSelection
            else
                FOtherSettings.cook_potone_item3 = "-"
            end
            SaveDataOther()
        end
    })

    -- Populate
    local d3 = GetKeyValuesFromList(all_plants_list)
    table.insert(d3, 1, "-")
    cook3Dropdown:SetValues(d3)
    cook3Dropdown:SetValue(FOtherSettings.cook_potone_item3)


    -- 4
    local cook4Dropdown = Cooking_Group:AddDropdown("cook4Dropdown", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "ðŸ… Ingredient 4",
        Tooltip = "Select your fourth ingredient.",
        Searchable = true,
        MaxVisibleDropdownItems = 7,
        Changed = function(newSelection)
            if newSelection ~= nil then
                FOtherSettings.cook_potone_item4 = newSelection
            else
                FOtherSettings.cook_potone_item4 = "-"
            end
            SaveDataOther()
        end
    })

    -- Populate
    local d4 = GetKeyValuesFromList(all_plants_list)
    table.insert(d4, 1, "-")
    cook4Dropdown:SetValues(d4)
    cook4Dropdown:SetValue(FOtherSettings.cook_potone_item4)


    -- 5
    local cook5Dropdown = Cooking_Group:AddDropdown("cook5Dropdown", {
        Values = {},
        Default = {},
        Multi = false,
        Text = "ðŸ± Ingredient 5",
        Tooltip = "Select your final ingredient.",
        Searchable = true,
        MaxVisibleDropdownItems = 7,
        Changed = function(newSelection)
            if newSelection ~= nil then
                FOtherSettings.cook_potone_item5 = newSelection
            else
                FOtherSettings.cook_potone_item5 = "-"
            end
            SaveDataOther()
        end
    })

    -- Populate
    local d5 = GetKeyValuesFromList(all_plants_list)
    table.insert(d5, 1, "-")
    cook5Dropdown:SetValues(d5)
    cook5Dropdown:SetValue(FOtherSettings.cook_potone_item5)

    Cooking_Group:AddDivider()

    Cooking_Group:AddLabel({
        Text =
        'âš ï¸ Auto-Cooks foods for you, will cook on all available <font color="#FF0000">Cooking Pots</font> ,<font color="#FFD700">Skips Ascension-required items</font>. Pauses if <font color="#FFA500">hatching is in progress</font>.',
        DoesWrap = true
    })


    Cooking_Group:AddDivider()
    Varz.UI_Buttons.ButtonAutoCook = Cooking_Group:AddToggle("autocookstart", {
        Text = "ðŸ¥£ Auto-Cook",
        Default = FOtherSettings.is_auto_cook,
        Tooltip = "Automatically cooks ingredients when ready ðŸ³",
        Callback = function(Value)
            FOtherSettings.is_auto_cook = Value
            SaveDataOther()
            local status = Value and "Auto-Cooking Started" or "Auto-Cooking Stopped"
            Library:Notify(status, 2)
        end
    })

    Cooking_Group:AddLabel({
        Text = 'â˜¢ï¸ <font color="#FF4500">Stop cooking before changing recipes - may cook the wrong dish</font>',
        DoesWrap = true
    })

    Cooking_Group:AddToggle("autocook_autoharvest", {
        Text = "ðŸ’ Auto-Harvest Fruits",
        Default = FOtherSettings.cooking_autocollect_required,
        Tooltip = "Auto-harvests fruits needed for recipes.",
        Callback = function(Value)
            FOtherSettings.cooking_autocollect_required = Value
            SaveDataOther()
            local status = Value and "Enabled" or "Disabled"
            Library:Notify(status, 2)
        end
    })

    Cooking_Group:AddToggle("autocook_autoplant", {
        Text = "ðŸŒ± Auto Plant Missing",
        Default = FOtherSettings.cooking_autoplant_required,
        Tooltip = "Auto Places missing plants needed for recipes.",
        Callback = function(Value)
            FOtherSettings.cooking_autoplant_required = Value
            SaveDataOther()
            local status = Value and "Enabled" or "Disabled"
            Library:Notify(status, 2)
        end
    })



    Cooking_Group:AddSpacer(40)
end

-- Call the function to build the UI
UiCraftsideTab()











-- Create the UI Fruit collection #fruitui
local function UiCollectionTab()
    local UIMutationTab = Window:AddTab({
        Name = "Fruit Collection",
        Description = "Collect fruits with mutation lists",
        Icon = "list-checks" -- Using a lucide icon
    })

    ---------------------------------------------------
    -- ## Automation & Stats Groupboxes
    ---------------------------------------------------
    local AutomationGroup = UIMutationTab:AddLeftGroupbox("Fruit Collection", "shopping-basket")
    local gSafeFruits = UIMutationTab:AddRightGroupbox("Safe Fruits", "book-heart")

    --============================================
    -- Safe Fruits #fruit #safe
    --============================================
    if gSafeFruits then
        gSafeFruits:AddLabel({
            Text =
            "ðŸŽ„âš ï¸ Safe Fruits â€” Select any fruits you want the system to protect from being deleted whenever sell or submit commands are triggered. Prevents events from Submitting these fruits aswel.",
            DoesWrap = true
        })

        local selectfruits = gSafeFruits:AddDropdown("safefruitsselect", {
            Values = {},
            Default = {},
            Multi = true,
            Text = "ðŸ‰ Select Fruits",
            Searchable = true,
            MaxVisibleDropdownItems = 10,
            Changed = function(newSelection)
                if newSelection == nil then
                    return
                end
                FSettings.safe_fruits = newSelection
                SaveData()
            end
        })
        local fruits_ls = InventoryManager.GetTableFruitToolNames()
        selectfruits:SetValues(fruits_ls)
        selectfruits:SetValue(FSettings.safe_fruits)


        local btnsell_pets = gSafeFruits:AddButton({
            Text = "â™»ï¸ Reload Fruits",
            Tooltip = "Reloads fruit list.",
            Func = function()
                local fruits_ls = InventoryManager.GetTableFruitToolNames()
                selectfruits:SetValues(fruits_ls)
                selectfruits:SetValue(FSettings.safe_fruits)
            end
        })


        gSafeFruits:AddButton({
            Text = "ðŸ’° Sell Fruit Inventory",
            Tooltip = "Sells all inventory, applies all filters from sell fruits.",
            Func = function()
                Varz.GetAllFruitsToSell()
            end
        })
    end







    --============================================
    -- collection #collect
    --============================================
    AutomationGroup:AddDivider()
    UI_LABELS.lbl_fruit_collect_live = AutomationGroup:AddLabel({
        Text = "ðŸ”´ Not running",
        DoesWrap = true -- Allows the text to span multiple lines if needed
    })

    AutomationGroup:AddDivider()

    local SeedDropdown = AutomationGroup:AddDropdown("SeedSelector", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ‰ Select Fruit to Collect",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.collection_plants = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.collection_plants[key] = value
            end
            SaveDataOther()
        end
    })

    SeedDropdown:SetValues(GetKeyValuesFromList(all_plants_list))
    SeedDropdown:SetValue(FOtherSettings.collection_plants)

    AutomationGroup:AddDivider()

    -- ## Whitelist Groupbox
    local _whitelistmut = AutomationGroup:AddDropdown("_whitelist", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "âœ… Whitelist Mutations",
        Tooltip = "Fruits matching the selected mutations are collected, otherwise all fruits are collected.",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.mutation_whitelist = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.mutation_whitelist[key] = value
            end
            SaveDataOther()
        end
    })

    _whitelistmut:SetValues(GetKeyValuesFromList(list_mutations))
    _whitelistmut:SetValue(FOtherSettings.mutation_whitelist)

    -- ## Blacklist Groupbox
    local _blacklis = AutomationGroup:AddDropdown("_blacklis", {
        Values = {},
        Default = {},
        Text = "âŒ Blacklist Mutations",
        Multi = true,
        Searchable = true,
        Tooltip = "Fruits carrying selected mutations will not be gathered.",
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.mutation_blacklist = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.mutation_blacklist[key] = value
            end
            SaveDataOther()
        end
    })

    _blacklis:SetValues(GetKeyValuesFromList(list_mutations))
    _blacklis:SetValue(FOtherSettings.mutation_blacklist)


    -- ## Variant
    local _Variant = AutomationGroup:AddDropdown("_variants", {
        Values = {},
        Default = {},
        Text = "âœ¨ <color='#FF00CF'>Variant</font>",
        Multi = true,
        Searchable = true,
        Tooltip = "Collects any selected Variants (Gold, Rainbow etc). if nothing is selected then collects everything.",
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            FOtherSettings.fruit_variants_select = newSelection
            SaveDataOther()
        end
    })

    if _Variantthen then
        _Variant:SetText(GetText_Variant())
    end

    _Variant:SetValues(GetKeyValuesFromList(Varz.All_Variants))
    _Variant:SetValue(FOtherSettings.fruit_variants_select)

    -- ## Rainbow Animation Logic
    -- This creates a separate thread to update the text color continuously
    task.spawn(function()
        while task.wait() do
            -- Safety check: stop loop if the dropdown ceases to exist
            if not _Variant then break end

            -- Calculate Rainbow Color based on time
            -- Change the '5' to make it faster (lower number) or slower (higher number)
            local hue = tick() % 5 / 5
            local color = Color3.fromHSV(hue, 1, 1)

            -- Convert to Hex
            local hex = color:ToHex()

            -- Update the text with the new color
            -- Note: Standard Roblox RichText uses <font color='#...'>
            _Variant:SetText("âœ¨ <font color='#" .. hex .. "'>Variant</font>")
        end
    end)

    AutomationGroup:AddDivider()

    local function GetTextMutationCount()
        local str = string.format("âœ¨ Mutation Count <font color='#7CFC00'>%s</font>",
            FOtherSettings.max_mutation_count)
        return str
    end


    -- #maxmut
    local input_mutation_amount
    input_mutation_amount = AutomationGroup:AddInput("max_mutation_count", {
        Text = GetTextMutationCount(),
        Default = FOtherSettings.max_mutation_count,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "12",
        Tooltip = "Enter amount of mutations should the fruit to collect it. e.g. 12. ",
        Callback = function(Value)
            local num = ParseWholeNumber(Value)
            if not num then
                Library:Notify("Invalid number : " .. Value, 3)
                input_mutation_amount:SetValue(FOtherSettings.max_mutation_count)
                return
            end

            if num < 0 then
                Library:Notify("Enter value 0 or more", 3)
                input_mutation_amount:SetValue(FOtherSettings.max_mutation_count)
                return
            end

            FOtherSettings.max_mutation_count = num
            SaveDataOther()
            input_mutation_amount:SetText(GetTextMutationCount())
        end
    })




    AutomationGroup:AddDivider()

    AutomationGroup:AddLabel({
        Text =
        "âš ï¸ Applies to <font color='#FFFACD'>events</font> and other parts of game where <font color='#FFA07A'>fruits</font> are collected.",
        DoesWrap = true
    })

    local InputMin
    local min_default_text = "â¬‡ï¸ <font color='#7CFC00'>Minimum</font> Weight [KG]"
    InputMin = AutomationGroup:AddInput("MyInputmin", {
        Text = min_default_text,
        Default = FOtherSettings.g_fruit_weight_min,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Min Weight Value",
        Callback = function(Value)
            local num = ParseWeightNumber(Value)
            if not num then
                Library:Notify("Invalid number : " .. Value, 3)
                InputMin:SetValue(FOtherSettings.g_fruit_weight_min)

                return
            end

            if num < 0 then
                Library:Notify("Enter value 0 or more", 3)
                InputMin:SetValue(FOtherSettings.g_fruit_weight_min)

                return
            end

            if num > tonumber(FOtherSettings.g_fruit_weight_max) then
                Library:Notify("Minimum should be lower than maximum", 3)
                InputMin:SetValue(FOtherSettings.g_fruit_weight_min)

                return
            end

            FOtherSettings.g_fruit_weight_min = num
            SaveDataOther()

            InputMin:SetText("âœ… <font color='#00FF00'>Minimum Weight Updated</font>")
            task.wait(1.5)
            InputMin:SetText(min_default_text)
        end
    })

    local max_default_text = "â¬†ï¸ <font color='#FF6B6B'>Maximum</font> Weight [KG]"
    local InputMax
    InputMax = AutomationGroup:AddInput("MyInputmax", {
        Text = max_default_text,
        Default = FOtherSettings.g_fruit_weight_max,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Max Weight Value",
        Callback = function(Value)
            local num = ParseWeightNumber(Value)

            if not num then
                Library:Notify("Invalid number : " .. Value, 3)
                InputMax:SetValue(tostring(FOtherSettings.g_fruit_weight_max))
                return
            end

            if num <= 0 then
                Library:Notify("Enter value more than 0", 3)
                InputMax:SetValue(tostring(FOtherSettings.g_fruit_weight_max))
                return
            end

            if num < tonumber(FOtherSettings.g_fruit_weight_min) then
                Library:Notify("Maximum should be higher than minimum", 3)
                InputMax:SetValue(tostring(FOtherSettings.g_fruit_weight_max))
            end

            FOtherSettings.g_fruit_weight_max = num
            SaveDataOther()

            InputMax:SetText("âœ… <font color='#00FF00'>Maximum Weight Updated</font>")
            task.wait(1.5)
            InputMax:SetText(max_default_text)
        end
    })
    AutomationGroup:AddDivider()
    AutomationGroup:AddToggle("collect_fruits_togglefruit_collector_turbo", {
        Text = "ðŸ”¥<font color='#FF8900'> Turbo Mode</font>",
        Default = FOtherSettings.fruit_collector_turbo,
        Tooltip = "If enabled, Uses faster collection mode.",
        Callback = function(Value)
            FOtherSettings.fruit_collector_turbo = Value
            SaveDataOther()
        end
    })

    AutomationGroup:AddDivider()







    AutomationGroup:AddToggle("collect_fruits_toggle", {
        Text = "âš¡ Enable Collector",
        Default = FOtherSettings.is_collect_fruit,
        Tooltip = "Automatically collects fruits when available.",
        Callback = function(Value)
            FOtherSettings.is_collect_fruit = Value
            --Varz.backpack_full=false
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2)
        end
    })

    AutomationGroup:AddSpacer(100)
end

-- Call the function to build the UI
UiCollectionTab()









-- Selling UI



-- Create the UI for Selling backpack etc
local function MSellUI()
    -- Create the new "Mutations" Tab
    local UISellTab = Window:AddTab({
        Name = "Selling",
        Description = "Sell fruits and more",
        Icon = "store" -- Using a lucide icon
    })

    ---------------------------------------------------
    -- ## Groupboxes
    ---------------------------------------------------
    local AutomationGroup = UISellTab:AddLeftGroupbox("Backpack", "briefcase-business")
    local SellPetsGroup = UISellTab:AddLeftGroupbox("Sell Pets", "briefcase-business")

    local SellPetTypeGroup = UISellTab:AddRightGroupbox("Sell Pet Type", "dog")

    --====== SELL PET TYPE


    SellPetTypeGroup:AddLabel({
        Text =
        "âŒ <font color='#FF4444'><b>[âš  WARNING]</b> Any pets selected here will be <b>auto-sold!</b> Select with caution!</font> âŒ",
        DoesWrap = true
    })

    local sell_pettype_dd = SellPetTypeGroup:AddDropdown("sell_pettype_dd", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ¦œ Select Pet Type",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            if newSelection == nil then
                return
            end
            FSettings.sellingpets.auto_sell_selected = newSelection
            SaveData()
        end
    })
    sell_pettype_dd:SetValues(Varz.all_pets_names_list, true)
    sell_pettype_dd:SetValue(FSettings.sellingpets.auto_sell_selected)


    SellPetTypeGroup:AddToggle("autosellfavpets", {
        Text = "â¤ï¸ Sell Favorite",
        Default = FSettings.sellingpets.auto_sell_override_fav,
        Tooltip = "If enable it will also sell pets that are marked as Favorite.",
        Callback = function(Value)
            FSettings.sellingpets.auto_sell_override_fav = Value
            SaveData()
        end
    })


    SellPetTypeGroup:AddToggle("autosellfavpets", {
        Text = "âš ï¸ Enable Auto Sell",
        Default = FSettings.sellingpets.auto_pet_sell,
        Tooltip = "If enable it will sell selected pets when they are in inventory.",
        Callback = function(Value)
            FSettings.sellingpets.auto_pet_sell = Value
            SaveData()
        end
    })









    --================= SELL PETS
    SellPetsGroup:AddLabel({
        Text = "Select pets to sell.",
        DoesWrap = true
    })

    UI_LABELS.lbl_sell_inventory_pets = SellPetsGroup:AddLabel({
        Text = "Status: ",
        DoesWrap = true
    })

    UI_Dropdown.dropdown_sell_inventory_pets = SellPetsGroup:AddDropdown("ddsellpet_list", {
        Values = {},
        Default = {},
        Multi = true,
        Text = "ðŸ¦œ Select Pets Sell",
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Changed = function(newSelection)
            if newSelection == nil then
                return
            end
            Varz.sell_selected_pets = {}

            for Value, Selected in pairs(newSelection) do
                if Selected then
                    local _uuid = extractUUIDFromString(Value)
                    if _uuid then
                        table.insert(Varz.sell_selected_pets, _uuid)
                    end
                end
                -- loop ends
            end
        end
    })


    SellPetsGroup:AddToggle("manualsellfavpets", {
        Text = "â¤ï¸ Sell Favorite",
        Default = FSettings.sellingpets.manual_sell_fav,
        Tooltip = "If enable it will also sell pets that are marked as Favorite.",
        Callback = function(Value)
            FSettings.sellingpets.manual_sell_fav = Value
            SaveData()
        end
    })

    local btnsell_pets = SellPetsGroup:AddButton({
        Text = "âŒ Sell Selected Pets",
        Tooltip = "Sells selected pets",
        Func = function()
            _Helper.SellSelectedPets(Varz.sell_selected_pets)
        end
    })

    local btnreload = SellPetsGroup:AddButton({
        Text = "â™»ï¸ Reload Pets",
        Func = function()
            UpdatePetData()
        end
    })


    --====== END sell pets






    AutomationGroup:AddLabel({
        Text = "Select how you want to sell from your backpack",
        DoesWrap = true
    })

    AutomationGroup:AddToggle("sell_backpack_toggle", {
        Text = "Auto Sell Backpack",
        Default = FOtherSettings.auto_sellbackpack,
        Tooltip = "Automatically sells backpack when full",
        Callback = function(Value)
            FOtherSettings.auto_sellbackpack = Value
            --Varz.backpack_full = false
            SaveDataOther()
            local status = Value and " Started " or " Stopped"
            Library:Notify(status, 2.5)
        end
    })



    local sellFruitList = AutomationGroup:AddDropdown("sellFruitList", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸŒ Sell Fruits",
        Tooltip = "Select fruit to sell. if nothing is selected it will sell all.",
        Changed = function(newSelection)
            FOtherSettings.sell_fruit_list = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.sell_fruit_list[key] = value
            end

            SaveDataOther()
        end
    })

    local sellWhiteListMut = AutomationGroup:AddDropdown("sellWhiteListMut", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "âœ… Sell Selected Mutations",
        Tooltip = "Sells any mutations selected. if nothing is selected it will sell all.",
        Changed = function(newSelection)
            FOtherSettings.sell_mutation_whitelist = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.sell_mutation_whitelist[key] = value
            end

            SaveDataOther()
        end
    })

    local sellBlackListMut = AutomationGroup:AddDropdown("sellBlackListMut", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "âŒ Don't Sell Selected Mutations",
        Tooltip = "Won't sell any selected mutations. if nothing is selected it will sell all.",
        Changed = function(newSelection)
            FOtherSettings.sell_mutation_blacklist = {}
            for key, value in pairs(newSelection) do
                FOtherSettings.sell_mutation_blacklist[key] = value
            end

            SaveDataOther()
        end
    })

    sellFruitList:SetValues(GetKeyMutListUsingDir(all_plants_list))
    sellFruitList:SetValue(FOtherSettings.sell_fruit_list);

    sellWhiteListMut:SetValues(GetKeyMutListUsingDir(list_mutations))
    sellWhiteListMut:SetValue(FOtherSettings.sell_mutation_whitelist)

    sellBlackListMut:SetValues(GetKeyMutListUsingDir(list_mutations))
    sellBlackListMut:SetValue(FOtherSettings.sell_mutation_blacklist)

    AutomationGroup:AddDivider()

    local max_default_text = "âš¡ <font color='#FF9E1F'>Backpack Sell Timer</font>"

    local InputTimer
    InputTimer = AutomationGroup:AddInput("inputbackpacktimer", {
        Text = max_default_text,
        Default = FOtherSettings.auto_sell_backpack_every,
        Numeric = true,
        AllowEmpty = true,
        Finished = true,
        ClearTextOnFocus = false,
        Placeholder = "Sell backpack every X seconds",
        Tooltip = "Set the interval (in seconds) to automatically sell your backpack contents.",
        Callback = function(Value)
            local num = ParseWeightNumber(Value)

            if not num then
                Library:Notify("âŒ Invalid number: " .. tostring(Value), 3)
                InputTimer:SetValue(tostring(FOtherSettings.auto_sell_backpack_every))
                return
            end

            if num <= 0 then
                Library:Notify("âš ï¸ Please enter a number greater than 0", 3)
                InputTimer:SetValue(tostring(FOtherSettings.auto_sell_backpack_every))
                return
            end

            -- Save new timer
            FOtherSettings.auto_sell_backpack_every = num
            SaveDataOther()

            -- Show temporary confirmation
            InputTimer:SetText("âœ… <font color='#00FF00'>Backpack timer updated</font>")
            task.wait(1.5)
            InputTimer:SetText(max_default_text)
        end
    })

    AutomationGroup:AddToggle("auto_sell_every_toggle", {
        Text = "Auto Sell Every",
        Default = FOtherSettings.auto_sell_backpack_time,
        Tooltip = "Toggle automatic selling of backpack at the set interval.",
        Callback = function(Value)
            FOtherSettings.auto_sell_backpack_time = Value
            SaveDataOther()
            local status = Value and "âœ… Auto-sell started" or "â¹ï¸ Auto-sell stopped"
            Library:Notify(status, 2.5)
        end
    })

    AutomationGroup:AddSpacer(10)
end

-- Call the function to build the UI
MSellUI()










--=========== Shops

-- Shops
function MShopUi()
    local UIShopTab             = Window:AddTab({
        Name = "Shops",
        Description = "Shops",
        Icon = "store"
    })

    local GroupBoxWebhook       = UIShopTab:AddLeftGroupbox("Shops", "store")
    local GroupBoxOtherSettings = UIShopTab:AddRightGroupbox("Shop Settings", "settings-2")
    local GroupBoxMarket        = UIShopTab:AddRightGroupbox("Market", "banknote")
    local SeasonPassGroup       = UIShopTab:AddLeftGroupbox("ðŸŒŸ Season Shop", "tickets")
    local MerchantGroup         = UIShopTab:AddLeftGroupbox("ðŸ“ Traveling Merchants", "store")

    ----=========================================
    -------- Traveling Merchant
    ----------------------------------------------
    do
        MerchantGroup:AddLabel({
            Text = "ðŸ›’ Select items to buy when Traveling Merchant are available on the map.",
            DoesWrap = true
        })
        -- Loop through all available merchant data to create a UI for each shop.
        for ShopName, ShopData in pairs(EventsManager.AllTravelingMerchantData) do
            local Chance = ShopData.Chance

            local font_c = "#FFFFFF"
            if Chance <= 0 then
                font_c = "#C21F00"
            end
            local shop_name = string.format("<font color='%s'>%s</font>", font_c, ShopName)
            local saved_data = FSettings.merchant_shop_data[ShopName] or {}

            -- Create a unique dropdown menu for this specific shop.
            local _mdrop
            _mdrop = MerchantGroup:AddDropdown(ShopName .. "_dropdown", {
                Text = shop_name,
                Values = ShopData.ShopItems,
                Default = saved_data,
                Multi = true,
                Searchable = true,
                MaxVisibleDropdownItems = 10,
                Tooltip = "Choose items for " .. ShopName,

                -- This function runs every time the user changes the selection.
                Changed = function(newSelection)
                    if newSelection ~= nil then
                        FSettings.merchant_shop_data[ShopName] = newSelection or {}
                        SaveData()
                    end
                end
            })

            _mdrop:SetValue(saved_data)
        end


        MerchantGroup:AddSpacer(220)
    end


    ------------- END








    --============ Season Pass
    SeasonPassGroup:AddDivider()
    SeasonPassGroup:AddLabel({
        Text =
        "ðŸ›’ Welcome to the Season Pass Shop! Select items to buy with your season points. âœ… Selected items will be automatically purchased.",
        DoesWrap = true
    })
    SeasonPassGroup:AddDivider()
    local seasonshopitems = SeasonPassGroup:AddDropdown("SeasonPassGroupDropdown", {
        Values = {},
        Default = {},
        Multi = true,
        Searchable = true,
        MaxVisibleDropdownItems = 10,
        Text = "ðŸŒŸ Select Season Shop Items",
        Tooltip = "Pick your favourite items to auto-buy them with your season points.",
        Changed = function(newSelection)
            if not newSelection then return end

            FOtherSettings.season_pass_shop_items = {}
            for Name, value in pairs(newSelection) do
                FOtherSettings.season_pass_shop_items[Name] = true
            end
            SaveDataOther()
        end
    })

    seasonshopitems:SetValues(_EventShops.Season.GetAllSeasonShopItems())
    seasonshopitems:SetValue(FOtherSettings.season_pass_shop_items)

    SeasonPassGroup:AddDivider()

    SeasonPassGroup:AddToggle("season_autoclaim", {
        Text = "ðŸŸ¡ Auto-Claim Points",
        Default = FSettings.auto_claim_season_points,
        Tooltip = "Claim seasion points.",
        Callback = function(Value)
            FSettings.auto_claim_season_points = Value
            SaveData()
        end
    })


    -------- =========== Market

    if GroupBoxMarket then
        if Varz.GetCheckIfPro() then
            Varz.UI_Toggles.ToggleUnlockStore = GroupBoxMarket:AddToggle("secretstore", {
                Text = "Unlock Secret store",
                Default = false,
                Tooltip = "Magic",
                Callback = function(Value)

                end
            })


            --local hiddenStuuf = GroupBoxMarket:AddDependencyBox()
            UI_Dropdown.DropDownMarket = GroupBoxMarket:AddDropdown("DropDownMarket", {
                Values = {},
                Default = {},
                Multi = false,
                Searchable = true,
                MaxVisibleDropdownItems = 10,
                Text = "Products",
                Tooltip = "Buy",
                Changed = function(newSelection)
                    if not newSelection then
                        return
                    end
                    _Helper.JsonPrint(newSelection)
                    MoneyMarkets.CurrentSelectedProductId = newSelection
                end
            })



            -- load
            local btnLoadMarket = GroupBoxMarket:AddButton({
                Text = "Load products",
                Tooltip = "Please stand where you want to move the Plants.",
                Func = function()
                    if next(MoneyMarkets.Market.products) ~= null then
                        Library:Notify("Already loaded", 2)
                        return
                    end
                    Library:Notify("Loading products please wait...", 5)
                    MoneyMarkets.Market.LoadProducts()
                end
            })

            -- Buy selected
            local buyselected = GroupBoxMarket:AddButton({
                Text = "Buy Product",
                Tooltip = "Purchase ",
                Func = function()
                    if next(MoneyMarkets.Market.products) == null then
                        Library:Notify("Not loaded", 2)
                        return
                    end

                    MoneyMarkets.Market.BuySelected()
                end
            })

            -- hiddenStuuf:SetupDependencies({
            --     { Varz.UI_Toggles.ToggleUnlockStore, true },
            -- })

            if Varz.UI_Toggles.ToggleUnlockStore then
                Varz.UI_Toggles.ToggleUnlockStore:SetVisible(false)
            end
        else
            GroupBoxMarket:AddLabel({
                Text = Varz.GetProMessage(),
                DoesWrap = true
            })
        end
    end
    --=========================== END MARKET
    --========================================================








    -- info
    local lblinfo = GroupBoxWebhook:AddLabel({
        Text = "Buy shops? by default all shops will be purchased when active",
        DoesWrap = true
    })


    --======== Shops buttons
    local btnShopGear = GroupBoxWebhook:AddToggle("btnShopGear", {
        Text = "Buy Gear Shop",
        Default = FSettings.buy_gearshop,
        Tooltip = "Enable Gear Shop",
        Callback = function(Value)
            FSettings.buy_gearshop = Value
            SaveData()
            Library:Notify("Updated", 1)
        end
    })

    local btnShopSeed = GroupBoxWebhook:AddToggle("btnShopSeed", {
        Text = "Buy Seed Shop",
        Default = FSettings.buy_seedshop,
        Tooltip = "Enable Seed Shop",
        Callback = function(Value)
            FSettings.buy_seedshop = Value
            SaveData()
            Library:Notify("Updated", 1)
        end
    })

    local btnShopEgg = GroupBoxWebhook:AddToggle("btnShopEgg", {
        Text = "Buy Egg Shop",
        Default = FSettings.buy_eggshop,
        Tooltip = "Enable Egg Shop",
        Callback = function(Value)
            FSettings.buy_eggshop = Value
            SaveData()
            Library:Notify("Updated", 1)
        end
    })
end

MShopUi();


_Helper.is_dex_loaded = false
_Helper.LoadDexTool = function()
    if _Helper.is_dex_loaded then
        return
    end
    local s, r = pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
        _Helper.is_dex_loaded = true
    end)
end

_Helper.is_spy_loaded = false
_Helper.LoadSpyTool = function()
    if _Helper.is_spy_loaded then
        return
    end
    local s, r = pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/depthso/Sigma-Spy/refs/heads/main/Main.lua"),
            "Sigma Spy")()
        _Helper.is_spy_loaded = true
    end)
end

-- #settings
function SettingsUi()
    local UISettingsTab = Window:AddTab({
        Name = "Settings",
        Description = "Settings",
        Icon = "settings"
    })

    local groupVfx = UISettingsTab:AddLeftGroupbox("Game Visuals", "triangle-dashed")
    local GroupBoxWebhook = UISettingsTab:AddLeftGroupbox("Webhook URL", "link")
    local GroupBoxOtherSettings = UISettingsTab:AddRightGroupbox("Other Settings", "settings-2")
    local GroupBoxApiSettings = UISettingsTab:AddRightGroupbox("Web API", "webhook")
    local InterfaceGroupbox = UISettingsTab:AddLeftGroupbox("Interface", "layout-dashboard")

    local gLogout = UISettingsTab:AddLeftGroupbox("Logout", "layout-dashboard")

    local devtoolsGroup
    if Varz.dev_tools then
        devtoolsGroup = UISettingsTab:AddLeftGroupbox("Dev Tools", "align-center-horizontal")
    end


    if gLogout then
        gLogout:AddLabel({
            Text = "âš ï¸ Use this to reset login and login with new key. REJOIN to login again.",
            DoesWrap = true
        })
        gLogout:AddButton({
            Text = "âŒ Reset Login Details",
            Func = function()
                -- remove older file
                local filename = "exologin.json"
                if not isfile(filename) then
                    filename = string.format("%s_exologin.json", Varz.player_userid)
                end
                if isfile(filename) then
                    delfile(filename)
                    Library:Notify("Reset completed. Rejoin..", 5)
                else
                    Library:Notify("Done", 2)
                end
            end
        })
    end


    -- Dev tools
    if devtoolsGroup then
        local btndex = devtoolsGroup:AddButton({
            Text = "DEX",
            Func = function()
                _Helper.LoadDexTool()
            end
        })

        local btnspy = devtoolsGroup:AddButton({
            Text = "SPY",
            Func = function()
                _Helper.LoadSpyTool()
            end
        })
    end


    -- VFX
    if groupVfx then
        local _vfx = GameDataManager.Inventory.GetSettings()

        for key, _v in pairs(_vfx) do
            if key == "PetUpdateRate" or key == "ShowDetails" then continue end

            groupVfx:AddToggle("toggle_" .. key, {
                Text = tostring(key),
                Default = _v,
                Tooltip = "Enable or disable",
                Callback = function(Value)
                    _Helper.vfx.SetVisualEffect(key, Value)
                end
            })
        end
    end



    --================== INTERFACE

    -- Add the UI Scale dropdown
    local values = { 45, 50, 60, 65, 70, 75, 80, 90, 93, 96, 99, 100, 103, 106, 108, 110, 115, 120, 125, 130, 135, 140, 145, 150 }

    local ui_scale_dd = InterfaceGroupbox:AddDropdown("UIScaleDropdown", {
        Text = "â†”ï¸ UI Scale",
        Values = values,                    -- Predefined scale percentages
        Default = FSettings.ui_rescale_val, -- Your saved value

        -- This function formats how the value is displayed in the dropdown
        FormatDisplayValue = function(Value)
            return tostring(Value) .. "%"
        end,

        -- This function is called when the user selects a new value
        Changed = function(Value)
            if not Value then return end
            FSettings.ui_rescale_val = Value
            Library:SetDPIScale(Value)
            SaveData()
        end,

        Tooltip = "Controls the overall size of the user interface."
    })

    ui_scale_dd:SetValue(FSettings.ui_rescale_val)


    -- END








    GroupBoxApiSettings:AddLabel({
        Text = "ðŸŒ Log in to the website to get your API key. ðŸ”‘ Enter it here to sync your data ðŸ“Š.",
        DoesWrap = true
    })

    GroupBoxApiSettings:AddInput("inputApiWeb", {
        Text = "Web API KEY",
        Default = FOtherSettings.web_api_key,
        Numeric = false,
        ClearTextOnFocus = false,
        Finished = false, -- Only calls callback when you press enter
        Placeholder = "API Key",
        Callback = function(Value)
            FOtherSettings.web_api_key = Value
            SaveDataOther()
            Library:Notify("Web API Key Updated", 3)
        end
    })


    -- webhook url
    local lbl_webhook_info = GroupBoxWebhook:AddLabel({
        Text = "Please enter your webhook url for discord",
        DoesWrap = true
    })


    -- PlayerStats
    GroupBoxOtherSettings:AddToggle("togglePlayerStats", {
        Text = "Player Stats",
        Default = FOtherSettings.is_playerstats_running,
        Tooltip = "Show/Hide Player Stats Ui",
        Callback = function(Value)
            FOtherSettings.is_playerstats_running = Value
            SaveDataOther()
            Library:Notify("Updated", 3)
        end
    })
    GroupBoxOtherSettings:AddDivider()
    -- active pets ui
    GroupBoxOtherSettings:AddToggle("toggleacui", {
        Text = "Active Pets UI",
        Default = FSettings.show_activepets_ui,
        Tooltip = "Show/Hide Active Pets UI",
        Callback = function(Value)
            FSettings.show_activepets_ui = Value
            SaveData()
        end
    })

    GroupBoxOtherSettings:AddDivider()


    GroupBoxOtherSettings:AddDivider()
    GroupBoxOtherSettings:AddLabel({
        Text =
        "ðŸ’¡ When enabled, the game's original notifications will be hidden and replaced with custom ones. To restore them, simply disable this option and rejoin the game.",
        DoesWrap = true
    })

    GroupBoxOtherSettings:AddToggle("toggle_delete_notification", {
        Text = "âŒ Delete Notifications",
        Default = FSettings.use_noti,
        Tooltip = "Removes the game's default notification UI.",
        Callback = function(Value)
            FSettings.use_noti = Value

            if Value then
                _Helper.DestroyNotification()
            end

            SaveData()
        end
    })
    -- GroupBoxOtherSettings:AddLabel({
    --     Text =
    --     "ðŸ’¡ When enabled, this tells the game you're on a PC â€” allowing drag and drop to work properly on emulators.",
    --     DoesWrap = true
    -- })

    -- GroupBoxOtherSettings:AddToggle("toggle_pc_mode", {
    --     Text = "âšª PC Mode",
    --     Default = FSettings.is_pc_mode,
    --     Tooltip = "Enable to simulate PC mode for better drag and drop support on emulators.",
    --     Callback = function(Value)
    --         FSettings.is_pc_mode = Value
    --         _Helper.SetPcMode()
    --         SaveData()
    --     end
    -- })


    GroupBoxOtherSettings:AddToggle("disable_event_notify_button", {
        Text = "ðŸ”” Disable Event Notify Btn",
        Default = FSettings.disable_event_notify_button,
        Tooltip = "Show or hide the event notify button",
        Callback = function(Value)
            FSettings.disable_event_notify_button = Value
            _Helper.NotifyButton()
            SaveData()
        end
    })


    GroupBoxOtherSettings:AddToggle("only_show_baseweight", {
        Text = "ðŸ‹ï¸ Show BaseWeight",
        Default = FSettings.only_show_baseweight,
        Tooltip = "If enabled only shows you the base weight everywhere. Reload teams to see changes.",
        Callback = function(Value)
            FSettings.only_show_baseweight = Value
            SaveData()
        end
    })






    --======== WEbhook #webhook

    local InputWebhook = GroupBoxWebhook:AddInput("inputWebhook", {
        Text = "Webhook Url",
        Default = FSettings.webhook_url,
        Numeric = false,
        ClearTextOnFocus = false,
        Finished = false, -- Only calls callback when you press enter
        Placeholder = "Must start with https://",
        Callback = function(Value)
            FSettings.webhook_url = Value
            print("Input updated:", Value)
            SaveData()
            Library:Notify("Webhook saved", 3)
        end
    })

    -- Toggle Send Detailed Report Every Hatch
    local togHatchReport = GroupBoxWebhook:AddToggle("toggleDetailedHatchReport", {
        Text = "Detailed Hatch Report",
        Default = FSettings.send_everyhatch_alert,
        Tooltip = "Every hatch sends a report",
        Callback = function(Value)
            FSettings.send_everyhatch_alert = Value
            print("Toggle changed to:", Value)
            SaveData()
            Library:Notify("Updated Hatch Report", 3)
        end
    })


    -- Test webhook
    local ButtonTestWebHook = GroupBoxWebhook:AddButton({
        Text = "Send Test WebHook",
        Func = function()
            SendErrorMessage("Test WebHook!")
            Library:Notify("Sent Test Webhook", 3)
        end
    })

    GroupBoxWebhook:AddDivider()

    local txt_mt = "<font color='#EB27F5'>ðŸ§¬ Mutation URL</font>"

    local InputWebhookMut = GroupBoxWebhook:AddInput("mutinputWebhook", {
        Text = txt_mt,
        Default = FSettings.mut_webhook_url,
        Numeric = false,
        ClearTextOnFocus = false,
        Finished = false, -- Only calls callback when you press enter
        Placeholder = "If empty, they will be sent to normal hatching webhook.",
        Callback = function(Value)
            FSettings.mut_webhook_url = Value
            SaveData()
            Library:Notify("Mut Webhook saved", 3)
        end
    })

    -- -- Rare Hatch
    -- local togRareHatchReport = GroupBoxWebhook:AddToggle("toggleRareHatchReport", {
    --     Text = "Rare Hatch Report",
    --     Default = FSettings.send_rare_pet_alert,
    --     Tooltip = "When a rare pet is hatched",
    --     Callback = function(Value)
    --         FSettings.send_rare_pet_alert = Value
    --         print("Toggle changed to:", Value)
    --         SaveData()
    --         Library:Notify("Updated Rare Hatch Report", 3)
    --     end
    -- })

    -- -- Big Pet Hatch
    -- local togBigPetReport = GroupBoxWebhook:AddToggle("toggleBigPetHatchReport", {
    --     Text = "Big Pet Hatch Report",
    --     Default = FSettings.send_big_pet_alert,
    --     Tooltip = "When a big pet is hatched",
    --     Callback = function(Value)
    --         FSettings.send_big_pet_alert = Value
    --         print("Toggle changed to:", Value)
    --         SaveData()
    --         Library:Notify("Updated Big Pet Report", 3)
    --     end
    -- })





    -- reload pet teams
    --    local TestFun = GroupBoxWebhook:AddButton({
    --         Text = "Test Function",
    --         Func = function()
    --                 -- hold a pet boosts
    --                 local succs, petb = pcall(function ()
    --                     return InventoryManager.GetPetBoostUsingName("Small Treat")
    --                 end)

    --                 if not  succs then
    --                     _Helper.log("Small Pet Treat not found: " .. tostring(petb))
    --                 else
    --                     warn("Found Small Pet Treat: ")
    --                     EquipToolOnChar(petb)
    --                 end
    --         end
    --     })
end

SettingsUi()

-- must be called last
--Library:SetDPIScale(FSettings.ui_rescale_val)


-- icons name from lucide.dev, third is an optional description

--CheckAndSendTimedReports()

FarmManager.AutoStartEvents = function()
    if FSettings.is_running_custom_teams then
        Library:Notify("Starting teams system in 10s", 9)
        task.wait(10)
        PetMutation.StartCustomTeams();
    end

    if FSettings.mut_system.is_ruuning then
        Library:Notify("Auto resume pet mutation in 10s", 9)
        task.wait(10)
        PetMutation.StartThread()
        return
    end

    if FOtherSettings.mut_was_running then
        if FSettings.is_running then
            FOtherSettings.mut_was_running = false
            SaveDataOther()
        end
        Library:Notify("Auto resume mutation machine in 10s", 9)
        task.wait(10)

        MutationMachineManager.StartThread()
        return
    end


    --auto start the rejoin if already started before #no auto start atm
    if FSettings.is_running then
        -- start the task here
        Library:Notify("Auto resume hatching in 10s", 7)
        local countx = 10;
        while countx > 0 do
            countx = countx - 1
            task.wait(1)

            if countx <= 1 then
                Varz.StartHatchingSystem()
            end
        end
    end
end





FallEventManager.chipmunk_cd_max = 10
FallEventManager.chipmun_cd_current = 0
FallEventManager.event_delayed_start = 15




-- Start Fall Event #event
if not _G.FallEventLoop then
    _G.FallEventLoop = task.spawn(function()
        while true do
            task.wait(FallEventManager.event_delayed_start)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            FallEventManager.event_delayed_start = 2
            Varz.QUEST_TASK_RUNNING = false

            if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
                task.wait(15)
                continue
            end

            --FallEventManager.chipmun_cd_current = FallEventManager.chipmun_cd_current + 1


            -- if FallEventManager.chipmun_cd_current >= FallEventManager.chipmunk_cd_max then
            --     --warn("Claim rewards")
            --     FallEventManager.ClaimRewardsOrReset()
            --     FallEventManager.chipmun_cd_current = 0
            -- end


            if not FOtherSettings.is_fall_event_running then
                FallEventManager.UpdateStatsText("ðŸ”´ Event is not enabled.")
                continue
            end

            if Varz.IS_HATCHING == true then
                FallEventManager.UpdateStatsText("ðŸ¥š Paused: Hatching in Progress.")
                task.wait(13)
                continue
            end

            if not FallEventManager.EventFolderExists() then
                FallEventManager.UpdateStatsText("ðŸ”´ Unable to find event...")

                task.wait(15)
                continue
            end

            local fast_mode = FOtherSettings.is_fall_event_fastmode
            FallEventManager.UpdateStatsText("ðŸŸ¢ Active and running...")
            local typeoffruits = FallEventManager.GetLookingForTrait()
            local cooldown = FallEventManager.GetCooldown()
            local _total_bloom = FallEventManager.GetFallBlooms()




            if _total_bloom then
                FallEventManager.UpdateStatsFallBloomText("ðŸŒ¸ Fall Blooms: <b>" .. _total_bloom .. "</b>")
            end

            local current_progress = FallEventManager.GetProgressPercent()
            if current_progress then
                FallEventManager.UpdateStatsProgressText("ðŸ”„ Progress: " .. current_progress .. "")
            end

            if typeoffruits then
                FallEventManager.UpdateStatsRequiredText("âœ¨ Looking for: <font color='#FF7800'>" ..
                    typeoffruits .. "</font> ")
            end


            local xignoreMut = { ["Vamp"] = true, ["Ghostly"] = true, ["Blight"] = true, ["Necrotic"] = true }
            local valid_mutations = {
                ["Frozen"] = true,
                ["Chilled"] = true,
                ["Snowy"] = true,
                ["Ornamented"] = true,
                ["Glacial"] = true,
                ["Pepermint"] = true
            }

            local collectfruits = {}

            for key, value in pairs(all_plants_list) do
                collectfruits[key] = true
            end

            local configx = {
                amount = 20,
                batch_mode = true,
                whitelist_mutation = valid_mutations,
                --blacklist_mutation = FOtherSettings.mutation_whitelist,
                --variants = FOtherSettings.fruit_variants_select,
                --mut_count = FOtherSettings.max_mutation_count
            }




            -- try to submit any fruits collected
            if cooldown then
                -- can't collect fruits yet
                --print("Can't collect cd: ".. cooldown)
                FallEventManager.UpdateStatsProgressText("â³ Cooldown: <b>" .. cooldown .. "s </b>")
                task.wait(2)
                continue
            end



            if typeoffruits and typeoffruits ~= "Any" then
                --local list_names = _FruitCollectorMachine.GetPlantsByCategoryName(typeoffruits)
                local list_names = collectfruits
                if list_names then
                    --print("got list of names")
                    local display_txt = "<font color='#F5BB27'>--- " .. typeoffruits .. "</font> Fruits ---\n"
                    for Name, value in pairs(list_names) do
                        local txv = string.format("%s\n", Name)
                        display_txt = display_txt .. txv
                    end
                    -- FallEventManager.UpdateRequiredFruitsInfoText(display_txt)

                    if Varz.backpack_full then
                        FallEventManager.SubmitFruits()
                        continue
                    end

                    local collected = false
                    if fast_mode then
                        while true do
                            task.wait(0.5)
                            if not FOtherSettings.is_fall_event_running then break end
                            local restorebp = false
                            if not fast_mode then
                                break
                            end

                            -- Pause
                            if Varz.IsPaused() then
                                break
                            end


                            FallEventManager.UpdateStatsText("ðŸŸ¢ Fast collect...")
                            --collected = _FruitCollectorMachine.CollectFruitByNamesBatchMode(list_names, 500)
                            --local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarity(list_names, 30, true)
                            local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarityConfig(collectfruits,
                                configx)

                            task.wait(0.2)

                            if not _c then
                                break
                            end
                            FallEventManager.SubmitFruits()

                            if Varz.IS_HATCHING or Varz.backpack_full then
                                break
                            end
                        end

                        task.wait(0.1)
                    else
                        --collected = _FruitCollectorMachine.CollectFruitByNames(list_names, 50)
                        while true do
                            task.wait(0.5)
                            if not FOtherSettings.is_fall_event_running then break end
                            if Varz.IS_HATCHING or Varz.backpack_full then
                                break
                            end
                            if fast_mode then
                                break
                            end

                            -- Pause
                            if Varz.IsPaused() then
                                break
                            end

                            FallEventManager.UpdateStatsText("ðŸŸ¢ Normal collect...")
                            --local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarity(list_names, 9)

                            configx.amount = 9
                            configx.batch_mode = false
                            local _c = _FruitCollectorMachine.CollectFruitByNamesSortedRarityConfig(collectfruits,
                                configx)

                            if not _c then
                                collected = false
                                break
                            end
                            FallEventManager.SubmitFruits()
                            collected = true
                        end


                        task.wait(0.1)
                    end


                    if collected then
                        FallEventManager.UpdateStatsText("âœ… Fruits Submitted")
                        task.wait(0.1)
                    else
                        FallEventManager.UpdateStatsText("â˜¹ï¸ No fruits available.")
                        task.wait(2.5)
                    end
                end
            elseif typeoffruits and typeoffruits == "Any" then
                -- Chubby Chipmunk Event
                local amountotcollect = 50
                local collected = 0
                local amountoffruits = InventoryManager.GetFruitCount()
                if amountoffruits < 10 then
                    collected = _FruitCollectorMachine.CollectFruitsRandomWithIgnoreMut(amountotcollect, xignoreMut)
                else
                    collected = amountoffruits
                end

                if collected > 0 then
                    FallEventManager.SubmitFruits()
                    FallEventManager.UpdateStatsText("âœ… Fruits Submitted")
                    task.wait(0.5)
                else
                    FallEventManager.UpdateStatsText("â˜¹ï¸ No fruits available.")
                    task.wait(2.5)
                end
                task.wait(0.1)
            else
                FallEventManager.UpdateStatsText("âŒ Failed to find fruit category! restart game.")
                task.wait(3)
                --print("fruits category not found")
            end
        end
    end)
end







-- #tradeevent loop
if TaskManager.loop_tradeevent then
    task.cancel(TaskManager.loop_tradeevent)
    TaskManager.loop_tradeevent = nil
end

TaskManager.loop_tradeevent = task.spawn(function()
    while true do
        task.wait(3)

        -- Disabled
        if true then
            break
        end
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        local ui_ele = EventsManager.TraderEvent.UpdateUITradeEventStatus

        if not FSettings.tradeevent.enable_trade_event then
            ui_ele("ðŸ”´ Not enabled or running.")
            task.wait(5)
            continue
        end



        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            ui_ele("âšª Farm still loading.")
            task.wait(5)
            continue
        end

        if not EventsManager.TraderEvent.GetEventPlatform() then
            ui_ele("âŒ Event not found.")
            task.wait(5)
            continue
        end

        if Varz.IS_HATCHING then
            ui_ele("ðŸŸ¡ Hatching.")
            task.wait(3)
            continue
        end

        local require_fruit, require_amount = EventsManager.TraderEvent.GetRequiredFruit()

        if not require_fruit then
            ui_ele("âš ï¸ Already Traded.")
            task.wait(5)
            continue
        end
        local haveamount = InventoryManager.GetFruitCountUsingNameFromData(require_fruit)
        local missing_amount = math.max(0, require_amount - haveamount)

        local ui_text = string.format("Required: %s\nAmount: %s/%s\nMissing Amount: %s", require_fruit, haveamount,
            require_amount, missing_amount)
        ui_ele(ui_text)

        task.wait(0.5)

        if haveamount > 0 then
            --ui_ele("âœ… Submit Success.")
            EventsManager.TraderEvent.SubmitRequirements()
            task.wait(1)
        end


        -- plant or collect fruits

        if _FruitCollectorMachine.HasPlantByName(require_fruit) then
            if FSettings.tradeevent.fruit_collect then
                local list_fruts = {}
                list_fruts[require_fruit] = true
                _FruitCollectorMachine.CollectFruitByNamesSortedRarity(list_fruts, 15)
                EventsManager.TraderEvent.SubmitRequirements()
            end
        else
            --place these
            if FSettings.tradeevent.seed_place then
                if not Varz.is_garden_full_seed then
                    pcall(function()
                        if Varz.IsSingleHarvest(require_fruit) then
                            _FruitCollectorMachine.PlaceSeedSmart(require_fruit, missing_amount)
                            task.wait(0.5)
                            -- EventsManager.TraderEvent.SubmitRequirements()
                        else
                            _FruitCollectorMachine.PlaceSeedSmart(require_fruit, 3)
                            task.wait(0.5)
                            --EventsManager.TraderEvent.SubmitRequirements()
                        end
                    end)
                end
            end
        end

        task.wait(1)
    end
end)


-- #smith
if TaskManager.loop_smithman then
    task.cancel(TaskManager.loop_smithman)
    TaskManager.loop_smithman = nil
end


TaskManager.is_busy_smith = function()
    if Varz.IS_COOKING or Varz.IS_FEEDING or Varz.IS_HATCHING or Varz.IS_LEVELUP_RUNNING or Varz.IS_SEEDING or Varz.IS_Sprinkler or Varz.IS_WATERING or Varz.IS_MUTATION_RUNNING then
        return true
    end
    return false
end

TaskManager.loop_smithman = task.spawn(function()
    while true do
        task.wait(0.5)

        -- event not available
        if true then break end



        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            EventsManager.Furnace.UpdateUIStatus("âšª Farm still loading.")
            task.wait(10)
            continue
        end

        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        local FindEventModel = EventsManager.Furnace.FindEventModel()
        if not FindEventModel then
            EventsManager.Furnace.UpdateUIStatus("âŒ Event not found.")
            continue
        end

        if not FSettings.craftevent.smith_auto then
            EventsManager.Furnace.UpdateUIStatus("ðŸ”´ Not enabled or running.")
            task.wait(5)
            continue
        end

        task.wait(0.1)

        if Varz.IS_CRAFTING then
            task.wait(4)
            continue
        end



        EventsManager.Furnace.UpdateUIStatus("ðŸŸ¢ Running.")

        if Varz.IS_HATCHING then
            EventsManager.Furnace.UpdateUIStatus("ðŸŸ¡ Hatching.")
            task.wait(3)
            continue
        end


        local delay_between = 1.1

        local egg = EventsManager.Furnace.EquipEggToSubmit()
        if not egg then
            EventsManager.Furnace.UpdateUIStatus("âŒ No eggs found.")
            task.wait(3)
            continue
        end

        if TaskManager.is_busy_smith() then
            task.wait(3)
            continue
        end

        while not TaskManager.is_busy_smith() do
            EventsManager.Furnace.UpdateUIStatus("âœ… Submit Egg.")
            task.wait(0.3)
            EventsManager.Furnace.SubmitEggHeld()

            task.wait(delay_between)



            local gear = EventsManager.Furnace.EquipGearToSubmit()
            if not gear then
                EventsManager.Furnace.UpdateUIStatus("âŒ No gears found.")
                task.wait(3)
                continue
            end
            EventsManager.Furnace.UpdateUIStatus("âœ… Submit Gear.")
            task.wait(0.3)
            EventsManager.Furnace.SubmitGearHeld()
            task.wait(delay_between)

            local fruit = EventsManager.Furnace.EquipFruitToSubmit()
            if not fruit then
                EventsManager.Furnace.UpdateUIStatus("âŒ No fruits found.")
                task.wait(3)
                continue
            end
            EventsManager.Furnace.UpdateUIStatus("âœ… Submit Fruit.")
            task.wait(0.3)
            EventsManager.Furnace.SubmitFruitHeld()
            task.wait(delay_between)
            break
        end
    end
end)





-- Quest activity
if not _G.EventsQuestLineLoop then
    _G.EventsQuestLineLoop = task.spawn(function()
        while true do
            Varz.QUEST_TASK_RUNNING = false

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if true then break end -- break the event

            EventQuestsManager.UpdateStatsInfo("â³ Waiting for tasks...")
            task.wait(7)

            while FOtherSettings.is_fall_questline_auto == false do
                EventQuestsManager.UpdateStatsText(
                    "<font color='#FF0000'>ðŸ”´ Fall Questline not enabled or runningâ€¦</font>")
                task.wait(3)
                continue
            end

            if Varz.IS_HATCHING then
                task.wait(3)
                continue
            end


            EventQuestsManager.UpdateStatsText("<font color='#00FF00'>ðŸŸ¢ Active and runningâ€¦</font>")

            local can_reward = EventQuestsManager.CanClaimRewards()

            if can_reward == true then
                -- claim rewards
                --warn("Please claim rewards")
                EventQuestsManager.UpdateStatsInfo("ðŸŽ Claiming Rewardsâ€¦")
                EventQuestsManager.ClaimRewards()
                task.wait(5)
                EventQuestsManager.UpdateStatsInfo("ðŸŽ‰ Rewards Claimed!")
                continue
            end



            local questslist = EventQuestsManager.GetAvailableActivites()
            _Helper.JsonPrint(questslist)
            if not questslist then
                -- reset
                --warn("Invalid event")
                EventQuestsManager.UpdateStatsText("âš ï¸ Error with event, retrying...")
                task.wait(10)
                continue
            end



            --print("Avoid list > ")
            --_Helper.JsonPrint(EventQuestsManager.AvoidQuests)

            -- check avoid quests here and filter quest
            -- Must make questslist only quests not inside avoid

            -- Filter out quests already in AvoidQuests
            local filteredQuests = {}
            for _, questData in ipairs(questslist) do
                local skip = false
                for _Type, tbl in pairs(questData) do
                    for _, avoid in ipairs(EventQuestsManager.AvoidQuests) do
                        if avoid.Type == _Type and avoid.tbl.name == tbl.name then
                            skip = true
                            break
                        end
                    end
                    if skip then break end
                end
                if not skip then
                    table.insert(filteredQuests, questData)
                end
            end
            questslist = filteredQuests
            --_Helper.log("After filter")
            --_Helper.JsonPrint(questslist)

            -- _Helper.JsonPrint(questslist)

            -- if next(questslist) == nil then
            --     -- reset quest board here

            --     local rerollcost = EventQuestsManager.RerollCost()
            --     if not rerollcost then
            --         -- warn("Reroll cost : " .. rerollcost )
            --         task.wait(10)
            --         continue
            --     end
            --     task.wait(0.3)
            --     if _Helper.canReroll(rerollcost, FOtherSettings.quest_recoll_max_cost) then
            --         --warn("------ Do Reroll")
            --         EventQuestsManager.UpdateStatsText("ðŸ’° Rerolling the Shopâ€¦")
            --         if FOtherSettings.is_fall_questline_reroll then
            --             EventQuestsManager.DoReroll()
            --             task.wait(1)
            --             EventQuestsManager.AvoidQuests = {}
            --         else
            --             -- not enabled
            --             EventQuestsManager.UpdateStatsText("âš ï¸ Rerolling not enabled, skippingâ€¦")
            --         end
            --         task.wait(3)
            --     else
            --         --warn("Unable to reroll, cost high: ")
            --         EventQuestsManager.UpdateStatsInfo(
            --             "â³ <font color='#FFD700'>Unable to reroll. Consider increasing the reroll amount or enabling Auto Reroll.</font>")
            --     end
            --     task.wait(1)
            --     --warn("Must reset quest line")

            --     task.wait(4)
            --     continue
            -- end



            local center = FarmManager.mFarm.Center_Point.Position
            local availablePositions = getGridSeedPositions(center)
            Varz.QUEST_TASK_RUNNING = true

            local water_seed = "Orange Tulip"

            for _, m_data in ipairs(questslist) do
                -- { name = "Maple Leaf Charm", use_current = current, use_max = required }
                for _Type, _tbl in pairs(m_data) do
                    local use_current = _tbl.use_current
                    local use_max = _tbl.use_max
                    local use_amount = use_max - use_current
                    local _name = _tbl.name

                    local timeoutx = 15
                    while Varz.IS_HATCHING or Varz.IS_SEEDING or Varz.IS_COOKING or Varz.IS_SHOVELING do
                        timeoutx = timeoutx - 1
                        if timeoutx <= 0 then
                            break
                        end
                        task.wait(3)
                        continue
                    end

                    if use_amount <= 0 then
                        --warn("cant use this, maybe already max used " .. _name)
                        continue
                    end

                    local toolShovel = InventoryManager.GetShovel()
                    -- is user holding any tool
                    if IsToolHeldNew(toolShovel) then
                        EventQuestsManager.UpdateStatsInfo(
                            "âš ï¸ You are holding a tool <font color='#ff00ff'>[Shovel]</font>, waiting for you to unequip it...")
                        task.wait(math.random(4, 10))
                        continue
                    end

                    EventQuestsManager.UpdateStatsInfo("ðŸ› ï¸ Attempting quest: " .. _Type .. " â†’ " .. _name)
                    task.wait(0.5)

                    if _Type == "Fall Bloom" or _Type == "Harvest Spirit" then
                        -- auto done by event
                        task.wait(10)
                        continue
                    end

                    if _Type == "Bonfire" then
                        local bonfire = InventoryManager.GetBonfire()
                        local limit = 3 -- check if already this much on farm
                        local currentPlantsCount = FarmManager.GetObjectCountByName(_name)
                        if currentPlantsCount >= limit then
                            --warn("Plant " .. _name.. " has reached limit!")
                            -- add to avoid list
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(5)
                            continue
                        end
                        if not bonfire then
                            -- user dont have it, skip
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(2)
                            continue
                        end
                        local placePos = availablePositions[math.random(1, #availablePositions)]
                        unequipTools()
                        task.wait(0.1)
                        EquipToolOnChar(bonfire)
                        InventoryManager.PlaceBonfire(placePos)
                        task.wait(0.6)
                        unequipTools()
                        task.wait(3)
                        continue
                    end

                    if _Type == "WATERCAN" then
                        local waterf = InventoryManager.GetWateringCan(_name)
                        if not waterf then
                            -- dont have cans, skip
                            warn("watering can not found")
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(1)
                            continue
                        end
                        local placePos = availablePositions[math.random(1, #availablePositions)]
                        -- teleport
                        local hrp = _S.Character:WaitForChild("HumanoidRootPart")
                        -- Save the current CFrame
                        local originalCFrame = hrp.CFrame


                        local seed_tool = InventoryManager.GetSeedUsingName(water_seed)
                        if seed_tool then
                            TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(placePos))
                            task.wait(1)
                            unequipTools()
                            task.wait(0.1)
                            EquipToolOnChar(seed_tool)
                            _FruitCollectorMachine.PlantSeed(placePos, water_seed)
                            task.wait(0.6)
                            unequipTools()
                            task.wait(0.5)
                        else
                            warn("Don't have seed " .. water_seed)
                            -- skip
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            continue
                        end

                        if waterf then
                            unequipTools()
                            task.wait(0.1)
                            EquipToolOnChar(waterf)
                            task.wait(0.1)
                            -- same as seed pack
                            for i = 1, use_amount, 1 do
                                InventoryManager.UseWateringCan(placePos)
                                task.wait(0.1)
                            end
                            unequipTools()
                            task.wait(0.5)
                        end
                        TeleportPlayerToCFrame(originalCFrame)
                        task.wait(3)
                        continue
                    end

                    if _Type == "Tool" then
                        -- use this by clicking on screen
                        local ftool = InventoryManager.GetToolUsingName(_name)
                        if ftool then
                            unequipTools()
                            task.wait(0.1)
                            EquipToolOnChar(ftool)
                            task.wait(0.3)
                            -- like weather tools
                            InventoryManager.UseAnyToolOnScreen()
                            task.wait(1)
                        else
                            -- dont have this
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            continue
                        end
                        unequipTools()
                        task.wait(3)
                        continue
                    end

                    if _Type == "SeedPack" then
                        local seedpack = InventoryManager.GetSeedPackUsingName(_name)
                        if seedpack then
                            unequipTools()
                            task.wait(0.1)
                            EquipToolOnChar(seedpack)
                            task.wait(0.3)
                            InventoryManager.OpenSeedPack(_name)
                            task.wait(1)
                        else
                            -- no seed pack, mark as blacklist
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(3)
                            continue
                        end

                        unequipTools()
                        task.wait(3)
                        continue
                    end

                    if _Type == "FeedFood" then
                        local haveFood = _FruitCollectorMachine.GetFoodForFeedUsingName(_name)
                        if not haveFood then
                            -- Don't have fruit. blacklist this quest
                            warn("Dont have food " .. _name)
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(1)
                            continue
                        end
                        warn("Have food " .. _name)
                        MonsterFeeder.FeedPetsFood(_name, use_amount)
                        task.wait(2)
                        continue
                    end

                    if _Type == "Seed" then
                        if Varz.is_garden_full_seed then
                            -- Garden is full
                            -- Inform the fruit collector to collect the plants we plant with watering cans
                            if _FruitCollectorMachine.HasPlantByName(water_seed) then
                                _FruitCollectorMachine.HarvestFruitsUsingNames({ water_seed }, 5)
                                task.wait(2)
                            end
                            warn("Garden is full")
                            EventQuestsManager.UpdateStatsInfo("âš ï¸ Garden is full, unable to place a seed. Waiting...")
                            task.wait(5)
                            continue
                        end
                        warn("Checking Seeds to place")
                        local hrp = _S.Character:WaitForChild("HumanoidRootPart")
                        -- Save the current CFrame
                        local originalCFrame = hrp.CFrame
                        local placePos = availablePositions[math.random(1, #availablePositions)]
                        local seed_tool = InventoryManager.GetSeedUsingName(_name)
                        if seed_tool then
                            TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(center))
                            task.wait(0.3)
                            unequipTools()
                            task.wait(0.1)
                            EquipToolOnChar(seed_tool)
                            for i = 1, use_amount, 1 do
                                _FruitCollectorMachine.PlantSeed(placePos, _name)
                                task.wait(0.6)
                                warn("Placed seed")
                            end
                            task.wait(0.3)
                            unequipTools()
                        else
                            warn("Don't have seed " .. _name)
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                        end
                        TeleportPlayerToCFrame(originalCFrame)
                        task.wait(3)
                        continue
                    end

                    if _Type == "Harvest" then
                        task.wait(0.1)
                        if not _FruitCollectorMachine.HasPlantByName(_name) then
                            warn("Don't have this plant in farm")
                            local placePos = availablePositions[math.random(1, #availablePositions)]
                            local seed_tool = InventoryManager.GetSeedUsingName(_name)
                            local hrp = _S.Character:WaitForChild("HumanoidRootPart")
                            -- Save the current CFrame
                            local originalCFrame = hrp.CFrame

                            if seed_tool then
                                local plant_am = 3
                                TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(center))
                                task.wait(0.3)
                                unequipTools()
                                task.wait(0.1)
                                EquipToolOnChar(seed_tool)
                                for i = 1, plant_am, 1 do
                                    _FruitCollectorMachine.PlantSeed(placePos, _name)
                                    task.wait(0.6)
                                end
                                task.wait(0.3)
                                unequipTools()
                            else
                                --warn("Don't have seed " .. _name)
                                table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            end
                            TeleportPlayerToCFrame(originalCFrame)
                            task.wait(3)
                            continue
                        end
                        _FruitCollectorMachine.HarvestFruitsUsingNames({ _name }, use_amount)
                        --table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                        task.wait(3)
                        continue
                    end

                    if _Type == "Sprinkler" then
                        local _sprinkler = InventoryManager.GetSprinklerUsingName(_name)
                        if not _sprinkler then
                            -- user has no tool, mark as impossible task
                            table.insert(EventQuestsManager.AvoidQuests, { tbl = _tbl, Type = _Type })
                            task.wait(3)
                            continue
                        end
                        unequipTools()
                        task.wait(0.4)
                        EquipToolOnChar(_sprinkler)
                        task.wait(0.4)
                        for i = 1, use_amount, 1 do
                            task.wait(0.5)
                            if IsToolHeld(_sprinkler) then
                                local placePos = availablePositions[math.random(1, #availablePositions)]
                                InventoryManager.PlaceSprinkler(placePos)
                                task.wait(0.9)
                                --warn("Placed: " .. _name)
                            end
                        end

                        unequipTools()
                        task.wait(0.1)
                        continue
                    end

                    if _Type == "Feed" then
                        task.wait(0.1)
                        MonsterFeeder.FeedHungryPets(true, true)
                        task.wait(7)
                        continue
                    end
                end
            end
            EventQuestsManager.UpdateStatsInfo("âœ… Quest done, moving to next...")
            Varz.QUEST_TASK_RUNNING = false
            task.wait(math.random(1, 2))
        end
    end)
end






-- #shovel sprinkler
if TaskManager.task_auto_shovel_sprinkler then
    task.cancel(TaskManager.task_auto_shovel_sprinkler)
    TaskManager.task_auto_shovel_sprinkler = nil
end

TaskManager.busy_task_auto_shovel_sprinkler = function()
    if Varz.IS_COOKING or Varz.IS_FEEDING or Varz.IS_HATCHING or Varz.IS_LEVELUP_RUNNING or Varz.IS_SEEDING or Varz.IS_Sprinkler or Varz.IS_WATERING or Varz.IS_MUTATION_RUNNING then
        return true
    end
    return false
end

TaskManager.task_auto_shovel_sprinkler = task.spawn(function()
    while true do
        task.wait(3)

        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        if not FSettings.auto_remove_sprinklers then
            continue
        end

        if TaskManager.busy_task_auto_shovel_sprinkler() then
            task.wait(3)
            continue
        end

        local anys = next(FSettings.auto_remove_sp_list)
        if not anys then
            task.wait(2)
            continue
        end

        if IsSprinklerHeld() then
            task.wait(1)
            continue
        end


        for item_name, _v in pairs(FSettings.auto_remove_sp_list) do
            local items = FarmManager.GetObjectsUsingName(item_name)

            if #items > 0 then
                local tool = InventoryManager.GetShovel()
                if not tool then continue end

                if TaskManager.busy_task_auto_shovel_sprinkler() then break end
                unequipTools()
                EquipToolOnChar(tool)
                for _, value in pairs(items) do
                    if TaskManager.busy_task_auto_shovel_sprinkler() then break end
                    FarmManager.DeleteObject(value)
                    task.wait(0.9)
                end

                unequipTools()
            else
                --warn("Nothing found for  " .. item_name)
            end
            task.wait(0.05)
        end
    end
end)











-- Event Shop Buy
Varz.EventShop_CD = 5
if not _G.EventsShopBuyStuff then
    _G.EventsShopBuyStuff = task.spawn(function()
        while true do
            task.wait(Varz.EventShop_CD)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if Varz.IS_HATCHING then
                continue
            end

            -- Jungle Seed Stages
            if not EventsManager.shutdown_event_jungle_event then
                EventsManager.JungleShops.BuyStage1Seeds()
                EventsManager.JungleShops.BuyStage2Seeds()
            end

            _EventShops.Halloween.BuyItems()

            _EventShops.Season.BuySeasonShopItem()
            _EventShops.Season.ClaimSeasonPoints()

            -- fall pet shop
            if not Varz.IS_HATCHING then
                _EventShops.FallBuyPetsShop()
            end

            _EventShops.FallBuyCosmeticsShop()
            _EventShops.FallBuyGearsShop()
            _EventShops.FallBuySeedsShop()

            Varz.EventShop_CD = math.random(10, 15)
        end
    end)
end

if not _G.xUIupdater then
    _G.xUIupdater = task.spawn(function()
        while true do
            task.wait(15)

            if Varz.IS_HATCHING then
                continue
            end
            FarmManager.GetAllFarmPlantsNamesAndCount()
        end
    end)
end







Varz.trowel_count_total_to_move = 0
Varz.trowel_current_moved = 0

-- Start Fall Event
if not _G.TowerSRun then
    _G.TowerSRun = task.spawn(function()
        while true do
            task.wait(1)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not _PlantsManager.trowel_is_running then
                _PlantsManager.UpdateTrowelStatus("ðŸ”´ Not Running...")
                task.wait(2)
                continue
            end

            if Varz.IS_HATCHING or Varz.IS_MUTATION_RUNNING then
                _PlantsManager.UpdateTrowelStatus("ðŸ¥š Paused: Hatching/Mutation in Progress.")
                task.wait(15)
                continue
            end

            Varz.trowel_count_total_to_move = 0
            Varz.trowel_current_moved = 0

            _PlantsManager.UpdateTrowelStatus("ðŸŸ¢ Active and running...")

            -- start the process of moving plants
            local posv3 = _PlantsManager.StringToVector3(FOtherSettings.trowel_saved_cframe)
            if not posv3 then
                _PlantsManager.UpdateTrowelStatus("ðŸ”´ Stopping location invalid...")
                _PlantsManager.trowel_is_running = false
                task.wait(3)
                continue
            end

            --warn("Pos: " , tostring(posv3))

            local plants_ar = _PlantsManager.GetAllPlantsOnFarmForTrowel(posv3)

            -- Get trowel tool
            local mtrowel = _PlantsManager.FindTrowelTool()
            if not mtrowel then
                _PlantsManager.UpdateTrowelStatus("ðŸ”´ Stopping no trowel found...")
                _PlantsManager.trowel_is_running = false
                task.wait(3)
                continue
            end

            if plants_ar and #plants_ar == 0 then
                _PlantsManager.UpdateTrowelStatus("ðŸ”´ Stopping no plants to move...")
                _PlantsManager.trowel_is_running = false
                task.wait(3)
                continue
            end

            Varz.trowel_count_total_to_move = #plants_ar
            local toolholdtries = 0

            -- we have plants process them.
            unequipTools()
            task.wait(0.3)
            EquipToolOnChar(mtrowel)

            _PlantsManager.UpdateTrowelProgress("ðŸ”„ <font color='#32CD32'>Moving </font> " ..
                Varz.trowel_current_moved .. "/" .. Varz.trowel_count_total_to_move)

            for _, fruit in ipairs(plants_ar) do
                local timeoutx = 30
                while Varz.IS_MUTATION_RUNNING or Varz.IS_COOKING or Varz.IS_HATCHING or Varz.IS_SEEDING or Varz.IS_SHOVELING do
                    if timeoutx <= 0 then
                        break
                    end
                    _PlantsManager.UpdateTrowelStatus("ðŸ¥š Paused: Waiting for other tasks...")
                    task.wait(3)
                    timeoutx = timeoutx - 1
                    continue
                end

                if _PlantsManager.trowel_is_running == false then
                    _PlantsManager.UpdateTrowelStatus("âŒ Stopped by user.")
                    task.wait(1)
                    break
                end

                local is_pick = _PlantsManager.PickUpPlantUsingTrowel(mtrowel, fruit)
                if not is_pick then
                    _PlantsManager.UpdateTrowelStatus("âŒ Failed to pick up this plant...")
                    task.wait(0.5)
                    continue
                end
                task.wait(0.1)

                if not IsToolHeld(mtrowel) then
                    _PlantsManager.UpdateTrowelStatus("âŒ Tool not held. Equip... ")
                    unequipTools()
                    task.wait(0.3)
                    EquipToolOnChar(mtrowel)
                    toolholdtries = toolholdtries + 1
                    task.wait(1)

                    if toolholdtries > 15 then
                        break
                    end
                    continue
                end

                local placedplant = _PlantsManager.PlacePlantUsingTrowel(mtrowel, fruit, posv3)
                task.wait(0.1)
                if not placedplant then
                    _PlantsManager.UpdateTrowelStatus("âŒ Failed to place this plant...")
                    task.wait(0.5)
                    continue
                end
                _PlantsManager.UpdateTrowelProgress("ðŸ”„ <font color='#32CD32'>Moving </font> " ..
                    Varz.trowel_current_moved .. "/" .. Varz.trowel_count_total_to_move)
                --print("Moved: " , fruit.Name)

                Varz.trowel_current_moved = Varz.trowel_current_moved + 1
                _PlantsManager.UpdateTrowelStatus("ðŸŸ¢ Success " .. fruit.Name)
                task.wait(0.1)
            end

            -- All moved
            _PlantsManager.trowel_is_running = false
            _PlantsManager.UpdateTrowelStatus(
                "âœ… All plants moved. if nothing moved please make sure to set cframe again and inside your farm.")
            _PlantsManager.UpdateTrowelProgress("ðŸ“Š Last Moved " ..
                Varz.trowel_current_moved .. "/" .. Varz.trowel_count_total_to_move)
            task.wait(0.1)
            unequipTools()
            task.wait(3)
        end
    end)
end






Varz.feeding_cooldown_timer = 5

if not _G.monsterfeedsy then
    _G.monsterfeedsy = task.spawn(function()
        while true do
            task.wait(0.6)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end
            if not FOtherSettings.feeding_pets_auto then
                -- not running..
                MonsterFeeder.UpdateLblStatsText("ðŸ”´ Not running")
                task.wait(math.random(2, 5))
                continue
            end

            local timer_cd = tonumber(FOtherSettings.feeding_pets_timer)
            if not timer_cd then
                timer_cd = math.random(60, 120)
            end
            Varz.feeding_cooldown_timer = timer_cd

            while Varz.feeding_cooldown_timer > 0 and FOtherSettings.feeding_pets_auto do
                MonsterFeeder.UpdateLblStatsText("ðŸŸ¢ Active. Feed in " .. Varz.feeding_cooldown_timer .. "s")
                Varz.feeding_cooldown_timer = Varz.feeding_cooldown_timer - 1
                task.wait(1)
            end

            if Varz.IS_HATCHING then
                MonsterFeeder.UpdateLblStatsText("ðŸŸ¡ Hatching in process")
                task.wait(math.random(3, 7))
                continue
            end

            if FOtherSettings.feeding_pets_auto then
                if not Varz.IS_FEEDING then
                    Varz.IS_FEEDING = true

                    local success, err = pcall(function()
                        return MonsterFeeder.FeedHungryPets(FOtherSettings.force_feed_all_pets, true)
                    end)

                    if not success then
                        warn("[PetFeeder] FeedHungryPets failed:", err)
                    end

                    Varz.IS_FEEDING = false
                    task.wait(1)
                end
            end
        end
    end)
end



-- #selltask

if TaskManager.task_sellpets then
    task.cancel(TaskManager.task_sellpets)
    TaskManager.task_sellpets = nil
end

TaskManager.sell_pet_delay_start = 25

TaskManager.task_sellpets = task.spawn(function()
    while true do
        task.wait(TaskManager.sell_pet_delay_start)
        TaskManager.sell_pet_delay_start = 3

        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        if Varz.IS_HATCHING then
            continue
        end

        if not FSettings.sellingpets.auto_pet_sell then
            task.wait(3)
            continue
        end

        if InventoryManager.IsToolHeldAny() then
            task.wait(1)
            continue
        end

        pcall(function()
            _Helper.SellSelectedPetsTypes()
        end)
        task.wait(4)
    end
end)


-- #pack
if TaskManager.task_open_packs then
    task.cancel(TaskManager.task_open_packs)
    TaskManager.task_open_packs = nil
end

TaskManager.task_open_packs = task.spawn(function()
    while true do
        task.wait(7)

        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end

        if not FSettings.seedpack.is_active then
            task.wait(3)
            continue
        end

        Varz.IS_PACKOPEN = true
        GameDataManager.LoopPackOpenerAuto()
        Varz.IS_PACKOPEN = false
    end
end)


-- #level
if not _G.monsterlevels_task then
    _G.monsterlevels_task = task.spawn(function()
        while true do
            Varz.IS_LEVELUP_RUNNING = false
            task.wait(3)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FOtherSettings.pet_auto_level_auto then
                -- not running..
                MonsterManager.LevelSystem.UpdateUiTextStats("ðŸ”´ Not running")
                task.wait(math.random(2, 5))
                continue
            end

            MonsterManager.LevelSystem.UpdateUiTextStats("ðŸŸ¢ Active and running")

            local max_level = tonumber(FOtherSettings.pet_auto_level_max)
            local min_level = tonumber(FOtherSettings.pet_auto_level_min)

            if min_level > 0 then
                if max_level <= min_level then
                    MonsterManager.LevelSystem.UpdateUiTextStats(
                        "âŒ Max level can't be less than or equal to minimum level.")
                    task.wait(math.random(2, 5))
                    continue
                end
            end


            local pets_to_level = {}
            local idx = 0
            for _, _uuid in ipairs(FOtherSettings.pet_level_selected_pets) do
                local currentLvl = MonsterManager.LevelSystem.GetCurrentPetLevel(_uuid)
                if currentLvl >= max_level then
                    continue
                end

                if min_level > 0 then
                    if currentLvl < min_level then
                        continue
                    end
                end
                table.insert(pets_to_level, _uuid)
            end

            if #pets_to_level == 0 then
                MonsterManager.LevelSystem.UpdateUiTextStats("ðŸŸ¡ Not pets found to level..")
                task.wait(2)
                continue
            end

            MonsterManager.LevelSystem.DetailsPastBoosts = {}

            Varz.IS_LEVELUP_RUNNING = true
            for _, _uuid in ipairs(pets_to_level) do
                idx = idx + 1
                if not FOtherSettings.pet_auto_level_auto then break end
                max_level = tonumber(FOtherSettings.pet_auto_level_max)
                min_level = tonumber(FOtherSettings.pet_auto_level_min)

                if Varz.IS_MUTATION_RUNNING or Varz.IS_JUNGLE_RUNNING or Varz.IS_HATCHING or Varz.IS_COOKING or Varz.IS_FEEDING or Varz.IS_SEEDING or Varz.IS_SHOVELING then
                    MonsterManager.LevelSystem.UpdateUiTextStats("ðŸŸ¡ Tasks in progress")
                    task.wait(math.random(3, 7))
                    continue
                end

                local _petData = GetPetDataByUUID(_uuid)
                if not _petData then
                    continue
                end

                local PetData = _petData.PetData
                local PetType = _petData.PetType -- name of the pet
                local Level = PetData.Level

                local pet_name = tostring(idx) .. "# " .. PetType

                local _boosts = FOtherSettings.pet_level_boost_list
                local currentLvl = Level

                if currentLvl >= max_level then
                    -- pet max level reached
                    continue
                end

                -- Only proceed if _boosts is a string
                if type(_boosts) ~= "string" then
                    --warn("Pet boost is not a string, ignoring")
                    MonsterManager.LevelSystem.UpdateUiTextStats("ðŸŸ¡ Select a boost")
                    task.wait(3)
                    break
                end

                local is_syrup = false
                local is_gear_use = false
                local _tool = nil


                if string.find(_boosts, "Syrup") then
                    is_syrup = true
                    _tool = InventoryManager.GetToolUsingName(_boosts)
                else
                    _tool = InventoryManager.GetPetAnyBoostUsingName(_boosts)
                end

                if string.find(_boosts, "Jelly") then
                    is_gear_use = true
                    --Jack- O- Jelly [285x Uses]

                    local _cleanname = CleanItemNameXpBoosts(_boosts)
                    _tool = InventoryManager.GetToolUsingNameNormalised(_cleanname)
                end


                if not _tool then
                    --warn("Don't have this boost: " .. _boosts)
                    MonsterManager.LevelSystem.UpdateUiTextStats("ðŸŸ¡ Boost not found ")
                    task.wait(3)
                    break
                end



                local petmover = FarmManager.GetActivePetsPetMoverObject(_uuid)
                if not petmover then
                    MonsterManager.LevelSystem.UpdateUiTextStats("âŒ Pet not found on farm.")
                    task.wait(1)
                    continue
                end
                if petmover:IsA("Part") then
                    petmover = petmover:FindFirstChildOfClass("Model")
                end






                -- #level
                MonsterManager.LevelSystem.UpdateUiTextStats("âš¡ Applying boosts...")
                if not EquipToolOnChar(_tool) then
                    MonsterManager.LevelSystem.UpdateUiTextStats("ðŸ”´ Unable to equip tool.")
                    task.wait(1)
                    break
                end

                local lvl_give = 0
                local needed_levels = max_level - currentLvl
                local current_used_boosts = 0
                local max_boost_allowed = 40

                while needed_levels > 0 do
                    if not IsToolHeldNew(_tool) then
                        warn("Not holding tool")
                        break
                    end

                    if current_used_boosts >= max_boost_allowed then
                        break
                    end



                    -- âœ… Before using boost: capture current level
                    local before = MonsterManager.LevelSystem.GetCurrentPetLevel(_uuid)

                    -- Apply boost
                    if is_syrup then
                        InventoryManager.TryUseSyrup(petmover)
                        task.wait(0.3)
                    elseif is_gear_use then
                        InventoryManager.TryUseGearBoost(_boosts, petmover)
                        task.wait(1.2)
                    else
                        MonsterBoostManager.ApplyBoostToPet(_uuid)
                    end

                    task.wait(0.15)

                    -- âœ… After using boost: re-read level
                    local after = MonsterManager.LevelSystem.GetCurrentPetLevel(_uuid)

                    -- âœ… Calculate actual number of levels gained
                    local diff = after - before

                    if diff > 0 then
                        lvl_give = lvl_give + diff
                        needed_levels = needed_levels - diff
                    end

                    current_used_boosts = current_used_boosts + 1

                    MonsterManager.LevelSystem.DetailsPastBoosts[pet_name] = {
                        cur = currentLvl,
                        given_levels = lvl_give,
                        target = max_level
                    }

                    MonsterManager.LevelSystem.UpdateUiTextInformation()

                    -- Safety: stop if we hit max even if needed_levels logic lags
                    if after >= max_level then
                        break
                    end
                end

                task.wait(0.3)
                unequipTools()
            end
            MonsterManager.LevelSystem.UpdateUiTextStats("âœ… Done applying boosts")
            Varz.IS_LEVELUP_RUNNING = false
        end
    end)
end



-- #craft
if TaskManager.craft_tasks_loop then
    task.cancel(TaskManager.craft_tasks_loop)
    TaskManager.craft_tasks_loop = nil
end

TaskManager.craft_tasks_loop = task.spawn(function()
    while true do
        task.wait(1)
        -- Pause
        if Varz.IsPaused() or Varz.IS_HATCHING then
            task.wait(math.random(2, 5))
            continue
        end

        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            UPDATE_LABELS_FUNC.UpdateSetLblStats("ðŸ”´ Waiting for farm data to load.")
            task.wait(10)
            continue
        end

        local _event_enabled = FSettings.allcraft.auto_craft_event

        if not _event_enabled then
            -- not running..
            CraftManager.Update_GearEventWorkbenchStatus("ðŸ”´ Not running")
            CraftManager.Update_GearEventWorkbenchTimers("â„¹ï¸ Select recipes and [Enable] to craft.")
            task.wait(math.random(2, 5))
            continue
        end

        for bName, _data in pairs(CraftManager.AllReceipeData) do
            local rlist = FSettings.allcraft.receipe_data[bName]
            if not rlist then
                continue
            end

            -- Pause
            if Varz.IsPaused() or Varz.IS_HATCHING then
                task.wait(math.random(2, 5))
                break
            end

            local hasRecipes = next(rlist) ~= nil
            if not hasRecipes then
                continue
            end

            -- Get current status
            local current_step = CraftManager.GetWorkbenchStateUsingName(bName)
            if current_step == nil then
                continue
            end

            if Varz.IS_HATCHING then
                CraftManager.Update_GearEventWorkbenchStatus("ðŸŸ¡ Hatching in process")
                task.wait(math.random(3, 7))
                break
            end

            if current_step == CraftManager.CraftStats.SKIP_CRAFT then
                -- craft is process
                --print("Craft in progress for : " .. bName)
                CraftManager.CraftTeams.PlaceTeamIdle()
                CraftManager.Update_GearEventWorkbenchStatus("ðŸ”¨ " .. bName .. "ðŸ”¨ is Crafting: ")
                task.wait(0.5)
                continue
            end

            if current_step == CraftManager.CraftStats.SELECT_RECIPE then
                -- Ready, insert a recipe
                --Varz.IS_CRAFTING = true
                CraftManager.Update_GearEventWorkbenchStatus("ðŸ› ï¸ " .. bName .. " is Attempting Recipe...")
                --print("ðŸ› ï¸ Attempting Recipe...")

                local success, result = pcall(function()
                    CraftManager.SetRecipeUsingName(bName)
                end)

                if success then
                    if result == false then
                        task.wait(3)
                        local fail_r = CraftManager.Current_Recipe_MissingItemName
                        CraftManager.Update_GearEventWorkbenchStatus("âŒ Recipes <font color='#F527E7'>" ..
                            CraftManager.Current_Recipe_Name ..
                            "</font> are Missing <font color='#F08080'>" ..
                            tostring(fail_r) .. "</font> - insufficient resources")
                        warn("insufficient ", fail_r)
                        task.wait(3)
                        CraftManager.Current_Recipe_Name = ""
                        CraftManager.Current_Recipe_MissingItemName = ""
                        Varz.IS_CRAFTING = false
                        continue
                    end
                else
                    --warn(bName .. " failed: " .. tostring(err))
                    CraftManager.Update_GearEventWorkbenchStatus("âŒ " .. bName .. " Stop craft.")

                    task.wait(2)
                end
                task.wait(2)
                --Varz.IS_CRAFTING = false
                continue
            end


            if current_step == CraftManager.CraftStats.START_CRAFTING then
                -- Start crafting, press the submit button
                CraftManager.CraftTeams.PlaceTeamSubmitItems()
                CraftManager.StartCraftWorkbenchUsingName(bName)
                CraftManager.Update_GearEventWorkbenchStatus("âœ… " .. bName .. " Craft Started Successfully")
                task.wait(1)
                continue
            end


            if current_step == CraftManager.CraftStats.SUBMIT_ITEM then
                -- Submit items
                --warn("Submit items")
                task.wait(1)
                CraftManager.CancelWorkbenchUsingName(bName)
                continue
            end

            if current_step == CraftManager.CraftStats.CLAIM_REWARDS then
                -- Craft is complete, claim the items
                -- claim rewards
                CraftManager.CraftTeams.PlaceTeamClaimItems()
                CraftManager.Update_GearEventWorkbenchStatus("ðŸŽ Claiming Rewards")
                --print("ðŸŽ Claiming Rewards")
                CraftManager.ClaimWorkbenchUsingName(bName)
                CraftManager.Current_Recipe_Name = ""
                task.wait(0.5)
                CraftManager.Update_GearEventWorkbenchStatus("âœ… Success")
                CraftManager.Update_GearEventWorkbenchTimers("ðŸŸ¢ Waiting...")
                continue
            end

            if not hasRecipes then
                CraftManager.Update_GearEventWorkbenchStatus("ðŸŸ¢ Active nothing to craft. ")
                warn("ðŸŸ¢ Active nothing to craft.")
                task.wait(0.5)
                continue
            end
        end
    end
end)




if not Varz.threadCookingHandle then
    Varz.threadCookingHandle = task.spawn(function()
        while true do
            task.wait(7 + CookingManager.SpeedOffset)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FOtherSettings.is_auto_cook then
                -- not running..
                --warn("auto cook is not running")
                CookingManager.Update_AllStatus("ðŸ”´ Not active or running")
                CookingManager.TimeDisplayPots = {}
                task.wait(math.random(1 + CookingManager.SpeedOffset, 3 + CookingManager.SpeedOffset))
                continue
            end

            CookingManager.Update_AllStatus("ðŸŸ¢ Active and running")

            local all_pots = CookingManager.GetAllCookingPots()
            if not all_pots then
                --warn("You dont have pots to cook on.")
                CookingManager.Update_AllStatus("âŒ No Cooking Pots found.. Stopping..")
                local status = "Cooking stopped - you do not have any Cooking Pets."
                Library:Notify(status, 4)
                CookingManager.TimeDisplayPots = {}
                CookingManager.Update_AllTimers()
                FOtherSettings.is_auto_cook = false
                SaveDataOther()

                if Varz.UI_Buttons.ButtonAutoCook then
                    Varz.UI_Buttons.ButtonAutoCook:SetValue(FOtherSettings.is_auto_cook)
                end

                task.wait(9 + CookingManager.SpeedOffset)
                continue
            end
            -- prevent inf loops
            local max_h_wait = 0
            while Varz.IS_MUTATION_RUNNING or Varz.IS_Sprinkler or Varz.IS_HATCHING or Varz.IS_SHOVELING or Varz.IS_SEEDING do
                if max_h_wait > 7 then
                    break
                end
                CookingManager.Update_AllStatus("ðŸŸ¡ Paused: Other tasks in progress.")
                max_h_wait = max_h_wait + 1
                task.wait(5)
            end

            for _uuid, _model in pairs(all_pots) do
                task.wait(1)

                if CookingManager.GetIsCooking(_model) then
                    local time_txt = _uuid .. " is cooking"
                    local timeleft = CookingManager.GetTimeLeftUntilDone(_model)
                    if timeleft then
                        time_txt = timeleft
                    end
                    --warn("Already cooking " .. _uuid.. " Time: ".. time_txt)

                    CookingManager.TimeDisplayPots[_uuid] = "ðŸ² Cooking Pot: " .. time_txt
                    CookingManager.Update_AllTimers()
                    task.wait(1)
                    continue
                end

                -- is this ready to collect?
                if CookingManager.IsReadyToCollect(_model) then
                    -- collect
                    CookingManager.Update_AllStatus("ðŸ” Collecting from " .. _uuid)
                    CookingManager.TimeDisplayPots[_uuid] = "âœ… Food is Ready "
                    CookingManager.Update_AllTimers()
                    CookingManager.GetFoodFromPot(_uuid)
                    task.wait(0.01 + CookingManager.SpeedOffset)
                    CookingManager.Update_AllStatus("âœ… Collected from " .. _uuid)
                    continue
                end



                if CookingManager.IsReadyForNewCooking(_model) then
                    -- This pot is ready for cooking, process it

                    local toolShovel = InventoryManager.GetShovel()
                    -- is user holding any tool
                    if IsToolHeldNew(toolShovel) then
                        CookingManager.TimeDisplayPots[_uuid] =
                        "âš ï¸ You are holding a tool <font color='#ff00ff'>[Shovel]</font>, waiting for you to unequip it..."
                        CookingManager.Update_AllTimers()
                        task.wait(math.random(4, 10))
                        continue
                    end


                    CookingManager.TimeDisplayPots[_uuid] = "âšª Ready to cook "
                    CookingManager.Update_AllTimers()

                    local list_fruits = CookingManager.GatherAllRequiredIngredients(_uuid)
                    if not list_fruits then
                        --warn("No fruits to add, skip " .. _uuid)
                        CookingManager.Update_AllStatus("âš¡ No fruits found for " .. _uuid)
                        task.wait(2 + CookingManager.SpeedOffset)

                        continue
                    end
                    CookingManager.Update_AllStatus("ðŸ² Adding fruits to " .. _uuid)
                    task.wait(0.05 + CookingManager.SpeedOffset)
                    Varz.IS_COOKING = true
                    CookingManager.SubmitAllFruits(_uuid, list_fruits)
                    Varz.IS_COOKING = false
                    task.wait(0.05 + CookingManager.SpeedOffset)
                    --warn("All fruits submitted "  .. _uuid)
                    CookingManager.Update_AllStatus("âœ… All fruits submitted to " .. _uuid)

                    continue
                end
            end

            task.wait(0.1 + CookingManager.SpeedOffset)
        end
    end)
end











if not _G.shovel_all_plants then
    _G.shovel_all_plants = task.spawn(function()
        while true do
            Varz.IS_SHOVELING = false
            task.wait(5)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            while not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() do
                if UI_Dropdown.ShovelDropDown then
                    UI_Dropdown.ShovelDropDown:SetText("âš ï¸ Loading...")
                end

                task.wait(1)
                continue
            end



            if not ShovelManager.isLoaded then
                ShovelManager.UpdateCurrentPlantsInFarm()
                task.wait(1)
                if UI_Dropdown.ShovelDropDown then
                    UI_Dropdown.ShovelDropDown:SetText("â›ï¸ Plants to Shovel")
                end

                ShovelManager.isLoaded = true
            end


            if not FOtherSettings.is_auto_shovel then
                -- Only care about manual active state
                if not ShovelManager.IsActive then
                    ShovelManager.UpdateStatus("ðŸ”´ Auto-Shovel Disabled")
                    task.wait(math.random(1, 2))
                    continue
                else
                    -- Manual run in progress
                    ShovelManager.UpdateStatus("ðŸŸ¡ Auto-Shovel Running (Manual)")
                end
            else
                -- Auto mode is ON -> always runs
                ShovelManager.UpdateStatus("ðŸŸ¢ Auto-Shovel Running (Auto)")
            end

            task.wait(0.7)

            --  Get all plants to remove
            local del_plants = ShovelManager.Plant.GetPlantsToDestroy()
            local count_plants = #del_plants

            if count_plants <= 0 then
                ShovelManager.UpdateStatus("ðŸ”´ Nothing to shovel")
                task.wait(3)
                continue
            end

            ShovelManager.UpdateStatus("ðŸŸ¢ Active and running...")
            task.wait(0.5)
            -- current amount for these plants
            -- ["Apple"] = {amount: 300}

            local plant_count = FarmManager.GetPlantCountByNameArrayTable(del_plants)
            local max_keep = FOtherSettings.shovel_keep_amount

            -- check if we can destroy any plants
            local plants_under_limit = ""
            local allowed_del = {}
            local not_allow = {}
            for _, plantx in ipairs(del_plants) do
                if plant_count[plantx.Name] ~= nil then
                    if plant_count[plantx.Name] > max_keep then
                        -- can del this
                        table.insert(allowed_del, plantx)
                    else
                        not_allow[plantx.Name] = true
                    end
                end
            end

            for _itemname, value in pairs(not_allow) do
                plants_under_limit = plants_under_limit .. " " .. _itemname .. " under-limit[Skipped]\n"
            end

            if #allowed_del == 0 then
                if not FOtherSettings.is_auto_shovel then
                    ShovelManager.UpdateStatus("ðŸ”´ Cannot delete any plants. Stopping... " .. plants_under_limit)
                    ShovelManager.IsActive = false
                    Library:Notify("Shovel Stopped", 1)
                else
                    ShovelManager.UpdateStatus("ðŸ”´ Nothing to delete, trying again soon in 10s. " .. plants_under_limit)
                    task.wait(10)
                    continue
                end

                task.wait(3)
                continue
            end

            -- delete plants
            local tool = InventoryManager.GetShovel()
            unequipTools()
            EquipToolOnChar(tool)
            task.wait(0.7)

            ShovelManager.UpdateStatus("ðŸŸ¡ Removing plants from your farm...")
            Varz.IS_SHOVELING = true
            ShovelManager.IsActive = true
            for _, plant in ipairs(allowed_del) do
                if not ShovelManager.IsActive then
                    break
                end
                max_keep = FOtherSettings.shovel_keep_amount

                while Varz.IS_MUTATION_RUNNING or Varz.IS_HATCHING or Varz.IS_FEEDING or Varz.IS_COOKING or Varz.IS_SEEDING do
                    ShovelManager.UpdateStatus("ðŸŸ¡ Paused due to other tasks in progress...")
                    task.wait(2)
                    continue
                end

                ShovelManager.UpdateStatus("ðŸŸ¡ Removing plants from your farm...")

                if not IsToolHeldNew(tool) then
                    unequipTools()
                    EquipToolOnChar(tool)
                    task.wait(0.7)
                end

                if plant_count[plant.Name] ~= nil then
                    if plant_count[plant.Name] <= max_keep then
                        -- we cant shovel this plant anymore
                        --warn("Skipped plant "..plant_count[plant.Name] ..  " / ".. max_keep)
                        ShovelManager.UpdateProgressInformation(plant_count)
                        continue
                    end
                end

                if plant_count[plant.Name] ~= nil then
                    -- destroy it
                    ShovelManager.Plant.DeletePlant(plant)
                    plant_count[plant.Name] = plant_count[plant.Name] - 1
                end
                ShovelManager.UpdateProgressInformation(plant_count)
                task.wait(0.7)
                --warn("Plant destoryed")
            end
            ShovelManager.IsActive = false
            unequipTools()
            task.wait(1)
            Varz.IS_SHOVELING = false
            ShovelManager.UpdateStatus("ðŸŸ¢ Shovelling Complete")
        end
    end)
end






-- Event #seed System
if TaskManager.seedeventtasker then
    task.cancel(TaskManager.seedeventtasker)
    TaskManager.seedeventtasker = nil
end

TaskManager.seedeventtasker = task.spawn(function()
    while true do
        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end
        Varz.IS_SEEDING = false
        task.wait(5)


        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            task.wait(5)
            continue
        end

        if not Varz.event_seeding_active then
            continue
        end

        if next(Varz.event_seeding_list) == nil then
            Varz.event_seeding_active = false
            continue
        end

        if Varz.IS_HATCHING then
            task.wait(4)
            continue
        end

        local placeseeds = Varz.event_seeding_list

        local center = FarmManager.mFarm.Center_Point.Position
        local availablePositions = getGridSeedPositions(center)

        local placePos = availablePositions[math.random(1, #availablePositions)]

        local didplace = false
        Varz.IS_SEEDING = true
        for seedName, data in pairs(placeseeds) do
            -- Use color and bold for seed names, normal for count
            if Varz.is_garden_full_seed or Varz.IS_HATCHING then
                break
            end

            if not Varz.event_seeding_active then
                break
            end


            local amount = data.placeamount
            local get_seed_count = FarmManager.GetPlantCountBySeed(seedName)

            -- if get_seed_count >= amount then
            --     continue
            -- end

            local placed_am = amount - get_seed_count
            if placed_am <= 0 then
                continue
            end



            local _tool = InventoryManager.GetSeedUsingName(seedName)
            if _tool then
                if not IsToolHeldNew(_tool) then
                    unequipTools()
                    task.wait(0.3)
                    if not EquipToolOnChar(_tool) then
                        continue
                    end
                    task.wait(0.3)
                end
                Library:Notify("Placing seed: " .. seedName)

                for i = 1, placed_am, 1 do
                    _FruitCollectorMachine.PlantSeed(placePos, seedName)
                    task.wait(0.4)
                    didplace = true

                    if not Varz.event_seeding_active then
                        break
                    end

                    if Varz.is_garden_full_seed or Varz.IS_HATCHING then
                        break
                    end
                end

                Library:Notify("Done Placing seed: " .. seedName)

                if Varz.is_garden_full_seed or Varz.IS_HATCHING then
                    break
                end
            end
        end


        Varz.IS_SEEDING = false

        if not didplace then
            Library:Notify("Stopped no seeds placed.", 3)
            Varz.event_seeding_active = false
        end
    end
end)


-- #seed system
if not _G.seedplacementrun then
    _G.seedplacementrun = task.spawn(function()
        local function isbusy_seed()
            if Varz.IS_MUTATION_RUNNING or Varz.IS_Sprinkler or Varz.IS_JUNGLE_RUNNING or Varz.IS_HATCHING or Varz.IS_SHOVELING or Varz.IS_COOKING or Varz.IS_WATERING then
                return true
            end
            return false
        end

        while true do
            task.wait(3)

            if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
                SeedManager.Labels.updateStats("ðŸ”´ Waiting for farm data to load.")
                task.wait(5)
                continue
            end


            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FOtherSettings.is_auto_seed then
                if not SeedManager.IsActive then
                    SeedManager.Labels.updateStats("ðŸ”´ Auto-Seed Disabled")
                    Varz.IS_SEEDING = false
                    task.wait(math.random(1, 2))
                    continue
                else
                    SeedManager.Labels.updateStats("ðŸŸ¡ Auto-Seed Running (Manual)")
                end
            else
                SeedManager.Labels.updateStats("ðŸŸ¢ Auto-Seed Running")
            end

            SeedManager.Labels.updateStats("ðŸŸ¢ Auto-Seed Running")
            task.wait(0.4)

            if Varz.IS_SEEDING then
                SeedManager.Labels.updateStats("ðŸ”´ Other systems are placing seeds. Will retry...")
                task.wait(1.9)
                continue
            end

            if isbusy_seed() then
                SeedManager.Labels.updateStats("â¸ï¸ Paused: Other tasks in progress...")
                task.wait(2)
                continue
            end

            -- find all plants on the farm and see if we can place more. remove any we can't place
            local seeds_to_place, plantedCounts = SeedManager.Seeds.GetSeedsToPlaceFiltered()
            if not seeds_to_place then
                if not FOtherSettings.is_auto_seed then
                    SeedManager.Labels.updateStats("ðŸ”´ No seeds to place...")
                    SeedManager.IsActive = false
                    Library:Notify("Stopping seed placement.", 2)
                    task.wait(2)
                    continue
                end
                SeedManager.Labels.updateStats("ðŸŸ¡ No seeds to place...")
                task.wait(3)
                continue
            end



            local center = FarmManager.mFarm.Center_Point.Position
            local availablePositions = getGridSeedPositions(center)

            -- Is it random placement?
            local placePos = availablePositions[math.random(1, #availablePositions)]
            -- does user need to be teleported?
            local hrp = _S.Character:WaitForChild("HumanoidRootPart")
            local originalCFrame = hrp.CFrame

            local isRandomPos = FOtherSettings.is_seed_random
            local max_keep = FOtherSettings.seed_keep_amount
            local userDefinedPosition
            if not isRandomPos then
                userDefinedPosition = _Helper.StringToVector3(FOtherSettings.seed_location_vector)

                -- start the process of moving plants
                if not userDefinedPosition then
                    SeedManager.Labels.updateStats("ðŸ”´ Location is not valid, please select a new location.")
                    task.wait(9)
                    continue
                end

                if _PlantsManager.IsWithinRangeOfFarm(center, userDefinedPosition) then
                    SeedManager.Labels.updateStats("ðŸ”´ Current Location is not within your farm.")
                    task.wait(9)
                    continue
                end
            end

            -- are we close to the farm?
            local currentPlacePos = _PlantsManager.GetCurrentCFrameFromPlayerString()
            local currentPlacePosV3 = _PlantsManager.StringToVector3(currentPlacePos)

            local didTp = false
            if _PlantsManager.IsWithinRangeOfFarm(center, currentPlacePosV3) then
                TeleportPlayerToCFrame(_Helper.Vector3ToCFrame(center))
                didTp = true
            end

            if userDefinedPosition then
                placePos = userDefinedPosition
            end


            SeedManager.IsActive = true
            SeedManager.Labels.updateStats("ðŸŒ± Attempting to place seeds...")
            local is_stop = false
            Varz.IS_SEEDING = true
            for seedName, amount in pairs(seeds_to_place) do
                if not SeedManager.IsActive then
                    break
                end
                if Varz.is_garden_full_seed then
                    SeedManager.Labels.updateStats("â¸ï¸ Garden is full")
                    task.wait(2)
                    break
                end

                if is_stop then
                    break
                end

                local _seedTool = InventoryManager.GetSeedUsingName(seedName)
                if not _seedTool then
                    task.wait(0.1)
                    continue
                end
                unequipTools()
                if not EquipToolOnChar(_seedTool) then
                    task.wait(0.1)
                    continue
                end
                task.wait(0.3)

                for i = 1, amount, 1 do
                    task.wait()
                    if not SeedManager.IsActive then
                        break
                    end
                    if Varz.is_garden_full_seed then
                        SeedManager.Labels.updateStats("â¸ï¸ Garden is full")
                        task.wait(2)
                        break
                    end
                    local timeout = 30

                    if isbusy_seed() then
                        SeedManager.Labels.updateStats("â¸ï¸ Paused: Other tasks in progress...")
                        is_stop = true
                        task.wait(1)
                        break
                    end

                    SeedManager.Labels.updateStats("ðŸŒ± Attempting to place seeds...")

                    if isRandomPos then
                        placePos = availablePositions[math.random(1, #availablePositions)]
                    end

                    if not _seedTool then
                        break
                    end

                    if not IsToolHeldNew(_seedTool) then
                        if not _seedTool then
                            break
                        end
                        unequipTools()
                        if not EquipToolOnChar(_seedTool) then
                            task.wait(1)
                            break
                        end
                        task.wait(0.3)
                    end


                    if plantedCounts[seedName] ~= nil then
                        if plantedCounts[seedName] >= max_keep then
                            SeedManager.Labels.updateInformation(plantedCounts)
                            continue
                        end
                    end

                    if plantedCounts[seedName] ~= nil then
                        -- plant it
                        _FruitCollectorMachine.PlantSeed(placePos, seedName)
                        plantedCounts[seedName] = plantedCounts[seedName] + 1
                    end
                    SeedManager.Labels.updateInformation(plantedCounts)
                    local speedx = FOtherSettings.seed_speed_timer1
                    task.wait(speedx)
                end
            end
            if didTp then
                TeleportPlayerToCFrame(originalCFrame)
            end

            unequipTools()
            SeedManager.IsActive = false
            SeedManager.Labels.updateStats("ðŸŸ¢ Seed placements complete")
            task.wait(1)
            Varz.IS_SEEDING = false
        end
    end)
end




-- seed system
if not _G.JungleEvent then
    _G.JungleEvent = task.spawn(function()
        local function is_jungleblocked()
            if Varz.IS_HATCHING then
                return true
            end
            return false
        end

        while true and EventsManager.shutdown_event_jungle_event == false do
            Varz.IS_JUNGLE_RUNNING = false
            task.wait(5)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FOtherSettings.is_auto_jungle then
                EventsManager.JungleUI.UpdateStatsText("ðŸ”´ Not Running")
                task.wait(0.3)
                continue
            end


            EventsManager.JungleUI.UpdateStatsText("ðŸŸ¢ Active and Running")


            if is_jungleblocked() then
                EventsManager.JungleUI.UpdateInformationText("â„¹ï¸ Other tasks in progress..")
                task.wait(1)
                continue
            end


            local submit_per_session = 10
            local selected_list = FOtherSettings.jungle_auto_plants_list
            --Varz.IS_JUNGLE_RUNNING = true
            local hasAnyfruits = false
            for i = 1, submit_per_session, 1 do
                if hasAnyfruits then
                    break
                end
                local fruitTool
                for Name, value in pairs(selected_list) do
                    fruitTool = InventoryManager.GetFruitUsingName(Name)
                    if fruitTool then
                        hasAnyfruits = true
                        break
                    end
                end
            end

            if hasAnyfruits then
                EventsManager.JungleUI.UpdateInformationText("â„¹ï¸ Submit fruit success..")
                EventsManager.JungleActions.SubmitAll()
            else
                EventsManager.JungleUI.UpdateInformationText("â„¹ï¸ No fruits found, trying to collect.")
                local collectls = {}
                for _name, value in pairs(selected_list) do
                    if _FruitCollectorMachine.HasPlantByName(_name) then
                        table.insert(collectls, _name)
                    end
                end
                if #collectls > 0 then
                    EventsManager.JungleUI.UpdateInformationText("â„¹ï¸ Collecting fruits")
                    _FruitCollectorMachine.HarvestFruitsUsingNames(collectls, 5)
                    task.wait(1)
                end
            end

            task.wait(1)
            --Varz.IS_JUNGLE_RUNNING = false
        end
    end)
end





-- water system
if not _G.letswater_task then
    _G.letswater_task = task.spawn(function()
        local function is_busy()
            if Varz.IS_MUTATION_RUNNING or Varz.IS_Sprinkler or Varz.IS_HATCHING or Varz.IS_SEEDING or Varz.IS_JUNGLE_RUNNING or Varz.IS_FEEDING or Varz.IS_SHOVELING or Varz.IS_COOKING or Varz.IS_LEVELUP_RUNNING then
                return true
            end
            return false
        end

        while true do
            Varz.IS_WATERING = false
            task.wait(5)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FarmManager.IsFarmFullyLoaded() or not FarmManager.IsDataFullyLoaded() then
                WaterManager.UI.UpdateStatus("ðŸ”´ Farm is still loading...")
                task.wait(1)
                continue
            end


            if not FOtherSettings.watering_is_auto then
                WaterManager.UI.UpdateStatus("ðŸ”´ Not Running")
                task.wait(1)
                continue
            end


            local waterf = InventoryManager.GetWateringCan("Watering Can")
            if not waterf then
                -- dont have cans, skip
                WaterManager.UI.UpdateStatus("âŒ You do not have watering cans.")
                task.wait(8)
                continue
            end

            WaterManager.UI.UpdateStatus("ðŸŸ¢ Active and Running")
            task.wait(1)
            WaterManager.UI.UpdateProgress("")

            if is_busy() then
                WaterManager.UI.UpdateStatus("â„¹ï¸ Other tasks in progress..")
                task.wait(1)
                continue
            end


            local not_grown = WaterManager.Plants.GetPlantsNotGrown()
            local found_trees_count = #not_grown
            WaterManager.UI.UpdateStatus("â„¹ï¸ Found " .. tostring(found_trees_count) .. " plants to water.")

            if found_trees_count <= 0 then
                WaterManager.UI.UpdateStatus("âŒ No plants to water.")
                task.wait(2)
                continue
            end





            if waterf then
                unequipTools()
                task.wait(0.1)
                EquipToolOnChar(waterf)
                task.wait(0.1)
            end

            local amount = tonumber(FOtherSettings.watering_amount_to_water)
            local speed_water = tonumber(FOtherSettings.watering_speed_time)
            local plant_limit = 20
            local current_water = 0

            Varz.IS_WATERING = true
            local is_stop = false
            for _, tree in ipairs(not_grown) do
                if not FOtherSettings.watering_is_auto then break end

                local pos = _FruitCollectorMachine.GetPlantPosition(tree)
                if not pos then
                    continue
                end
                if not waterf then
                    break
                end
                if current_water > plant_limit then
                    --warn(" Plant limit reached")
                    break
                end
                if is_stop then
                    break
                end

                WaterManager.UI.UpdateStatus("ðŸŸ¢ Watering in progress...")
                WaterManager.UI.UpdateProgress("ðŸ’§ Watering " .. tree.Name)
                local water_cans_used = 0
                for i = 1, amount, 1 do
                    if Varz.IS_HATCHING then
                        is_stop = true
                        break
                    end

                    if not waterf then
                        break
                    end

                    if not IsToolHeldNew(waterf) then
                        unequipTools()
                        if not EquipToolOnChar(waterf) then
                            is_stop = true
                            break
                        end
                        task.wait(0.3)
                    end
                    water_cans_used = water_cans_used + 1
                    InventoryManager.UseWateringCan(pos)
                    WaterManager.UI.UpdateProgress("ðŸ’§ Watering " ..
                        tree.Name .. "  " .. tostring(water_cans_used) .. "/" .. amount)
                    task.wait(speed_water)
                end

                task.wait(0.5)
                current_water = current_water + 1
            end
            WaterManager.UI.UpdateStatus("ðŸŸ¢ Watering completed...")
            unequipTools()
            Varz.IS_WATERING = false
        end
    end)
end







if not _G.sp_service_task then
    _G.sp_service_task = task.spawn(function()
        while true do
            Varz.IS_Sprinkler = false
            task.wait(5)

            -- Pause
            if Varz.IsPaused() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
                task.wait(math.random(2, 5))
                continue
            end

            if not FOtherSettings.is_auto_place_sprinkler_hatch then
                task.wait(3)
                continue
            end


            local item_name = "Grandmaster Sprinkler"
            local sp = FarmManager.GetSprinklerOnFarm(item_name)

            if sp then
                --warn("Already have sprinkler")
                task.wait(9)
                continue
            end

            if Varz.IS_HATCHING and FSettings.is_running then
                warn("Hatching in progress: ", Varz.IS_HATCHING)
                task.wait(5)
                continue
            end

            Varz.IS_Sprinkler = true
            task.wait(2)
            WaterManager.Sprinkler.PlaceGrandMaster(item_name)
            Varz.IS_Sprinkler = false
        end
    end)
end




-- #text


_Helper.activepets_cache_ui = {}
_Helper.MakeActivePetUi = function()
    local lines = {}
    local activels = GameDataManager.Inventory.GetEquippedPets()
    local now = os.time() -- Get the current time

    -- 1. Create a set of currently active pet UUIDs for quick lookup
    local current_pet_uuids = {}
    for _, uuid in ipairs(activels) do
        current_pet_uuids[uuid] = true
    end

    -- Helper function (from original code)
    local get_skillcd = function(puuid)
        local skill_text = ""
        for _uuid, pet_info in pairs(Varz.cooldown_pets) do
            if _uuid ~= puuid then
                continue
            end
            for _, dx in ipairs(pet_info) do
                local Name = dx.Name
                local Passive = dx.Passive
                local Time = dx.Time
                if not Time or not Name then
                    continue
                end

                local skillcd = _Helper.fmt_time(Time)
                local skillx = string.format('Skill:<font color="#A6FF00">%s</font>', skillcd)

                skill_text = skill_text .. " " .. skillx
            end
        end
        return skill_text
    end

    -- 2. Update cache with ALL currently active pets
    for _, uuid in ipairs(activels) do
        local _petData = GetPetDataByUUID(uuid)
        if not _petData then
            continue
        end

        local PetData = _petData.PetData
        local PetType = _petData.PetType or "Unknown"
        local Name = PetData.Name or "Unknown"
        local Level = PetData.Level or 1
        local BaseWeight = PetData.BaseWeight or 0
        local real_weight = GetRealPetWeight(BaseWeight, 1)


        local skill_info = get_skillcd(uuid)

        -- Rich text for pet line (from original)
        local pet_info_string = string.format(
            '<stroke th="1" joins="round" sizing="fixed" color="#FFFFFF"><font color="#E800FF">[%.2fKG]</font></stroke> <font color="#00FFFF">Lv.%d</font> ' ..
            '<font color="#FFFFFF">%s(%s)</font> ' ..
            '%s',
            real_weight,
            Level,
            _Helper.ShortName(PetType, 5),
            Name,
            skill_info
        )

        -- Add or update the pet in the cache
        _Helper.activepets_cache_ui[uuid] = {
            info = pet_info_string, -- Store the formatted string
            removed_at = nil        -- Mark as active (or re-active)
        }
    end

    -- 3. Mark any cached pets that are no longer active
    for uuid, cache_entry in pairs(_Helper.activepets_cache_ui) do
        if not current_pet_uuids[uuid] then
            -- This pet is in our cache but NOT in the active list
            if not cache_entry.removed_at then
                -- Mark it as removed for the first time
                cache_entry.removed_at = now
            end
        end
    end

    -- 4. Build the final `lines` array and identify pets to purge
    local uuids_to_remove = {}

    for uuid, cache_entry in pairs(_Helper.activepets_cache_ui) do
        if cache_entry.removed_at then
            -- This pet is marked as removed
            if (now - cache_entry.removed_at) > 2 then
                -- It's been over 4 seconds, mark for full removal
                table.insert(uuids_to_remove, uuid)
            else
                -- It's in the 4-second window, show it as gray
                local gray_pet_info = string.format('<font color="#FF2A00">%s</font>', cache_entry.info)
                table.insert(lines, gray_pet_info)
            end
        else
            -- This pet is active, add it normally
            local gray_pet_info = string.format('<font color="#FF2A00">%s</font>', cache_entry.info)
            if current_pet_uuids[uuid] then
                gray_pet_info = string.format('%s', cache_entry.info)
            end
            table.insert(lines, gray_pet_info)
        end
    end

    -- 5. Purge old pets from the cache
    for _, uuid in ipairs(uuids_to_remove) do
        _Helper.activepets_cache_ui[uuid] = nil
    end

    return lines
end


if GameDataManager.ui_task_slower then
    task.cancel(GameDataManager.ui_task_slower)
    GameDataManager.ui_task_slower = nil
end

GameDataManager.ui_task_slower = task.spawn(function()
    while true do
        task.wait(3)
        -- Pause
        if Varz.IsPaused() then
            task.wait(math.random(2, 5))
            continue
        end
        _Helper.UI.updateHomeStats(GameDataManager.Inventory.GetPetsCount_UI_TEXT())
    end
end)

-- #stats
if not _G.service_ui_labelupdates then
    _G.service_ui_labelupdates = task.spawn(function()
        while true do
            task.wait(0.5)
            local tbl_stats = {}

            if MutationMachineManager.is_running or PetMutation.is_running then
                local txtsel = string.format("  %s ", MutationMachineManager.TEXT_STATUS)
                table.insert(tbl_stats, txtsel)
            end

            if FSettings.is_running_custom_teams then
                table.insert(tbl_stats, Varz.TEXT_TEAM_SYSTEM)
            end

            if Varz.GetCheckPPByPass() == true then
                local txtsel =
                "<stroke color='#FFFFFF' thickness='2'><font color='#FF4444'>âŒ [Team Placer Failure] Sync issue detected due to interruptions. Please rejoin to restore team placement. âŒ</font></stroke>"
                table.insert(tbl_stats, txtsel)
            end


            if Varz.WAS_PRO_END == true then
                local txtsel =
                "<stroke color='#FFFFFF' thickness='2'><font color='#FF4444'>âŒ [Premium Disabled] Did you login into a new device? please rejoin to restore. Ending in 20s âŒ</font></stroke>"
                table.insert(tbl_stats, txtsel)
            end

            if FSettings.is_running then
                local _key = "hatchtimer"
                local timer_st = _Helper.GetTimerFormatted(_key)
                local txtsel = string.format("  %s\n%s", Varz.TEXT_HATCH_SYSTEM, timer_st)
                table.insert(tbl_stats, txtsel)

                if FSettings.is_test then
                    local txt_test = "\n<font color='#FF5555'>âŒ [Test Mode] Disable to hatch! Home > Test Mode âŒ</font>"
                    table.insert(tbl_stats, txt_test)
                end
            end

            if FSettings.agebreak.is_active_agebreak then
                table.insert(tbl_stats, Varz.TEXT_AGEBREAK)
            end

            if FSettings.allcraft.teams_enabled then
                table.insert(tbl_stats, Varz.TEXT_CRAFT_TEAMS)
            end

            if FSettings.pause_systems then
                local txtsel = "<font color='#FF5555'>âŒ All Systems Are Paused âŒ</font>"
                table.insert(tbl_stats, txtsel)
            end


            if Varz.GetIsRNGStable() then
                local txtsel =
                "ðŸ”¥ <stroke color='#000000' thickness='1'><font color='#07E600'>Possibly Stable RNG Detected.</font></stroke>"
                table.insert(tbl_stats, txtsel)
            end



            local _txteffects = _Helper.CountEffectsByPets()
            if _txteffects then
                for _, v in ipairs(_txteffects) do
                    table.insert(tbl_stats, v)
                end
            end
            local activepets = {}
            if FSettings.show_activepets_ui then
                activepets = _Helper.MakeActivePetUi()
            end
            --table.insert(tbl_stats, "Some Text sddddddlksld ")
            _Helper.updateStatusList(tbl_stats)
            _Helper.updateCompactStatus(activepets)
        end
    end)
end



-- #hook

if not _G.mt_webhook then
    _G.mt_webhook = task.spawn(function()
        local _nsent = 0
        while true do
            task.wait(2)


            if #VulnManager.HatchDataWebhook > 0 then
                local hatchwb = table.remove(VulnManager.HatchDataWebhook, 1)
                _Helper.HatchReportWebhook(hatchwb)
                task.wait(1)
            end

            if #MutationMachineManager.MaxLevelReachedWantedPets_webhook > 0 then
                local dx = table.remove(MutationMachineManager.MaxLevelReachedWantedPets_webhook, 1)
                local MutationType = MutationMachineManager.AllMutationListEnum[dx.MutationType]

                local data_filtered = {
                    pet_name = dx.PetType,
                    nickname = dx.Name,
                    level = dx.Level,
                    found_mutation = MutationType,
                    wanted = true
                }


                local payload = _Helper.getWebhookMutMaxLevel(data_filtered)
                local payload_pub = _Helper.getWebhookMutMaxLevel(data_filtered, true)
                _Helper.SendLiveWebhook(payload, FSettings.mut_webhook_url)
                task.wait(1)
                _Helper.SendLiveWebhookPublicDiscord(payload_pub)
            end

            if #MutationMachineManager.AgeBreakWebHook > 0 then
                local data_filtered = table.remove(MutationMachineManager.AgeBreakWebHook, 1)
                -- local _dta = {
                --     pet_name = PetType,
                --     nickname = Name,
                --     level = Level,
                --     required_level = lvl,
                --     weight = pet_weight
                -- }

                local payload = _Helper.getWebhookMockupDataAgeBreak(data_filtered)
                local payload_pub = _Helper.getWebhookMockupDataAgeBreak(data_filtered, true)
                _Helper.SendLiveWebhook(payload, FSettings.mut_webhook_url)
                task.wait(1)
                _Helper.SendLiveWebhookPublicDiscord(payload_pub)
            end


            if #MutationTableWebhook > 0 then
                local dx = table.remove(MutationTableWebhook, 1)
                local PetType = dx.PetType -- name
                local Level = dx.Level
                local MutationType = MutationMachineManager.AllMutationListEnum[dx.MutationType]
                local Name = dx.Name
                local IsWeight = dx.IsWeight
                local pet_weight = dx.Weight


                local mode_basew = false
                if IsWeight and IsWeight == true then
                    mode_basew = true
                end

                local is_wanted = false

                if next(FOtherSettings.mut_target_mutations) ~= nil then
                    if FOtherSettings.mut_target_mutations[MutationType] then
                        is_wanted = true
                    end
                end

                if FSettings.mut_system.wanted[MutationType] then
                    is_wanted = true
                end

                local data_filtered = {
                    pet_name = PetType,
                    nickname = Name,
                    level = Level,
                    found_mutation = MutationType,
                    wanted = is_wanted,
                    weight = pet_weight,
                    isw = mode_basew
                }

                local payload = _Helper.getWebhookMockupData(data_filtered)
                local payload_pub = _Helper.getWebhookMockupData(data_filtered, true)
                _Helper.SendLiveWebhook(payload, FSettings.mut_webhook_url)
                task.wait(1)
                _Helper.SendLiveWebhookPublicDiscord(payload_pub)
                --local pet_mut = string.format("Pet %s has mutated to %s with nickname %s",PetType, MutationType,Name )
                --SendErrorSuccess(pet_mut)
            end
        end
    end)
end


FarmManager.AutoStartEvents()

-- #update
task.spawn(function()
    UpdatePetData()
end)


-- if Library then
--     if _Helper.IsPrivateServer() then
--         Library:Notify("Private server detected", 6)
--     else
--         Library:Notify("Public server detected", 6)
--     end
-- end



function OnDcMd()
    game:GetService("GuiService").ErrorMessageChanged:Connect(function()
        local msg = game:GetService("GuiService"):GetErrorMessage()
        if msg and msg ~= "" then
            warn("Detected disconnect or error: " .. msg)
            SendErrorMessage("Disconnect Alert: " .. tostring(msg))
            task.wait(3)
            FSessionDx.was_dc = true
            SaveManager.SaveSessionSettings.SaveFile()
            task.wait(math.random(3, 9))
            if FSettings.disconnect_rejoin then
                pcall(function()
                    game:GetService("TeleportService"):Teleport(game.PlaceId, _S.LocalPlayer)
                end)
            end
        end
    end)
end

OnDcMd()

if FSessionDx.was_dc then
    SendErrorSuccess("Connection has been restored. You are back online.");
    FSessionDx.was_dc = false
    SaveManager.SaveSessionSettings.SaveFile()
end



_Helper.AutoActivateGameData = function()
    pcall(function()
        local args = {
            [1] = game:GetService("Players").LocalPlayer
        }

        game:GetService("ReplicatedStorage").GameEvents.LoadScreenEvent:FireServer(unpack(args))
    end)
end
_Helper.AutoActivateGameData()




-- #fav | fav_fruit_enhancer
Varz.cache_fruit_fav_abuse = {}
Varz.cache_reset_timer = 0
Varz.valid_rarity_filter = { ["Prismatic"] = true, ["Transcendent"] = true } -- Adjust as needed

-- new system vars
Varz.already_tested = {} -- Store bad UUIDs here: { ["uuid_string"] = true }
Varz.current_test = {}   -- List of current fruit objects being tested
Varz.was_hatch_done = false
Varz.gains = 0
Varz.enhancer_locked = 0
Varz.StopEnhancer = function(_time)
    Varz.enhancer_locked = _time
    task.wait(0.4)
end


Varz.GetFruitToFavAbuse = function()
    -- Helper to safely get UUID
    local function getUUID(tool)
        return tool:GetAttribute("c") or tool:GetAttribute("UUID") or "unknown"
    end

    -- 1. PRIORITY: Check if we already found the "God Roll" fruits
    if FSessionDx.oldtest and #FSessionDx.oldtest > 0 then
        local ls = {}
        for _, uuid in ipairs(FSessionDx.oldtest) do
            local tool = InventoryManager.GetFruitUsingUUID(uuid)
            if tool then
                table.insert(ls, tool)
            end
        end

        if #ls > 0 then
            return ls
        else
            FSessionDx.oldtest = {} -- Clear if items no longer exist
        end
    end

    -- 2. CHECK RESULTS: Did a hatch just finish?
    if Varz.was_hatch_done then
        Varz.was_hatch_done = false

        if Varz.gains >= 3 and #Varz.current_test > 0 then
            --  print(">>> GOOD RNG FOUND! Saving Fruits...")

            local good_ls = {}
            local newx = {}

            for _, ob in ipairs(Varz.current_test) do
                local uuid = getUUID(ob)
                table.insert(newx, uuid)
                table.insert(good_ls, ob)
            end
            FSessionDx.oldtest = newx
            SaveManager.SaveSessionSettings.SaveFile()
            return good_ls
        else
            -- print("--- BAD RNG. Discarding and marking as tested.")
            for _, ob in ipairs(Varz.current_test) do
                local uuid = getUUID(ob)
                Varz.already_tested[uuid] = true
            end
            Varz.current_test = {}
            Varz.gains = 0
        end
    end

    -- 3. WAITING: If currently testing, return current list
    if #Varz.current_test > 0 then
        local hh = {}
        for index, value in ipairs(Varz.current_test) do
            if not value.Parent then
                continue
            end

            table.insert(hh, value)
        end

        if #hh > 0 then
            return hh
        end
    end

    -- 4. NEW BATCH: Pick new fresh fruits
    -- print("Selecting new fruits to test...")

    local ls = {}
    local max_fruits = 7 -- Amount to test at once

    -- Fetch all available fruits
    local _tools = InventoryManager.GetFruitOfRarity(Varz.valid_rarity_filter, 500, true)

    if #_tools == 0 then
        _FruitCollectorMachine.CollectFruitsRandom(9)
        task.wait(4)
        return {}
    end

    -- Phase A: Try to find Untested Fruits
    for _, ob in ipairs(_tools) do
        local uuid = getUUID(ob)
        if not Varz.already_tested[uuid] then
            table.insert(ls, ob)
            table.insert(Varz.current_test, ob)
            if #ls >= max_fruits then break end
        end
    end

    -- Phase B: FALLBACK - If we didn't find enough fresh fruits, pick RANDOMS
    if #ls < max_fruits and #_tools > 0 then
        -- print("Run out of fresh fruits! Filling with randoms...")

        -- Loop until we fill the list or run out of options
        local attempts = 0
        while #ls < max_fruits and attempts < 100 do
            attempts = attempts + 1

            -- Pick a random fruit from the inventory
            local random_ob = _tools[math.random(1, #_tools)]

            -- Check if it's already in our current 'ls' list to avoid duplicates in the same batch
            local is_dupe = false
            for _, existing in ipairs(ls) do
                if existing == random_ob then
                    is_dupe = true
                    break
                end
            end

            if not is_dupe then
                table.insert(ls, random_ob)
                table.insert(Varz.current_test, random_ob)
            end
        end
    end

    if #ls == 0 then
        -- warn("Inventory is completely empty of valid fruits.")
    end

    return ls
end

-- Reset task if it exists to prevent duplicates
if TaskManager.loop_egg_enhancer then
    task.cancel(TaskManager.loop_egg_enhancer)
    TaskManager.loop_egg_enhancer = nil
end

TaskManager.loop_egg_enhancer = task.spawn(function()
    while true do
        task.wait(0.5)

        if Varz.enhancer_locked > 0 then
            task.wait(0.5)
            Varz.enhancer_locked = Varz.enhancer_locked - 1
            continue
        end

        if not FSettings.fav_fruit_enhancer or not FSettings.is_running then
            task.wait(2)
            continue
        end

        if not FarmManager.IsDataFullyLoaded() or not FarmManager.IsFarmFullyLoaded() then
            task.wait(2)
            continue
        end

        -- Main Logic
        local succes, fail = pcall(function()
            local ls = Varz.GetFruitToFavAbuse()

            -- Only favorite if we have a list and we haven't locked in the "Old Test" yet
            -- If we are using "Old Test", we generally assume they are already ready,
            -- but favoriting them ensures they are selected.
            if ls and #ls > 0 then
                MakeFruitsFav(ls)
                task.wait(0.3) -- Optional: slight delay to ensure server registers fav
                MakeFruitsFav(ls)
            end
        end)

        if not succes then
            warn("er: ", fail)
        end
    end
end)

-- local plantsFolder = workspace:WaitForChild("Farm"):WaitForChild("Farm"):WaitForChild("Important"):WaitForChild("Plants_Physical")

-- for _, plant in ipairs(plantsFolder:GetChildren()) do
--     -- Make the plant itself invisible
--     for _, obj in ipairs(plant:GetDescendants()) do
--         if obj:IsA("BasePart") then
--             obj.Transparency = 1
--             obj.CanCollide = false
--         elseif obj:IsA("Decal") or obj:IsA("Texture") then
--             obj.Transparency = 1
--         elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
--             obj.Enabled = false
--         elseif obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
--             obj.Enabled = false
--         end
--     end

--     -- Make all fruits inside the Fruits folder invisible
--     local fruitsFolder = plant:FindFirstChild("Fruits")
--     if fruitsFolder then
--         for _, fruit in ipairs(fruitsFolder:GetChildren()) do
--             if fruit:IsA("BasePart") then
--                 fruit.Transparency = 1
--                 fruit.CanCollide = false
--             elseif fruit:IsA("MeshPart") then
--                 fruit.Transparency = 1
--                 fruit.CanCollide = false
--             elseif fruit:IsA("Decal") or fruit:IsA("Texture") then
--                 fruit.Transparency = 1
--             elseif fruit:IsA("ParticleEmitter") or fruit:IsA("Trail") or fruit:IsA("Beam") then
--                 fruit.Enabled = false
--             elseif fruit:IsA("BillboardGui") or fruit:IsA("SurfaceGui") then
--                 fruit.Enabled = false
--             end
--         end
--     end
-- end


-- _S.Workspace.PetsPhysical.ChildAdded:Connect(function(pet)
--     task.wait(0.5) -- give time for pet to load


--     -- for _, obj in ipairs(pet:GetDescendants()) do
--     --     if obj:IsA("BasePart") then
--     --         obj.Transparency = 1
--     --         obj.CanCollide = false
--     --     elseif obj:IsA("Decal") or obj:IsA("Texture") then
--     --         obj.Transparency = 1
--     --     elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
--     --         obj.Enabled = false
--     --     elseif obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
--     --         obj.Enabled = false
--     --     end
--     -- end
-- end)

function _Helper.RCinputKil()
    pcall(function()
        local inp = _S.GameEvents.RCSafariJeep
        inp:Destroy()
    end)
end

-- game:GetService("ReplicatedStorage").GameEvents.LoadScreenEvent:FireServer(game:GetService("Players").LocalPlayer)
-- game:GetService("ReplicatedStorage").GameEvents.Finish_Loading:FireServer()

--_Helper.RCinputKil()

function _Helper.DisableAnalytics()
    local ReplicatedStorage = _S.ReplicatedStorage
    local ScriptContext = game:GetService("ScriptContext")


    -- Disable GameAnalyticsError remote
    local GAError = ReplicatedStorage.GameAnalyticsError

    -- Disable GameAnalyticsRemoteConfigs remote
    local GARemote = ReplicatedStorage.GameAnalyticsRemoteConfigs

    if GAError then
        GAError:Destroy()
        GAError = nil
    end

    if GARemote then
        GARemote:Destroy()
        GARemote = nil
    end

    -- Disconnect ScriptContext error connections
    if getconnections then
        for _, conn in pairs(getconnections(ScriptContext.Error)) do
            conn:Disconnect()
        end
    end
end

local success, err = pcall(function()
    _Helper.DisableAnalytics()
end)
if not success then
    warn("Error", err)
end



_Helper.LoadBypass = function()
    pcall(function()
        _S.GameEvents.Finish_Loading:FireServer()
    end)
end

_Helper.LoadBypass()



Varz.RemovePlayerX = function()
    local filename = "exologin.json"
    if not isfile(filename) then
        filename = string.format("%s_exologin.json", Varz.player_userid)
    end
    if isfile(filename) then
        delfile(filename)
        --Library:Notify("Reset completed. Rejoin..", 5)
    else
        --Library:Notify("Done", 2)
    end
    task.wait(20)
    Varz.is_pro = false
    Varz.is_forced_stop = true

    if main_thread then
        task.cancel(main_thread)
    end

    if petmut_thread then
        task.cancel(petmut_thread)
    end

    if mutation_thread then
        task.cancel(mutation_thread)
    end

    _S.LocalPlayer:Kick("You have been kicked from the experience.")
    --  rejoinS()
end


-- send
Varz.SendHpstats = function(payload)
    local urlx = "https://exotichub.app/alivestats"

    -- Capture success status and potential errors
    local success, result = pcall(function()
        local body = _S.HttpService:JSONEncode(payload)
        local req  = (syn and syn.request) or request

        if req then
            -- CASE 1: Using Executor Request (Synapse, Krnl, etc.)
            local response = req({
                Url = urlx,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })

            -- The response is a table. The actual text is usually in .Body
            --print("Server Status:", response.StatusCode)
            -- print("Server Message:", response.Body)

            return response.Body
        else
            -- CASE 2: Using Standard Roblox HttpService
            local response = _S.HttpService:PostAsync(urlx, body)

            -- PostAsync returns the body string directly
            -- print("Server Message:", response)

            return response
        end
    end)

    -- If the code failed to run (e.g. invalid URL or no internet)
    if success then
        local data = _S.HttpService:JSONDecode(result)
        --_Helper.JsonPrint(data)
        if data.invalidp then
            print("Invalid data detected")
        end

        if data.offn then
            -- print("User dissmiss")
        end
    else
        -- warn("Script Error:", result)
    end
end

Varz.SingleFruitDetails = function()
    local ls = {}
    local fruit_count = InventoryManager.GetFruitCount()
    -- print("Fruit count: ", fruit_count)
    if fruit_count == 1 then
        local fruit = InventoryManager.GetFruitRandomOrHeld()
        if fruit then
            local allatrr = fruit:GetAttributes()
            if allatrr then
                table.insert(ls, allatrr)
                -- print("Fruit added: ")
            else
                -- print("Fruit not added: ")
            end
        end
    end
    return ls
end

Varz.MakeDataForInventory = function()
    local fruits = {}
    local holding = {}

    -- collect fruits in backpack
    for _, item in ipairs(_S.Backpack:GetChildren()) do
        if InventoryManager.IsFruit(item) then
            table.insert(fruits, item.Name)
        end
    end

    -- the held tool
    local hold = InventoryManager.GetHeldTool()
    if hold and InventoryManager.IsFruit(hold) then
        table.insert(holding, hold.Name)
    end

    local cur_count, maxCount = GameDataManager.Inventory.GetPetsInventoryCounts()
    local inventory_dx = {
        current_pets = cur_count,
        max_pets = maxCount,
    }

    local _playersata = _S.LocalPlayer:GetAttributes()

    -- teams
    local datax = {
        fruits = fruits,
        fdetails = Varz.SingleFruitDetails(),
        holding = holding,
        username = _S.LocalPlayer.Name,
        uid = Varz.player_userid,
        hatching_team = InventoryManager.GetPetTeamData(FSettings.team3),
        seal_team = InventoryManager.GetPetTeamData(FSettings.team1),
        koi_team = InventoryManager.GetPetTeamData(FSettings.team2),
        bronto_team = InventoryManager.GetPetTeamData(FSettings.team4),
        inventory = inventory_dx,
        playerstatus = _playersata,
        is_pro = Varz.GetCheckIfPro(),
        serverv = _S.CurentV,
    }

    return datax
end


if TaskManager.task_sendhp then
    task.cancel(TaskManager.task_sendhp)
    TaskManager.task_sendhp = nil
end

-- #live
TaskManager.task_sendhp = task.spawn(function()
    while true do
        task.wait()
        -- print("started")
        if Varz.WAS_PRO_END then
            --print("pro ended")
            break
        end
        if Varz.IS_HATCHING then
            task.wait(3)
            --print("Hatching 1")
            continue
        end

        task.wait(25)

        local success, fal = pcall(function()
            local dx = Varz.MakeDataForInventory()
            _Helper.JsonPrint(dx)
        end)

        if not success then
            warn("er: ", fal)
        end
    end
end)
